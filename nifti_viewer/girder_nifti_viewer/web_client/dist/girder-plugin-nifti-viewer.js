var En = Object.defineProperty;
var Rs = (e) => {
  throw TypeError(e);
};
var Dn = (e, t, i) => t in e ? En(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var P = (e, t, i) => Dn(e, typeof t != "symbol" ? t + "" : t, i), Bi = (e, t, i) => t.has(e) || Rs("Cannot " + i);
var J = (e, t, i) => (Bi(e, t, "read from private field"), i ? i.call(e) : t.get(e)), gt = (e, t, i) => t.has(e) ? Rs("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, i), ft = (e, t, i, s) => (Bi(e, t, "write to private field"), s ? s.call(e, i) : t.set(e, i), i), Ui = (e, t, i) => (Bi(e, t, "access private method"), i);
import { getCurrentUser as Sn } from "@girder/core/auth";
import { AccessType as In } from "@girder/core/constants";
import Ps from "@girder/core/events";
import { restRequest as Sr } from "@girder/core/rest";
import { wrap as Tn } from "@girder/core/utilities/PluginUtils";
import Ir from "@girder/core/views/body/ItemView";
import Vn from "@girder/core/views/widgets/SearchFieldWidget";
import ve from "@girder/core/views/View";
import Bn from "@girder/core/models/Model";
const Un = Bn.extend({
  resourceName: "file",
  /**
   * Get volume ArrayBuffer with caching.
   * Returns a Promise that resolves to an ArrayBuffer.
   * The promise is cached, so subsequent calls return the same promise.
   * @returns {Promise<ArrayBuffer>}
   */
  getVolume: function() {
    return this._volumePromise || (this._volumePromise = this._loadVolume()), this._volumePromise;
  },
  /**
   * Get volume with progress tracking
   * @param {Function} onProgress - Callback (loaded, total) => void
   * @returns {Promise<ArrayBuffer>}
   */
  getVolumeWithProgress: function(e) {
    return this._volumePromise && this._volumeCompleted ? this._volumePromise.then((t) => (e && e(t.byteLength, t.byteLength), t)) : (this._volumePromise || (this._volumePromise = this._loadVolumeWithProgress(e), this._volumePromise.then(() => {
      this._volumeCompleted = !0;
    })), this._volumePromise);
  },
  /**
   * Internal method to download NIfTI file as ArrayBuffer.
   * @returns {Promise<ArrayBuffer>}
   * @private
   */
  _loadVolume: function() {
    const e = this.get("_id") || this.id;
    return e ? fetch(`/api/v1/file/${e}/download`, {
      method: "GET",
      credentials: "same-origin"
    }).then((t) => {
      if (!t.ok)
        throw new Error(`HTTP error! status: ${t.status}`);
      return t.arrayBuffer();
    }).catch((t) => {
      throw this._volumePromise = null, t;
    }) : Promise.reject(new Error("File ID not provided"));
  },
  /**
   * Load volume with progress tracking
   * @private
   * @param {Function} onProgress - Callback (loaded, total) => void
   * @returns {Promise<ArrayBuffer>}
   */
  _loadVolumeWithProgress: function(e) {
    const t = this.get("_id") || this.id;
    if (!t)
      return Promise.reject(new Error("File ID not provided"));
    const i = `/api/v1/file/${t}/download`;
    return fetch(i, {
      method: "GET",
      credentials: "same-origin"
    }).then((s) => {
      if (!s.ok)
        throw new Error(`HTTP ${s.status}: ${s.statusText}`);
      const r = s.headers.get("Content-Length"), a = r ? parseInt(r, 10) : 0;
      if (!s.body || !e || a === 0)
        return s.arrayBuffer();
      const n = s.body.getReader(), o = [];
      let l = 0;
      const c = () => n.read().then(({ done: h, value: f }) => {
        if (h) {
          const d = new Uint8Array(l);
          let u = 0;
          for (const m of o)
            d.set(m, u), u += m.length;
          return d.buffer;
        }
        return o.push(f), l += f.length, e(l, a), c();
      });
      return c();
    }).catch((s) => {
      throw this._volumePromise = null, this._volumeCompleted = !1, s;
    });
  },
  /**
   * Clear cached volume data.
   * Useful for memory management when the file is no longer needed.
   */
  clearCache: function() {
    this._volumePromise = null;
  }
});
var Rn = 1e-6, wt = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var e = 0, t = arguments.length; t--; )
    e += arguments[t] * arguments[t];
  return Math.sqrt(e);
});
function Ji() {
  var e = new wt(9);
  return wt != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;
}
function Pn(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;
}
function jt(e, t, i, s, r, a, n, o, l) {
  var c = new wt(9);
  return c[0] = e, c[1] = t, c[2] = i, c[3] = s, c[4] = r, c[5] = a, c[6] = n, c[7] = o, c[8] = l, c;
}
function Nn(e, t) {
  var i = t[0], s = t[1], r = t[2], a = t[3], n = t[4], o = t[5], l = t[6], c = t[7], h = t[8], f = h * n - o * c, d = -h * a + o * l, u = c * a - n * l, m = i * f + s * d + r * u;
  return m ? (m = 1 / m, e[0] = f * m, e[1] = (-h * s + r * c) * m, e[2] = (o * s - r * n) * m, e[3] = d * m, e[4] = (h * i - r * l) * m, e[5] = (-o * i + r * a) * m, e[6] = u * m, e[7] = (-c * i + s * l) * m, e[8] = (n * i - s * a) * m, e) : null;
}
function Tr(e, t, i) {
  var s = t[0], r = t[1], a = t[2], n = t[3], o = t[4], l = t[5], c = t[6], h = t[7], f = t[8], d = i[0], u = i[1], m = i[2], g = i[3], p = i[4], A = i[5], x = i[6], w = i[7], v = i[8];
  return e[0] = d * s + u * n + m * c, e[1] = d * r + u * o + m * h, e[2] = d * a + u * l + m * f, e[3] = g * s + p * n + A * c, e[4] = g * r + p * o + A * h, e[5] = g * a + p * l + A * f, e[6] = x * s + w * n + v * c, e[7] = x * r + w * o + v * h, e[8] = x * a + w * l + v * f, e;
}
function it() {
  var e = new wt(16);
  return wt != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e;
}
function mt(e) {
  var t = new wt(16);
  return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
}
function Ln(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
}
function Pt(e, t, i, s, r, a, n, o, l, c, h, f, d, u, m, g) {
  var p = new wt(16);
  return p[0] = e, p[1] = t, p[2] = i, p[3] = s, p[4] = r, p[5] = a, p[6] = n, p[7] = o, p[8] = l, p[9] = c, p[10] = h, p[11] = f, p[12] = d, p[13] = u, p[14] = m, p[15] = g, p;
}
function Vr(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function Ut(e, t) {
  if (e === t) {
    var i = t[1], s = t[2], r = t[3], a = t[6], n = t[7], o = t[11];
    e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = i, e[6] = t[9], e[7] = t[13], e[8] = s, e[9] = a, e[11] = t[14], e[12] = r, e[13] = n, e[14] = o;
  } else
    e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
  return e;
}
function Vt(e, t) {
  var i = t[0], s = t[1], r = t[2], a = t[3], n = t[4], o = t[5], l = t[6], c = t[7], h = t[8], f = t[9], d = t[10], u = t[11], m = t[12], g = t[13], p = t[14], A = t[15], x = i * o - s * n, w = i * l - r * n, v = i * c - a * n, F = s * l - r * o, C = s * c - a * o, b = r * c - a * l, y = h * g - f * m, E = h * p - d * m, S = h * A - u * m, D = f * p - d * g, M = f * A - u * g, B = d * A - u * p, T = x * B - w * M + v * D + F * S - C * E + b * y;
  return T ? (T = 1 / T, e[0] = (o * B - l * M + c * D) * T, e[1] = (r * M - s * B - a * D) * T, e[2] = (g * b - p * C + A * F) * T, e[3] = (d * C - f * b - u * F) * T, e[4] = (l * S - n * B - c * E) * T, e[5] = (i * B - r * S + a * E) * T, e[6] = (p * v - m * b - A * w) * T, e[7] = (h * b - d * v + u * w) * T, e[8] = (n * M - o * S + c * y) * T, e[9] = (s * S - i * M - a * y) * T, e[10] = (m * C - g * v + A * x) * T, e[11] = (f * v - h * C - u * x) * T, e[12] = (o * E - n * D - l * y) * T, e[13] = (i * D - s * E + r * y) * T, e[14] = (g * w - m * F - p * x) * T, e[15] = (h * F - f * w + d * x) * T, e) : null;
}
function re(e, t, i) {
  var s = t[0], r = t[1], a = t[2], n = t[3], o = t[4], l = t[5], c = t[6], h = t[7], f = t[8], d = t[9], u = t[10], m = t[11], g = t[12], p = t[13], A = t[14], x = t[15], w = i[0], v = i[1], F = i[2], C = i[3];
  return e[0] = w * s + v * o + F * f + C * g, e[1] = w * r + v * l + F * d + C * p, e[2] = w * a + v * c + F * u + C * A, e[3] = w * n + v * h + F * m + C * x, w = i[4], v = i[5], F = i[6], C = i[7], e[4] = w * s + v * o + F * f + C * g, e[5] = w * r + v * l + F * d + C * p, e[6] = w * a + v * c + F * u + C * A, e[7] = w * n + v * h + F * m + C * x, w = i[8], v = i[9], F = i[10], C = i[11], e[8] = w * s + v * o + F * f + C * g, e[9] = w * r + v * l + F * d + C * p, e[10] = w * a + v * c + F * u + C * A, e[11] = w * n + v * h + F * m + C * x, w = i[12], v = i[13], F = i[14], C = i[15], e[12] = w * s + v * o + F * f + C * g, e[13] = w * r + v * l + F * d + C * p, e[14] = w * a + v * c + F * u + C * A, e[15] = w * n + v * h + F * m + C * x, e;
}
function me(e, t, i) {
  var s = i[0], r = i[1], a = i[2], n, o, l, c, h, f, d, u, m, g, p, A;
  return t === e ? (e[12] = t[0] * s + t[4] * r + t[8] * a + t[12], e[13] = t[1] * s + t[5] * r + t[9] * a + t[13], e[14] = t[2] * s + t[6] * r + t[10] * a + t[14], e[15] = t[3] * s + t[7] * r + t[11] * a + t[15]) : (n = t[0], o = t[1], l = t[2], c = t[3], h = t[4], f = t[5], d = t[6], u = t[7], m = t[8], g = t[9], p = t[10], A = t[11], e[0] = n, e[1] = o, e[2] = l, e[3] = c, e[4] = h, e[5] = f, e[6] = d, e[7] = u, e[8] = m, e[9] = g, e[10] = p, e[11] = A, e[12] = n * s + h * r + m * a + t[12], e[13] = o * s + f * r + g * a + t[13], e[14] = l * s + d * r + p * a + t[14], e[15] = c * s + u * r + A * a + t[15]), e;
}
function Ns(e, t, i) {
  var s = i[0], r = i[1], a = i[2];
  return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * a, e[9] = t[9] * a, e[10] = t[10] * a, e[11] = t[11] * a, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
}
function ei(e, t, i) {
  var s = Math.sin(i), r = Math.cos(i), a = t[4], n = t[5], o = t[6], l = t[7], c = t[8], h = t[9], f = t[10], d = t[11];
  return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = a * r + c * s, e[5] = n * r + h * s, e[6] = o * r + f * s, e[7] = l * r + d * s, e[8] = c * r - a * s, e[9] = h * r - n * s, e[10] = f * r - o * s, e[11] = d * r - l * s, e;
}
function ii(e, t, i) {
  var s = Math.sin(i), r = Math.cos(i), a = t[0], n = t[1], o = t[2], l = t[3], c = t[4], h = t[5], f = t[6], d = t[7];
  return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = a * r + c * s, e[1] = n * r + h * s, e[2] = o * r + f * s, e[3] = l * r + d * s, e[4] = c * r - a * s, e[5] = h * r - n * s, e[6] = f * r - o * s, e[7] = d * r - l * s, e;
}
function kn(e, t, i) {
  var s = i[0], r = i[1], a = i[2], n = Math.hypot(s, r, a), o, l, c;
  return n < Rn ? null : (n = 1 / n, s *= n, r *= n, a *= n, o = Math.sin(t), l = Math.cos(t), c = 1 - l, e[0] = s * s * c + l, e[1] = r * s * c + a * o, e[2] = a * s * c - r * o, e[3] = 0, e[4] = s * r * c - a * o, e[5] = r * r * c + l, e[6] = a * r * c + s * o, e[7] = 0, e[8] = s * a * c + r * o, e[9] = r * a * c - s * o, e[10] = a * a * c + l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);
}
function On(e, t, i, s, r, a, n) {
  var o = 1 / (t - i), l = 1 / (s - r), c = 1 / (a - n);
  return e[0] = -2 * o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * c, e[11] = 0, e[12] = (t + i) * o, e[13] = (r + s) * l, e[14] = (n + a) * c, e[15] = 1, e;
}
var si = On;
function zn(e, t, i) {
  return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e[3] = t[3] * i, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = t[11] * i, e[12] = t[12] * i, e[13] = t[13] * i, e[14] = t[14] * i, e[15] = t[15] * i, e;
}
var Br = re;
function nt() {
  var e = new wt(3);
  return wt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e;
}
function Ot(e) {
  var t = new wt(3);
  return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;
}
function $t(e) {
  var t = e[0], i = e[1], s = e[2];
  return Math.hypot(t, i, s);
}
function O(e, t, i) {
  var s = new wt(3);
  return s[0] = e, s[1] = t, s[2] = i, s;
}
function Ls(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
}
function le(e, t, i) {
  return e[0] = t[0] + i[0], e[1] = t[1] + i[1], e[2] = t[2] + i[2], e;
}
function ot(e, t, i) {
  return e[0] = t[0] - i[0], e[1] = t[1] - i[1], e[2] = t[2] - i[2], e;
}
function hs(e, t, i) {
  return e[0] = Math.min(t[0], i[0]), e[1] = Math.min(t[1], i[1]), e[2] = Math.min(t[2], i[2]), e;
}
function fs(e, t, i) {
  return e[0] = Math.max(t[0], i[0]), e[1] = Math.max(t[1], i[1]), e[2] = Math.max(t[2], i[2]), e;
}
function Gn(e, t, i) {
  return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e;
}
function Yn(e, t) {
  var i = t[0] - e[0], s = t[1] - e[1], r = t[2] - e[2];
  return Math.hypot(i, s, r);
}
function Wn(e, t) {
  return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;
}
function Rt(e, t) {
  var i = t[0], s = t[1], r = t[2], a = i * i + s * s + r * r;
  return a > 0 && (a = 1 / Math.sqrt(a)), e[0] = t[0] * a, e[1] = t[1] * a, e[2] = t[2] * a, e;
}
function Kn(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function mi(e, t, i) {
  var s = t[0], r = t[1], a = t[2], n = i[0], o = i[1], l = i[2];
  return e[0] = r * l - a * o, e[1] = a * n - s * l, e[2] = s * o - r * n, e;
}
function Xn(e, t, i, s) {
  var r = t[0], a = t[1], n = t[2];
  return e[0] = r + s * (i[0] - r), e[1] = a + s * (i[1] - a), e[2] = n + s * (i[2] - n), e;
}
function ks(e, t, i) {
  var s = t[0], r = t[1], a = t[2];
  return e[0] = s * i[0] + r * i[3] + a * i[6], e[1] = s * i[1] + r * i[4] + a * i[7], e[2] = s * i[2] + r * i[5] + a * i[8], e;
}
function Ri(e, t) {
  var i = e[0], s = e[1], r = e[2], a = t[0], n = t[1], o = t[2], l = Math.sqrt(i * i + s * s + r * r), c = Math.sqrt(a * a + n * n + o * o), h = l * c, f = h && Kn(e, t) / h;
  return Math.acos(Math.min(Math.max(f, -1), 1));
}
var Os = ot, Le = $t;
(function() {
  var e = nt();
  return function(t, i, s, r, a, n) {
    var o, l;
    for (i || (i = 3), s || (s = 0), r ? l = Math.min(r * i + s, t.length) : l = t.length, o = s; o < l; o += i)
      e[0] = t[o], e[1] = t[o + 1], e[2] = t[o + 2], a(e, e, n), t[o] = e[0], t[o + 1] = e[1], t[o + 2] = e[2];
    return t;
  };
})();
function Wt() {
  var e = new wt(4);
  return wt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;
}
function Zt(e) {
  var t = new wt(4);
  return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;
}
function ht(e, t, i, s) {
  var r = new wt(4);
  return r[0] = e, r[1] = t, r[2] = i, r[3] = s, r;
}
function zs(e, t, i) {
  return e[0] = t[0] + i[0], e[1] = t[1] + i[1], e[2] = t[2] + i[2], e[3] = t[3] + i[3], e;
}
function qn(e, t, i) {
  return e[0] = t[0] - i[0], e[1] = t[1] - i[1], e[2] = t[2] - i[2], e[3] = t[3] - i[3], e;
}
function Hn(e, t, i) {
  return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e[3] = t[3] * i, e;
}
function Ct(e, t, i) {
  var s = t[0], r = t[1], a = t[2], n = t[3];
  return e[0] = i[0] * s + i[4] * r + i[8] * a + i[12] * n, e[1] = i[1] * s + i[5] * r + i[9] * a + i[13] * n, e[2] = i[2] * s + i[6] * r + i[10] * a + i[14] * n, e[3] = i[3] * s + i[7] * r + i[11] * a + i[15] * n, e;
}
var _n = qn;
(function() {
  var e = Wt();
  return function(t, i, s, r, a, n) {
    var o, l;
    for (i || (i = 4), s || (s = 0), r ? l = Math.min(r * i + s, t.length) : l = t.length, o = s; o < l; o += i)
      e[0] = t[o], e[1] = t[o + 1], e[2] = t[o + 2], e[3] = t[o + 3], a(e, e, n), t[o] = e[0], t[o + 1] = e[1], t[o + 2] = e[2], t[o + 3] = e[3];
    return t;
  };
})();
function Qn() {
  var e = new wt(2);
  return wt != Float32Array && (e[0] = 0, e[1] = 0), e;
}
function Gs(e, t) {
  var i = new wt(2);
  return i[0] = e, i[1] = t, i;
}
function jn(e, t, i) {
  return e[0] = t[0] * i, e[1] = t[1] * i, e;
}
function Ys(e) {
  var t = e[0], i = e[1];
  return Math.hypot(t, i);
}
function Zn(e, t) {
  var i = t[0], s = t[1], r = i * i + s * s;
  return r > 0 && (r = 1 / Math.sqrt(r)), e[0] = t[0] * r, e[1] = t[1] * r, e;
}
(function() {
  var e = Qn();
  return function(t, i, s, r, a, n) {
    var o, l;
    for (i || (i = 2), s || (s = 0), r ? l = Math.min(r * i + s, t.length) : l = t.length, o = s; o < l; o += i)
      e[0] = t[o], e[1] = t[o + 1], a(e, e, n), t[o] = e[0], t[o + 1] = e[1];
    return t;
  };
})();
var ae = 256, gi = [], ri;
for (; ae--; ) gi[ae] = (ae + 256).toString(16).substring(1);
function $i() {
  var e = 0, t, i = "";
  if (!ri || ae + 16 > 256) {
    for (ri = Array(e = 256); e--; ) ri[e] = 256 * Math.random() | 0;
    e = ae = 0;
  }
  for (; e < 16; e++)
    t = ri[ae + e], e == 6 ? i += gi[t & 15 | 64] : e == 8 ? i += gi[t & 63 | 128] : i += gi[t], e & 1 && e > 1 && e < 11 && (i += "-");
  return ae++, i;
}
function Jn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var $n = function(t, i) {
  var s = t.length;
  if (t === i) return !0;
  if (s !== i.length) return !1;
  for (var r = 0; r < s; r++)
    if (t[r] !== i[r])
      return !1;
  return !0;
};
const ta = /* @__PURE__ */ Jn($n), Ur = -1, Ei = 0, Ue = 1, yi = 2, ds = 3, us = 4, ms = 5, gs = 6, Rr = 7, Pr = 8, Ws = typeof self == "object" ? self : globalThis, ea = (e, t) => {
  const i = (r, a) => (e.set(a, r), r), s = (r) => {
    if (e.has(r))
      return e.get(r);
    const [a, n] = t[r];
    switch (a) {
      case Ei:
      case Ur:
        return i(n, r);
      case Ue: {
        const o = i([], r);
        for (const l of n)
          o.push(s(l));
        return o;
      }
      case yi: {
        const o = i({}, r);
        for (const [l, c] of n)
          o[s(l)] = s(c);
        return o;
      }
      case ds:
        return i(new Date(n), r);
      case us: {
        const { source: o, flags: l } = n;
        return i(new RegExp(o, l), r);
      }
      case ms: {
        const o = i(/* @__PURE__ */ new Map(), r);
        for (const [l, c] of n)
          o.set(s(l), s(c));
        return o;
      }
      case gs: {
        const o = i(/* @__PURE__ */ new Set(), r);
        for (const l of n)
          o.add(s(l));
        return o;
      }
      case Rr: {
        const { name: o, message: l } = n;
        return i(new Ws[o](l), r);
      }
      case Pr:
        return i(BigInt(n), r);
      case "BigInt":
        return i(Object(BigInt(n)), r);
      case "ArrayBuffer":
        return i(new Uint8Array(n).buffer, n);
      case "DataView": {
        const { buffer: o } = new Uint8Array(n);
        return i(new DataView(o), n);
      }
    }
    return i(new Ws[a](n), r);
  };
  return s;
}, ia = (e) => ea(/* @__PURE__ */ new Map(), e)(0), de = "", { toString: sa } = {}, { keys: ra } = Object, Ce = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Ei, t];
  const i = sa.call(e).slice(8, -1);
  switch (i) {
    case "Array":
      return [Ue, de];
    case "Object":
      return [yi, de];
    case "Date":
      return [ds, de];
    case "RegExp":
      return [us, de];
    case "Map":
      return [ms, de];
    case "Set":
      return [gs, de];
    case "DataView":
      return [Ue, i];
  }
  return i.includes("Array") ? [Ue, i] : i.includes("Error") ? [Rr, i] : [yi, i];
}, ni = ([e, t]) => e === Ei && (t === "function" || t === "symbol"), na = (e, t, i, s) => {
  const r = (n, o) => {
    const l = s.push(n) - 1;
    return i.set(o, l), l;
  }, a = (n) => {
    if (i.has(n))
      return i.get(n);
    let [o, l] = Ce(n);
    switch (o) {
      case Ei: {
        let h = n;
        switch (l) {
          case "bigint":
            o = Pr, h = n.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            h = null;
            break;
          case "undefined":
            return r([Ur], n);
        }
        return r([o, h], n);
      }
      case Ue: {
        if (l) {
          let d = n;
          return l === "DataView" ? d = new Uint8Array(n.buffer) : l === "ArrayBuffer" && (d = new Uint8Array(n)), r([l, [...d]], n);
        }
        const h = [], f = r([o, h], n);
        for (const d of n)
          h.push(a(d));
        return f;
      }
      case yi: {
        if (l)
          switch (l) {
            case "BigInt":
              return r([l, n.toString()], n);
            case "Boolean":
            case "Number":
            case "String":
              return r([l, n.valueOf()], n);
          }
        if (t && "toJSON" in n)
          return a(n.toJSON());
        const h = [], f = r([o, h], n);
        for (const d of ra(n))
          (e || !ni(Ce(n[d]))) && h.push([a(d), a(n[d])]);
        return f;
      }
      case ds:
        return r([o, n.toISOString()], n);
      case us: {
        const { source: h, flags: f } = n;
        return r([o, { source: h, flags: f }], n);
      }
      case ms: {
        const h = [], f = r([o, h], n);
        for (const [d, u] of n)
          (e || !(ni(Ce(d)) || ni(Ce(u)))) && h.push([a(d), a(u)]);
        return f;
      }
      case gs: {
        const h = [], f = r([o, h], n);
        for (const d of n)
          (e || !ni(Ce(d))) && h.push(a(d));
        return f;
      }
    }
    const { message: c } = n;
    return r([o, { name: l, message: c }], n);
  };
  return a;
}, aa = (e, { json: t, lossy: i } = {}) => {
  const s = [];
  return na(!(t || i), !!t, /* @__PURE__ */ new Map(), s)(e), s;
};
var vt = Uint8Array, xe = Uint16Array, oa = Int32Array, Nr = new vt([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Lr = new vt([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), la = new vt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), kr = function(e, t) {
  for (var i = new xe(31), s = 0; s < 31; ++s)
    i[s] = t += 1 << e[s - 1];
  for (var r = new oa(i[30]), s = 1; s < 30; ++s)
    for (var a = i[s]; a < i[s + 1]; ++a)
      r[a] = a - i[s] << 5 | s;
  return { b: i, r };
}, Or = kr(Nr, 2), zr = Or.b, ca = Or.r;
zr[28] = 258, ca[258] = 28;
var ha = kr(Lr, 0), fa = ha.b, ts = new xe(32768);
for (var lt = 0; lt < 32768; ++lt) {
  var Kt = (lt & 43690) >> 1 | (lt & 21845) << 1;
  Kt = (Kt & 52428) >> 2 | (Kt & 13107) << 2, Kt = (Kt & 61680) >> 4 | (Kt & 3855) << 4, ts[lt] = ((Kt & 65280) >> 8 | (Kt & 255) << 8) >> 1;
}
var Re = function(e, t, i) {
  for (var s = e.length, r = 0, a = new xe(t); r < s; ++r)
    e[r] && ++a[e[r] - 1];
  var n = new xe(t);
  for (r = 1; r < t; ++r)
    n[r] = n[r - 1] + a[r - 1] << 1;
  var o;
  if (i) {
    o = new xe(1 << t);
    var l = 15 - t;
    for (r = 0; r < s; ++r)
      if (e[r])
        for (var c = r << 4 | e[r], h = t - e[r], f = n[e[r] - 1]++ << h, d = f | (1 << h) - 1; f <= d; ++f)
          o[ts[f] >> l] = c;
  } else
    for (o = new xe(s), r = 0; r < s; ++r)
      e[r] && (o[r] = ts[n[e[r] - 1]++] >> 15 - e[r]);
  return o;
}, Ze = new vt(288);
for (var lt = 0; lt < 144; ++lt)
  Ze[lt] = 8;
for (var lt = 144; lt < 256; ++lt)
  Ze[lt] = 9;
for (var lt = 256; lt < 280; ++lt)
  Ze[lt] = 7;
for (var lt = 280; lt < 288; ++lt)
  Ze[lt] = 8;
var Gr = new vt(32);
for (var lt = 0; lt < 32; ++lt)
  Gr[lt] = 5;
var da = /* @__PURE__ */ Re(Ze, 9, 1), ua = /* @__PURE__ */ Re(Gr, 5, 1), Pi = function(e) {
  for (var t = e[0], i = 1; i < e.length; ++i)
    e[i] > t && (t = e[i]);
  return t;
}, Nt = function(e, t, i) {
  var s = t / 8 | 0;
  return (e[s] | e[s + 1] << 8) >> (t & 7) & i;
}, Ni = function(e, t) {
  var i = t / 8 | 0;
  return (e[i] | e[i + 1] << 8 | e[i + 2] << 16) >> (t & 7);
}, Yr = function(e) {
  return (e + 7) / 8 | 0;
}, pi = function(e, t, i) {
  return (t == null || t < 0) && (t = 0), (i == null || i > e.length) && (i = e.length), new vt(e.subarray(t, i));
}, ma = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], Dt = function(e, t, i) {
  var s = new Error(t || ma[e]);
  if (s.code = e, Error.captureStackTrace && Error.captureStackTrace(s, Dt), !i)
    throw s;
  return s;
}, Di = function(e, t, i, s) {
  var r = e.length, a = 0;
  if (!r || t.f && !t.l)
    return i || new vt(0);
  var n = !i, o = n || t.i != 2, l = t.i;
  n && (i = new vt(r * 3));
  var c = function(St) {
    var Ft = i.length;
    if (St > Ft) {
      var Vi = new vt(Math.max(Ft * 2, St));
      Vi.set(i), i = Vi;
    }
  }, h = t.f || 0, f = t.p || 0, d = t.b || 0, u = t.l, m = t.d, g = t.m, p = t.n, A = r * 8;
  do {
    if (!u) {
      h = Nt(e, f, 1);
      var x = Nt(e, f + 1, 3);
      if (f += 3, x)
        if (x == 1)
          u = da, m = ua, g = 9, p = 5;
        else if (x == 2) {
          var C = Nt(e, f, 31) + 257, b = Nt(e, f + 10, 15) + 4, y = C + Nt(e, f + 5, 31) + 1;
          f += 14;
          for (var E = new vt(y), S = new vt(19), D = 0; D < b; ++D)
            S[la[D]] = Nt(e, f + D * 3, 7);
          f += b * 3;
          for (var M = Pi(S), B = (1 << M) - 1, T = Re(S, M, 1), D = 0; D < y; ) {
            var U = T[Nt(e, f, B)];
            f += U & 15;
            var w = U >> 4;
            if (w < 16)
              E[D++] = w;
            else {
              var R = 0, N = 0;
              for (w == 16 ? (N = 3 + Nt(e, f, 3), f += 2, R = E[D - 1]) : w == 17 ? (N = 3 + Nt(e, f, 7), f += 3) : w == 18 && (N = 11 + Nt(e, f, 127), f += 7); N--; )
                E[D++] = R;
            }
          }
          var k = E.subarray(0, C), L = E.subarray(C);
          g = Pi(k), p = Pi(L), u = Re(k, g, 1), m = Re(L, p, 1);
        } else
          Dt(1);
      else {
        var w = Yr(f) + 4, v = e[w - 4] | e[w - 3] << 8, F = w + v;
        if (F > r) {
          l && Dt(0);
          break;
        }
        o && c(d + v), i.set(e.subarray(w, F), d), t.b = d += v, t.p = f = F * 8, t.f = h;
        continue;
      }
      if (f > A) {
        l && Dt(0);
        break;
      }
    }
    o && c(d + 131072);
    for (var q = (1 << g) - 1, _ = (1 << p) - 1, z = f; ; z = f) {
      var R = u[Ni(e, f) & q], K = R >> 4;
      if (f += R & 15, f > A) {
        l && Dt(0);
        break;
      }
      if (R || Dt(2), K < 256)
        i[d++] = K;
      else if (K == 256) {
        z = f, u = null;
        break;
      } else {
        var W = K - 254;
        if (K > 264) {
          var D = K - 257, $ = Nr[D];
          W = Nt(e, f, (1 << $) - 1) + zr[D], f += $;
        }
        var tt = m[Ni(e, f) & _], at = tt >> 4;
        tt || Dt(3), f += tt & 15;
        var L = fa[at];
        if (at > 3) {
          var $ = Lr[at];
          L += Ni(e, f) & (1 << $) - 1, f += $;
        }
        if (f > A) {
          l && Dt(0);
          break;
        }
        o && c(d + 131072);
        var ut = d + W;
        if (d < L) {
          var bt = a - L, xt = Math.min(L, ut);
          for (bt + d < 0 && Dt(3); d < xt; ++d)
            i[d] = s[bt + d];
        }
        for (; d < ut; ++d)
          i[d] = i[d - L];
      }
    }
    t.l = u, t.p = z, t.b = d, t.f = h, u && (h = 1, t.m = g, t.d = m, t.n = p);
  } while (!h);
  return d != i.length && n ? pi(i, 0, d) : i.subarray(0, d);
}, ga = /* @__PURE__ */ new vt(0), Wr = function(e) {
  (e[0] != 31 || e[1] != 139 || e[2] != 8) && Dt(6, "invalid gzip data");
  var t = e[3], i = 10;
  t & 4 && (i += (e[10] | e[11] << 8) + 2);
  for (var s = (t >> 3 & 1) + (t >> 4 & 1); s > 0; s -= !e[i++])
    ;
  return i + (t & 2);
}, pa = function(e) {
  var t = e.length;
  return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;
}, Aa = function(e, t) {
  return ((e[0] & 15) != 8 || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31) && Dt(6, "invalid zlib data"), (e[1] >> 5 & 1) == 1 && Dt(6, "invalid zlib data: " + (e[1] & 32 ? "need" : "unexpected") + " dictionary"), (e[1] >> 3 & 4) + 2;
}, Li = /* @__PURE__ */ function() {
  function e(t, i) {
    typeof t == "function" && (i = t, t = {}), this.ondata = i;
    var s = t && t.dictionary && t.dictionary.subarray(-32768);
    this.s = { i: 0, b: s ? s.length : 0 }, this.o = new vt(32768), this.p = new vt(0), s && this.o.set(s);
  }
  return e.prototype.e = function(t) {
    if (this.ondata || Dt(5), this.d && Dt(4), !this.p.length)
      this.p = t;
    else if (t.length) {
      var i = new vt(this.p.length + t.length);
      i.set(this.p), i.set(t, this.p.length), this.p = i;
    }
  }, e.prototype.c = function(t) {
    this.s.i = +(this.d = t || !1);
    var i = this.s.b, s = Di(this.p, this.s, this.o);
    this.ondata(pi(s, i, this.s.b), this.d), this.o = pi(s, this.s.b - 32768), this.s.b = this.o.length, this.p = pi(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, e.prototype.push = function(t, i) {
    this.e(t), this.c(i);
  }, e;
}();
function xa(e, t) {
  return Di(e, { i: 2 }, t, t);
}
var va = /* @__PURE__ */ function() {
  function e(t, i) {
    this.v = 1, this.r = 0, Li.call(this, t, i);
  }
  return e.prototype.push = function(t, i) {
    if (Li.prototype.e.call(this, t), this.r += t.length, this.v) {
      var s = this.p.subarray(this.v - 1), r = s.length > 3 ? Wr(s) : 4;
      if (r > s.length) {
        if (!i)
          return;
      } else this.v > 1 && this.onmember && this.onmember(this.r - s.length);
      this.p = s.subarray(r), this.v = 0;
    }
    Li.prototype.c.call(this, i), this.s.f && !this.s.l && !i && (this.v = Yr(this.s.p) + 9, this.s = { i: 0 }, this.o = new vt(0), this.push(new vt(0), i));
  }, e;
}();
function wa(e, t) {
  var i = Wr(e);
  return i + 8 > e.length && Dt(6, "invalid gzip data"), Di(e.subarray(i, -8), { i: 2 }, new vt(pa(e)), t);
}
function ba(e, t) {
  return Di(e.subarray(Aa(e), -4), { i: 2 }, t, t);
}
function ya(e, t) {
  return e[0] == 31 && e[1] == 139 && e[2] == 8 ? wa(e, t) : (e[0] & 15) != 8 || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? xa(e, t) : ba(e, t);
}
var Ca = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Fa = 0;
try {
  Ca.decode(ga, { stream: !0 }), Fa = 1;
} catch {
}
class Kr {
  constructor(t, i, s, r) {
    P(this, "esize");
    P(this, "ecode");
    P(this, "edata");
    P(this, "littleEndian");
    if (t % 16 != 0)
      throw new Error("This does not appear to be a NIFTI extension");
    this.esize = t, this.ecode = i, this.edata = s, this.littleEndian = r;
  }
  /**
   * Returns extension as ArrayBuffer.
   * @returns {ArrayBuffer}
   */
  toArrayBuffer() {
    let t = new Uint8Array(this.esize), i = new Uint8Array(this.edata);
    t.set(i, 8);
    let s = new DataView(t.buffer);
    return s.setInt32(0, this.esize, this.littleEndian), s.setInt32(4, this.ecode, this.littleEndian), t.buffer;
  }
}
const Et = class Et {
  /*** Static methods ***/
  static getStringAt(t, i, s) {
    var r = "", a, n;
    for (a = i; a < s; a += 1)
      n = t.getUint8(a), n !== 0 && (r += String.fromCharCode(n));
    return r;
  }
  static getIntAt(t, i, s) {
    return t.getInt32(i, s);
  }
  static getFloatAt(t, i, s) {
    return t.getFloat32(i, s);
  }
  static getDoubleAt(t, i, s) {
    return t.getFloat64(i, s);
  }
  static getInt64At(t, i, s) {
    const r = t.getUint32(i, s), a = t.getInt32(i + 4, s);
    let n;
    return s ? n = a * 2 ** 32 + r : n = r * 2 ** 32 + a, a < 0 && (n += -1 * 2 ** 32 * 2 ** 32), n;
  }
  static getUint64At(t, i, s) {
    const r = t.getUint32(i + (s ? 0 : 4), s), a = t.getUint32(i + (s ? 4 : 0), s);
    return s ? a * 2 ** 32 + r : r * 2 ** 32 + a;
  }
  static getExtensionsAt(t, i, s, r) {
    let a = [], n = i;
    for (; n < r; ) {
      let o = s, l = Et.getIntAt(t, n, s);
      if (!l)
        break;
      if (l + n > r && (o = !o, l = Et.getIntAt(t, n, o), l + n > r))
        throw new Error("This does not appear to be a valid NIFTI extension");
      if (l % 16 != 0)
        throw new Error("This does not appear to be a NIFTI extension");
      let c = Et.getIntAt(t, n + 4, o), h = t.buffer.slice(n + 8, n + l), f = new Kr(l, c, h, o);
      a.push(f), n += l;
    }
    return a;
  }
  static toArrayBuffer(t) {
    var i, s, r;
    for (i = new ArrayBuffer(t.length), s = new Uint8Array(i), r = 0; r < t.length; r += 1)
      s[r] = t[r];
    return i;
  }
  static isString(t) {
    return typeof t == "string" || t instanceof String;
  }
  static formatNumber(t, i = void 0) {
    let s;
    return Et.isString(t) ? s = Number(t) : s = t, i ? s = s.toPrecision(5) : s = s.toPrecision(7), parseFloat(s);
  }
  // http://stackoverflow.com/questions/18638900/javascript-crc32
  static makeCRCTable() {
    let t, i = [];
    for (var s = 0; s < 256; s++) {
      t = s;
      for (var r = 0; r < 8; r++)
        t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
      i[s] = t;
    }
    return i;
  }
  static crc32(t) {
    Et.crcTable || (Et.crcTable = Et.makeCRCTable());
    const i = Et.crcTable;
    let s = -1;
    for (var r = 0; r < t.byteLength; r++)
      s = s >>> 8 ^ i[(s ^ t.getUint8(r)) & 255];
    return (s ^ -1) >>> 0;
  }
};
/*** Static Pseudo-constants ***/
P(Et, "crcTable", null), P(Et, "GUNZIP_MAGIC_COOKIE1", 31), P(Et, "GUNZIP_MAGIC_COOKIE2", 139), P(Et, "getByteAt", function(t, i) {
  return t.getUint8(i);
}), P(Et, "getShortAt", function(t, i, s) {
  return t.getInt16(i, s);
});
let G = Et;
const Y = class Y {
  constructor() {
    P(this, "littleEndian", !1);
    P(this, "dim_info", 0);
    P(this, "dims", []);
    P(this, "intent_p1", 0);
    P(this, "intent_p2", 0);
    P(this, "intent_p3", 0);
    P(this, "intent_code", 0);
    P(this, "datatypeCode", 0);
    P(this, "numBitsPerVoxel", 0);
    P(this, "slice_start", 0);
    P(this, "slice_end", 0);
    P(this, "slice_code", 0);
    P(this, "pixDims", []);
    P(this, "vox_offset", 0);
    P(this, "scl_slope", 1);
    P(this, "scl_inter", 0);
    P(this, "xyzt_units", 0);
    P(this, "cal_max", 0);
    P(this, "cal_min", 0);
    P(this, "slice_duration", 0);
    P(this, "toffset", 0);
    P(this, "description", "");
    P(this, "aux_file", "");
    P(this, "intent_name", "");
    P(this, "qform_code", 0);
    P(this, "sform_code", 0);
    P(this, "quatern_a", 0);
    P(this, "quatern_b", 0);
    P(this, "quatern_c", 0);
    P(this, "quatern_d", 0);
    P(this, "qoffset_x", 0);
    P(this, "qoffset_y", 0);
    P(this, "qoffset_z", 0);
    P(this, "affine", [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ]);
    P(this, "qfac", 1);
    P(this, "quatern_R");
    P(this, "magic", "0");
    P(this, "isHDR", !1);
    P(this, "extensionFlag", [0, 0, 0, 0]);
    P(this, "extensionSize", 0);
    P(this, "extensionCode", 0);
    P(this, "extensions", []);
    /**
     * Returns a human-readable string of datatype.
     * @param {number} code
     * @returns {string}
     */
    P(this, "getDatatypeCodeString", function(t) {
      return t === Y.TYPE_UINT8 ? "1-Byte Unsigned Integer" : t === Y.TYPE_INT16 ? "2-Byte Signed Integer" : t === Y.TYPE_INT32 ? "4-Byte Signed Integer" : t === Y.TYPE_FLOAT32 ? "4-Byte Float" : t === Y.TYPE_FLOAT64 ? "8-Byte Float" : t === Y.TYPE_RGB24 ? "RGB" : t === Y.TYPE_INT8 ? "1-Byte Signed Integer" : t === Y.TYPE_UINT16 ? "2-Byte Unsigned Integer" : t === Y.TYPE_UINT32 ? "4-Byte Unsigned Integer" : t === Y.TYPE_INT64 ? "8-Byte Signed Integer" : t === Y.TYPE_UINT64 ? "8-Byte Unsigned Integer" : "Unknown";
    });
    /**
     * Returns a human-readable string of transform type.
     * @param {number} code
     * @returns {string}
     */
    P(this, "getTransformCodeString", function(t) {
      return t === Y.XFORM_SCANNER_ANAT ? "Scanner" : t === Y.XFORM_ALIGNED_ANAT ? "Aligned" : t === Y.XFORM_TALAIRACH ? "Talairach" : t === Y.XFORM_MNI_152 ? "MNI" : "Unknown";
    });
    /**
     * Returns a human-readable string of spatial and temporal units.
     * @param {number} code
     * @returns {string}
     */
    P(this, "getUnitsCodeString", function(t) {
      return t === Y.UNITS_METER ? "Meters" : t === Y.UNITS_MM ? "Millimeters" : t === Y.UNITS_MICRON ? "Microns" : t === Y.UNITS_SEC ? "Seconds" : t === Y.UNITS_MSEC ? "Milliseconds" : t === Y.UNITS_USEC ? "Microseconds" : t === Y.UNITS_HZ ? "Hz" : t === Y.UNITS_PPM ? "PPM" : t === Y.UNITS_RADS ? "Rads" : "Unknown";
    });
    P(this, "nifti_mat33_mul", function(t, i) {
      var s = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
      ], r, a;
      for (r = 0; r < 3; r += 1)
        for (a = 0; a < 3; a += 1)
          s[r][a] = t[r][0] * i[0][a] + t[r][1] * i[1][a] + t[r][2] * i[2][a];
      return s;
    });
    P(this, "nifti_mat33_determ", function(t) {
      var i, s, r, a, n, o, l, c, h;
      return i = t[0][0], s = t[0][1], r = t[0][2], a = t[1][0], n = t[1][1], o = t[1][2], l = t[2][0], c = t[2][1], h = t[2][2], i * n * h - i * c * o - a * s * h + a * c * r + l * s * o - l * n * r;
    });
  }
  /*** Prototype Methods ***/
  /**
   * Reads the header data.
   * @param {ArrayBuffer} data
   */
  readHeader(t) {
    var i = new DataView(t), s = G.getIntAt(i, 0, this.littleEndian), r, a, n, o;
    if (s !== Y.MAGIC_COOKIE && (this.littleEndian = !0, s = G.getIntAt(i, 0, this.littleEndian)), s !== Y.MAGIC_COOKIE)
      throw new Error("This does not appear to be a NIFTI file!");
    for (this.dim_info = G.getByteAt(i, 39), r = 0; r < 8; r += 1)
      o = 40 + r * 2, this.dims[r] = G.getShortAt(i, o, this.littleEndian);
    for (this.intent_p1 = G.getFloatAt(i, 56, this.littleEndian), this.intent_p2 = G.getFloatAt(i, 60, this.littleEndian), this.intent_p3 = G.getFloatAt(i, 64, this.littleEndian), this.intent_code = G.getShortAt(i, 68, this.littleEndian), this.datatypeCode = G.getShortAt(i, 70, this.littleEndian), this.numBitsPerVoxel = G.getShortAt(i, 72, this.littleEndian), this.slice_start = G.getShortAt(i, 74, this.littleEndian), r = 0; r < 8; r += 1)
      o = 76 + r * 4, this.pixDims[r] = G.getFloatAt(i, o, this.littleEndian);
    if (this.vox_offset = G.getFloatAt(i, 108, this.littleEndian), this.scl_slope = G.getFloatAt(i, 112, this.littleEndian), this.scl_inter = G.getFloatAt(i, 116, this.littleEndian), this.slice_end = G.getShortAt(i, 120, this.littleEndian), this.slice_code = G.getByteAt(i, 122), this.xyzt_units = G.getByteAt(i, 123), this.cal_max = G.getFloatAt(i, 124, this.littleEndian), this.cal_min = G.getFloatAt(i, 128, this.littleEndian), this.slice_duration = G.getFloatAt(i, 132, this.littleEndian), this.toffset = G.getFloatAt(i, 136, this.littleEndian), this.description = G.getStringAt(i, 148, 228), this.aux_file = G.getStringAt(i, 228, 252), this.qform_code = G.getShortAt(i, 252, this.littleEndian), this.sform_code = G.getShortAt(i, 254, this.littleEndian), this.quatern_b = G.getFloatAt(i, 256, this.littleEndian), this.quatern_c = G.getFloatAt(i, 260, this.littleEndian), this.quatern_d = G.getFloatAt(i, 264, this.littleEndian), this.quatern_a = Math.sqrt(1 - (Math.pow(this.quatern_b, 2) + Math.pow(this.quatern_c, 2) + Math.pow(this.quatern_d, 2))), this.qoffset_x = G.getFloatAt(i, 268, this.littleEndian), this.qoffset_y = G.getFloatAt(i, 272, this.littleEndian), this.qoffset_z = G.getFloatAt(i, 276, this.littleEndian), this.qform_code < 1 && this.sform_code < 1 && (this.affine[0][0] = this.pixDims[1], this.affine[1][1] = this.pixDims[2], this.affine[2][2] = this.pixDims[3]), this.qform_code > 0 && this.sform_code < this.qform_code) {
      const l = this.quatern_a, c = this.quatern_b, h = this.quatern_c, f = this.quatern_d;
      for (this.qfac = this.pixDims[0] === 0 ? 1 : this.pixDims[0], this.quatern_R = [
        [l * l + c * c - h * h - f * f, 2 * c * h - 2 * l * f, 2 * c * f + 2 * l * h],
        [2 * c * h + 2 * l * f, l * l + h * h - c * c - f * f, 2 * h * f - 2 * l * c],
        [2 * c * f - 2 * l * h, 2 * h * f + 2 * l * c, l * l + f * f - h * h - c * c]
      ], a = 0; a < 3; a += 1)
        for (n = 0; n < 3; n += 1)
          this.affine[a][n] = this.quatern_R[a][n] * this.pixDims[n + 1], n === 2 && (this.affine[a][n] *= this.qfac);
      this.affine[0][3] = this.qoffset_x, this.affine[1][3] = this.qoffset_y, this.affine[2][3] = this.qoffset_z;
    } else if (this.sform_code > 0)
      for (a = 0; a < 3; a += 1)
        for (n = 0; n < 4; n += 1)
          o = 280 + (a * 4 + n) * 4, this.affine[a][n] = G.getFloatAt(i, o, this.littleEndian);
    if (this.affine[3][0] = 0, this.affine[3][1] = 0, this.affine[3][2] = 0, this.affine[3][3] = 1, this.intent_name = G.getStringAt(i, 328, 344), this.magic = G.getStringAt(i, 344, 348), this.isHDR = this.magic === String.fromCharCode.apply(null, Y.MAGIC_NUMBER2), i.byteLength > Y.MAGIC_COOKIE) {
      this.extensionFlag[0] = G.getByteAt(i, 348), this.extensionFlag[1] = G.getByteAt(i, 349), this.extensionFlag[2] = G.getByteAt(i, 350), this.extensionFlag[3] = G.getByteAt(i, 351);
      let l = !0;
      !this.isHDR && this.vox_offset <= 352 && (l = !1), i.byteLength <= 368 && (l = !1), l && this.extensionFlag[0] && (this.extensions = G.getExtensionsAt(i, this.getExtensionLocation(), this.littleEndian, this.vox_offset), this.extensionSize = this.extensions[0].esize, this.extensionCode = this.extensions[0].ecode);
    }
  }
  /**
   * Returns a formatted string of header fields.
   * @returns {string}
   */
  toFormattedString() {
    var t = G.formatNumber, i = "";
    return i += "Dim Info = " + this.dim_info + `
`, i += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + `
`, i += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + `
`, i += "Intent Code = " + this.intent_code + `
`, i += "Datatype = " + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + `)
`, i += "Bits Per Voxel = " + this.numBitsPerVoxel + `
`, i += "Slice Start = " + this.slice_start + `
`, i += "Voxel Dimensions (1-8): " + t(this.pixDims[0]) + ", " + t(this.pixDims[1]) + ", " + t(this.pixDims[2]) + ", " + t(this.pixDims[3]) + ", " + t(this.pixDims[4]) + ", " + t(this.pixDims[5]) + ", " + t(this.pixDims[6]) + ", " + t(this.pixDims[7]) + `
`, i += "Image Offset = " + this.vox_offset + `
`, i += "Data Scale:  Slope = " + t(this.scl_slope) + "  Intercept = " + t(this.scl_inter) + `
`, i += "Slice End = " + this.slice_end + `
`, i += "Slice Code = " + this.slice_code + `
`, i += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(Y.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(Y.TEMPORAL_UNITS_MASK & this.xyzt_units) + `)
`, i += "Display Range:  Max = " + t(this.cal_max) + "  Min = " + t(this.cal_min) + `
`, i += "Slice Duration = " + this.slice_duration + `
`, i += "Time Axis Shift = " + this.toffset + `
`, i += 'Description: "' + this.description + `"
`, i += 'Auxiliary File: "' + this.aux_file + `"
`, i += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + `)
`, i += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + `)
`, i += "Quaternion Parameters:  b = " + t(this.quatern_b) + "  c = " + t(this.quatern_c) + "  d = " + t(this.quatern_d) + `
`, i += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + `
`, i += "S-Form Parameters X: " + t(this.affine[0][0]) + ", " + t(this.affine[0][1]) + ", " + t(this.affine[0][2]) + ", " + t(this.affine[0][3]) + `
`, i += "S-Form Parameters Y: " + t(this.affine[1][0]) + ", " + t(this.affine[1][1]) + ", " + t(this.affine[1][2]) + ", " + t(this.affine[1][3]) + `
`, i += "S-Form Parameters Z: " + t(this.affine[2][0]) + ", " + t(this.affine[2][1]) + ", " + t(this.affine[2][2]) + ", " + t(this.affine[2][3]) + `
`, i += 'Intent Name: "' + this.intent_name + `"
`, this.extensionFlag[0] && (i += "Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + `
`), i;
  }
  /**
   * Returns the qform matrix.
   * @returns {Array.<Array.<number>>}
   */
  getQformMat() {
    return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x, this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
  }
  /**
   * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
   * @param {number} qb
   * @param {number} qc
   * @param {number} qd
   * @param {number} qx
   * @param {number} qy
   * @param {number} qz
   * @param {number} dx
   * @param {number} dy
   * @param {number} dz
   * @param {number} qfac
   * @returns {Array.<Array.<number>>}
   */
  convertNiftiQFormToNiftiSForm(t, i, s, r, a, n, o, l, c, h) {
    var f = [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ], d, u = t, m = i, g = s, p, A, x;
    return f[3][0] = f[3][1] = f[3][2] = 0, f[3][3] = 1, d = 1 - (u * u + m * m + g * g), d < 1e-7 ? (d = 1 / Math.sqrt(u * u + m * m + g * g), u *= d, m *= d, g *= d, d = 0) : d = Math.sqrt(d), p = o > 0 ? o : 1, A = l > 0 ? l : 1, x = c > 0 ? c : 1, h < 0 && (x = -x), f[0][0] = (d * d + u * u - m * m - g * g) * p, f[0][1] = 2 * (u * m - d * g) * A, f[0][2] = 2 * (u * g + d * m) * x, f[1][0] = 2 * (u * m + d * g) * p, f[1][1] = (d * d + m * m - u * u - g * g) * A, f[1][2] = 2 * (m * g - d * u) * x, f[2][0] = 2 * (u * g - d * m) * p, f[2][1] = 2 * (m * g + d * u) * A, f[2][2] = (d * d + g * g - m * m - u * u) * x, f[0][3] = r, f[1][3] = a, f[2][3] = n, f;
  }
  /**
   * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
   * @param {Array.<Array.<number>>} R
   * @returns {string}
   */
  convertNiftiSFormToNEMA(t) {
    var i, s, r, a, n, o, l, c, h, f, d, u, m, g, p, A, x, w, v, F, C, b, y, E, S, D, M, B, T, U, R, N, k, L;
    if (p = 0, M = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ], B = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ], i = t[0][0], s = t[0][1], r = t[0][2], a = t[1][0], n = t[1][1], o = t[1][2], l = t[2][0], c = t[2][1], h = t[2][2], f = Math.sqrt(i * i + a * a + l * l), f === 0 || (i /= f, a /= f, l /= f, f = Math.sqrt(s * s + n * n + c * c), f === 0))
      return null;
    if (s /= f, n /= f, c /= f, f = i * s + a * n + l * c, Math.abs(f) > 1e-4) {
      if (s -= f * i, n -= f * a, c -= f * l, f = Math.sqrt(s * s + n * n + c * c), f === 0)
        return null;
      s /= f, n /= f, c /= f;
    }
    if (f = Math.sqrt(r * r + o * o + h * h), f === 0 ? (r = a * c - l * n, o = l * s - c * i, h = i * n - a * s) : (r /= f, o /= f, h /= f), f = i * r + a * o + l * h, Math.abs(f) > 1e-4) {
      if (r -= f * i, o -= f * a, h -= f * l, f = Math.sqrt(r * r + o * o + h * h), f === 0)
        return null;
      r /= f, o /= f, h /= f;
    }
    if (f = s * r + n * o + c * h, Math.abs(f) > 1e-4) {
      if (r -= f * s, o -= f * n, h -= f * c, f = Math.sqrt(r * r + o * o + h * h), f === 0)
        return null;
      r /= f, o /= f, h /= f;
    }
    if (M[0][0] = i, M[0][1] = s, M[0][2] = r, M[1][0] = a, M[1][1] = n, M[1][2] = o, M[2][0] = l, M[2][1] = c, M[2][2] = h, d = this.nifti_mat33_determ(M), d === 0)
      return null;
    for (D = -666, v = b = y = E = 1, F = 2, C = 3, m = 1; m <= 3; m += 1)
      for (g = 1; g <= 3; g += 1)
        if (m !== g) {
          for (p = 1; p <= 3; p += 1)
            if (!(m === p || g === p))
              for (B[0][0] = B[0][1] = B[0][2] = B[1][0] = B[1][1] = B[1][2] = B[2][0] = B[2][1] = B[2][2] = 0, A = -1; A <= 1; A += 2)
                for (x = -1; x <= 1; x += 2)
                  for (w = -1; w <= 1; w += 2)
                    B[0][m - 1] = A, B[1][g - 1] = x, B[2][p - 1] = w, u = this.nifti_mat33_determ(B), u * d > 0 && (S = this.nifti_mat33_mul(B, M), f = S[0][0] + S[1][1] + S[2][2], f > D && (D = f, v = m, F = g, C = p, b = A, y = x, E = w));
        }
    switch (T = U = R = N = k = L = "", v * b) {
      case 1:
        T = "X", N = "+";
        break;
      case -1:
        T = "X", N = "-";
        break;
      case 2:
        T = "Y", N = "+";
        break;
      case -2:
        T = "Y", N = "-";
        break;
      case 3:
        T = "Z", N = "+";
        break;
      case -3:
        T = "Z", N = "-";
        break;
    }
    switch (F * y) {
      case 1:
        U = "X", k = "+";
        break;
      case -1:
        U = "X", k = "-";
        break;
      case 2:
        U = "Y", k = "+";
        break;
      case -2:
        U = "Y", k = "-";
        break;
      case 3:
        U = "Z", k = "+";
        break;
      case -3:
        U = "Z", k = "-";
        break;
    }
    switch (C * E) {
      case 1:
        R = "X", L = "+";
        break;
      case -1:
        R = "X", L = "-";
        break;
      case 2:
        R = "Y", L = "+";
        break;
      case -2:
        R = "Y", L = "-";
        break;
      case 3:
        R = "Z", L = "+";
        break;
      case -3:
        R = "Z", L = "-";
        break;
    }
    return T + U + R + N + k + L;
  }
  /**
   * Returns the byte index of the extension.
   * @returns {number}
   */
  getExtensionLocation() {
    return Y.MAGIC_COOKIE + 4;
  }
  /**
   * Returns the extension size.
   * @param {DataView} data
   * @returns {number}
   */
  getExtensionSize(t) {
    return G.getIntAt(t, this.getExtensionLocation(), this.littleEndian);
  }
  /**
   * Returns the extension code.
   * @param {DataView} data
   * @returns {number}
   */
  getExtensionCode(t) {
    return G.getIntAt(t, this.getExtensionLocation() + 4, this.littleEndian);
  }
  /**
   * Adds an extension
   * @param {NIFTIEXTENSION} extension
   * @param {number} index
   */
  addExtension(t, i = -1) {
    i == -1 ? this.extensions.push(t) : this.extensions.splice(i, 0, t), this.vox_offset += t.esize;
  }
  /**
   * Removes an extension
   * @param {number} index
   */
  removeExtension(t) {
    let i = this.extensions[t];
    i && (this.vox_offset -= i.esize), this.extensions.splice(t, 1);
  }
  /**
   * Returns header as ArrayBuffer.
   * @param {boolean} includeExtensions - should extension bytes be included
   * @returns {ArrayBuffer}
   */
  toArrayBuffer(t = !1) {
    let r = 352;
    if (t)
      for (let l of this.extensions)
        r += l.esize;
    let a = new Uint8Array(r), n = new DataView(a.buffer);
    n.setInt32(0, 348, this.littleEndian), n.setUint8(39, this.dim_info);
    for (let l = 0; l < 8; l++)
      n.setUint16(40 + 2 * l, this.dims[l], this.littleEndian);
    n.setFloat32(56, this.intent_p1, this.littleEndian), n.setFloat32(60, this.intent_p2, this.littleEndian), n.setFloat32(64, this.intent_p3, this.littleEndian), n.setInt16(68, this.intent_code, this.littleEndian), n.setInt16(70, this.datatypeCode, this.littleEndian), n.setInt16(72, this.numBitsPerVoxel, this.littleEndian), n.setInt16(74, this.slice_start, this.littleEndian);
    for (let l = 0; l < 8; l++)
      n.setFloat32(76 + 4 * l, this.pixDims[l], this.littleEndian);
    n.setFloat32(108, this.vox_offset, this.littleEndian), n.setFloat32(112, this.scl_slope, this.littleEndian), n.setFloat32(116, this.scl_inter, this.littleEndian), n.setInt16(120, this.slice_end, this.littleEndian), n.setUint8(122, this.slice_code), n.setUint8(123, this.xyzt_units), n.setFloat32(124, this.cal_max, this.littleEndian), n.setFloat32(128, this.cal_min, this.littleEndian), n.setFloat32(132, this.slice_duration, this.littleEndian), n.setFloat32(136, this.toffset, this.littleEndian), a.set(new TextEncoder().encode(this.description), 148), a.set(new TextEncoder().encode(this.aux_file), 228), n.setInt16(252, this.qform_code, this.littleEndian), n.setInt16(254, this.sform_code, this.littleEndian), n.setFloat32(256, this.quatern_b, this.littleEndian), n.setFloat32(260, this.quatern_c, this.littleEndian), n.setFloat32(264, this.quatern_d, this.littleEndian), n.setFloat32(268, this.qoffset_x, this.littleEndian), n.setFloat32(272, this.qoffset_y, this.littleEndian), n.setFloat32(276, this.qoffset_z, this.littleEndian);
    const o = this.affine.flat();
    for (let l = 0; l < 12; l++)
      n.setFloat32(280 + 4 * l, o[l], this.littleEndian);
    if (a.set(new TextEncoder().encode(this.intent_name), 328), a.set(new TextEncoder().encode(this.magic), 344), t) {
      a.set(Uint8Array.from([1, 0, 0, 0]), 348);
      let l = this.getExtensionLocation();
      for (const c of this.extensions)
        n.setInt32(l, c.esize, c.littleEndian), n.setInt32(l + 4, c.ecode, c.littleEndian), a.set(new Uint8Array(c.edata), l + 8), l += c.esize;
    } else
      a.set(new Uint8Array(4).fill(0), 348);
    return a.buffer;
  }
};
/*** Static Pseudo-constants ***/
// datatype codes
P(Y, "TYPE_NONE", 0), P(Y, "TYPE_BINARY", 1), P(Y, "TYPE_UINT8", 2), P(Y, "TYPE_INT16", 4), P(Y, "TYPE_INT32", 8), P(Y, "TYPE_FLOAT32", 16), P(Y, "TYPE_COMPLEX64", 32), P(Y, "TYPE_FLOAT64", 64), P(Y, "TYPE_RGB24", 128), P(Y, "TYPE_INT8", 256), P(Y, "TYPE_UINT16", 512), P(Y, "TYPE_UINT32", 768), P(Y, "TYPE_INT64", 1024), P(Y, "TYPE_UINT64", 1280), P(Y, "TYPE_FLOAT128", 1536), P(Y, "TYPE_COMPLEX128", 1792), P(Y, "TYPE_COMPLEX256", 2048), // transform codes
P(Y, "XFORM_UNKNOWN", 0), P(Y, "XFORM_SCANNER_ANAT", 1), P(Y, "XFORM_ALIGNED_ANAT", 2), P(Y, "XFORM_TALAIRACH", 3), P(Y, "XFORM_MNI_152", 4), // unit codes
P(Y, "SPATIAL_UNITS_MASK", 7), P(Y, "TEMPORAL_UNITS_MASK", 56), P(Y, "UNITS_UNKNOWN", 0), P(Y, "UNITS_METER", 1), P(Y, "UNITS_MM", 2), P(Y, "UNITS_MICRON", 3), P(Y, "UNITS_SEC", 8), P(Y, "UNITS_MSEC", 16), P(Y, "UNITS_USEC", 24), P(Y, "UNITS_HZ", 32), P(Y, "UNITS_PPM", 40), P(Y, "UNITS_RADS", 48), // nifti1 codes
P(Y, "MAGIC_COOKIE", 348), P(Y, "STANDARD_HEADER_SIZE", 348), P(Y, "MAGIC_NUMBER_LOCATION", 344), P(Y, "MAGIC_NUMBER", [110, 43, 49]), // n+1 (.nii)
P(Y, "MAGIC_NUMBER2", [110, 105, 49]), // ni1 (.hdr/.img)
P(Y, "EXTENSION_HEADER_SIZE", 8);
let Z = Y;
const Yt = class Yt {
  constructor() {
    P(this, "littleEndian", !1);
    P(this, "dim_info", 0);
    P(this, "dims", []);
    P(this, "intent_p1", 0);
    P(this, "intent_p2", 0);
    P(this, "intent_p3", 0);
    P(this, "intent_code", 0);
    P(this, "datatypeCode", 0);
    P(this, "numBitsPerVoxel", 0);
    P(this, "slice_start", 0);
    P(this, "slice_end", 0);
    P(this, "slice_code", 0);
    P(this, "pixDims", []);
    P(this, "vox_offset", 0);
    P(this, "scl_slope", 1);
    P(this, "scl_inter", 0);
    P(this, "xyzt_units", 0);
    P(this, "cal_max", 0);
    P(this, "cal_min", 0);
    P(this, "slice_duration", 0);
    P(this, "toffset", 0);
    P(this, "description", "");
    P(this, "aux_file", "");
    P(this, "intent_name", "");
    P(this, "qform_code", 0);
    P(this, "sform_code", 0);
    P(this, "quatern_b", 0);
    P(this, "quatern_c", 0);
    P(this, "quatern_d", 0);
    P(this, "qoffset_x", 0);
    P(this, "qoffset_y", 0);
    P(this, "qoffset_z", 0);
    P(this, "affine", [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ]);
    P(this, "magic", "0");
    P(this, "extensionFlag", [0, 0, 0, 0]);
    P(this, "extensions", []);
    P(this, "extensionSize", 0);
    P(this, "extensionCode", 0);
    /**
     * Returns the byte index of the extension.
     * @returns {number}
     */
    P(this, "getExtensionLocation", function() {
      return Yt.MAGIC_COOKIE + 4;
    });
    /**
     * Returns the extension size.
     * @param {DataView} data
     * @returns {number}
     */
    P(this, "getExtensionSize", Z.prototype.getExtensionSize);
    /**
     * Returns the extension code.
     * @param {DataView} data
     * @returns {number}
     */
    P(this, "getExtensionCode", Z.prototype.getExtensionCode);
    /**
     * Adds an extension
     * @param {NIFTIEXTENSION} extension
     * @param {number} index
     */
    P(this, "addExtension", Z.prototype.addExtension);
    /**
     * Removes an extension
     * @param {number} index
     */
    P(this, "removeExtension", Z.prototype.removeExtension);
    /**
     * Returns a human-readable string of datatype.
     * @param {number} code
     * @returns {string}
     */
    P(this, "getDatatypeCodeString", Z.prototype.getDatatypeCodeString);
    /**
     * Returns a human-readable string of transform type.
     * @param {number} code
     * @returns {string}
     */
    P(this, "getTransformCodeString", Z.prototype.getTransformCodeString);
    /**
     * Returns a human-readable string of spatial and temporal units.
     * @param {number} code
     * @returns {string}
     */
    P(this, "getUnitsCodeString", Z.prototype.getUnitsCodeString);
    /**
     * Returns the qform matrix.
     * @returns {Array.<Array.<number>>}
     */
    P(this, "getQformMat", Z.prototype.getQformMat);
    /**
     * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
     * @param {number} qb
     * @param {number} qc
     * @param {number} qd
     * @param {number} qx
     * @param {number} qy
     * @param {number} qz
     * @param {number} dx
     * @param {number} dy
     * @param {number} dz
     * @param {number} qfac
     * @returns {Array.<Array.<number>>}
     */
    P(this, "convertNiftiQFormToNiftiSForm", Z.prototype.convertNiftiQFormToNiftiSForm);
    /**
     * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
     * @param {Array.<Array.<number>>} R
     * @returns {string}
     */
    P(this, "convertNiftiSFormToNEMA", Z.prototype.convertNiftiSFormToNEMA);
    P(this, "nifti_mat33_mul", Z.prototype.nifti_mat33_mul);
    P(this, "nifti_mat33_determ", Z.prototype.nifti_mat33_determ);
  }
  // ni2\0
  /*** Prototype Methods ***/
  /**
   * Reads the header data.
   * @param {ArrayBuffer} data
   */
  readHeader(t) {
    var i = new DataView(t), s = G.getIntAt(i, 0, this.littleEndian), r, a, n, o;
    if (s !== Yt.MAGIC_COOKIE && (this.littleEndian = !0, s = G.getIntAt(i, 0, this.littleEndian)), s !== Yt.MAGIC_COOKIE)
      throw new Error("This does not appear to be a NIFTI file!");
    for (this.magic = G.getStringAt(i, 4, 12), this.datatypeCode = G.getShortAt(i, 12, this.littleEndian), this.numBitsPerVoxel = G.getShortAt(i, 14, this.littleEndian), r = 0; r < 8; r += 1)
      o = 16 + r * 8, this.dims[r] = G.getInt64At(i, o, this.littleEndian);
    for (this.intent_p1 = G.getDoubleAt(i, 80, this.littleEndian), this.intent_p2 = G.getDoubleAt(i, 88, this.littleEndian), this.intent_p3 = G.getDoubleAt(i, 96, this.littleEndian), r = 0; r < 8; r += 1)
      o = 104 + r * 8, this.pixDims[r] = G.getDoubleAt(i, o, this.littleEndian);
    for (this.vox_offset = G.getInt64At(i, 168, this.littleEndian), this.scl_slope = G.getDoubleAt(i, 176, this.littleEndian), this.scl_inter = G.getDoubleAt(i, 184, this.littleEndian), this.cal_max = G.getDoubleAt(i, 192, this.littleEndian), this.cal_min = G.getDoubleAt(i, 200, this.littleEndian), this.slice_duration = G.getDoubleAt(i, 208, this.littleEndian), this.toffset = G.getDoubleAt(i, 216, this.littleEndian), this.slice_start = G.getInt64At(i, 224, this.littleEndian), this.slice_end = G.getInt64At(i, 232, this.littleEndian), this.description = G.getStringAt(i, 240, 320), this.aux_file = G.getStringAt(i, 320, 344), this.qform_code = G.getIntAt(i, 344, this.littleEndian), this.sform_code = G.getIntAt(i, 348, this.littleEndian), this.quatern_b = G.getDoubleAt(i, 352, this.littleEndian), this.quatern_c = G.getDoubleAt(i, 360, this.littleEndian), this.quatern_d = G.getDoubleAt(i, 368, this.littleEndian), this.qoffset_x = G.getDoubleAt(i, 376, this.littleEndian), this.qoffset_y = G.getDoubleAt(i, 384, this.littleEndian), this.qoffset_z = G.getDoubleAt(i, 392, this.littleEndian), a = 0; a < 3; a += 1)
      for (n = 0; n < 4; n += 1)
        o = 400 + (a * 4 + n) * 8, this.affine[a][n] = G.getDoubleAt(i, o, this.littleEndian);
    this.affine[3][0] = 0, this.affine[3][1] = 0, this.affine[3][2] = 0, this.affine[3][3] = 1, this.slice_code = G.getIntAt(i, 496, this.littleEndian), this.xyzt_units = G.getIntAt(i, 500, this.littleEndian), this.intent_code = G.getIntAt(i, 504, this.littleEndian), this.intent_name = G.getStringAt(i, 508, 524), this.dim_info = G.getByteAt(i, 524), i.byteLength > Yt.MAGIC_COOKIE && (this.extensionFlag[0] = G.getByteAt(i, 540), this.extensionFlag[1] = G.getByteAt(i, 541), this.extensionFlag[2] = G.getByteAt(i, 542), this.extensionFlag[3] = G.getByteAt(i, 543), this.extensionFlag[0] && (this.extensions = G.getExtensionsAt(i, this.getExtensionLocation(), this.littleEndian, this.vox_offset), this.extensionSize = this.extensions[0].esize, this.extensionCode = this.extensions[0].ecode));
  }
  /**
   * Returns a formatted string of header fields.
   * @returns {string}
   */
  toFormattedString() {
    var t = G.formatNumber, i = "";
    return i += "Datatype = " + +this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + `)
`, i += "Bits Per Voxel =  = " + this.numBitsPerVoxel + `
`, i += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + `
`, i += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + `
`, i += "Voxel Dimensions (1-8): " + t(this.pixDims[0]) + ", " + t(this.pixDims[1]) + ", " + t(this.pixDims[2]) + ", " + t(this.pixDims[3]) + ", " + t(this.pixDims[4]) + ", " + t(this.pixDims[5]) + ", " + t(this.pixDims[6]) + ", " + t(this.pixDims[7]) + `
`, i += "Image Offset = " + this.vox_offset + `
`, i += "Data Scale:  Slope = " + t(this.scl_slope) + "  Intercept = " + t(this.scl_inter) + `
`, i += "Display Range:  Max = " + t(this.cal_max) + "  Min = " + t(this.cal_min) + `
`, i += "Slice Duration = " + this.slice_duration + `
`, i += "Time Axis Shift = " + this.toffset + `
`, i += "Slice Start = " + this.slice_start + `
`, i += "Slice End = " + this.slice_end + `
`, i += 'Description: "' + this.description + `"
`, i += 'Auxiliary File: "' + this.aux_file + `"
`, i += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + `)
`, i += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + `)
`, i += "Quaternion Parameters:  b = " + t(this.quatern_b) + "  c = " + t(this.quatern_c) + "  d = " + t(this.quatern_d) + `
`, i += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + `
`, i += "S-Form Parameters X: " + t(this.affine[0][0]) + ", " + t(this.affine[0][1]) + ", " + t(this.affine[0][2]) + ", " + t(this.affine[0][3]) + `
`, i += "S-Form Parameters Y: " + t(this.affine[1][0]) + ", " + t(this.affine[1][1]) + ", " + t(this.affine[1][2]) + ", " + t(this.affine[1][3]) + `
`, i += "S-Form Parameters Z: " + t(this.affine[2][0]) + ", " + t(this.affine[2][1]) + ", " + t(this.affine[2][2]) + ", " + t(this.affine[2][3]) + `
`, i += "Slice Code = " + this.slice_code + `
`, i += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(Z.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(Z.TEMPORAL_UNITS_MASK & this.xyzt_units) + `)
`, i += "Intent Code = " + this.intent_code + `
`, i += 'Intent Name: "' + this.intent_name + `"
`, i += "Dim Info = " + this.dim_info + `
`, i;
  }
  /**
   * Returns header as ArrayBuffer.
   * @param {boolean} includeExtensions - should extension bytes be included
   * @returns {ArrayBuffer}
   */
  toArrayBuffer(t = !1) {
    let r = 544;
    if (t)
      for (let l of this.extensions)
        r += l.esize;
    let a = new Uint8Array(r), n = new DataView(a.buffer);
    n.setInt32(0, 540, this.littleEndian), a.set(new TextEncoder().encode(this.magic), 4), n.setInt16(12, this.datatypeCode, this.littleEndian), n.setInt16(14, this.numBitsPerVoxel, this.littleEndian);
    for (let l = 0; l < 8; l++)
      n.setBigInt64(16 + 8 * l, BigInt(this.dims[l]), this.littleEndian);
    n.setFloat64(80, this.intent_p1, this.littleEndian), n.setFloat64(88, this.intent_p2, this.littleEndian), n.setFloat64(96, this.intent_p3, this.littleEndian);
    for (let l = 0; l < 8; l++)
      n.setFloat64(104 + 8 * l, this.pixDims[l], this.littleEndian);
    n.setBigInt64(168, BigInt(this.vox_offset), this.littleEndian), n.setFloat64(176, this.scl_slope, this.littleEndian), n.setFloat64(184, this.scl_inter, this.littleEndian), n.setFloat64(192, this.cal_max, this.littleEndian), n.setFloat64(200, this.cal_min, this.littleEndian), n.setFloat64(208, this.slice_duration, this.littleEndian), n.setFloat64(216, this.toffset, this.littleEndian), n.setBigInt64(224, BigInt(this.slice_start), this.littleEndian), n.setBigInt64(232, BigInt(this.slice_end), this.littleEndian), a.set(new TextEncoder().encode(this.description), 240), a.set(new TextEncoder().encode(this.aux_file), 320), n.setInt32(344, this.qform_code, this.littleEndian), n.setInt32(348, this.sform_code, this.littleEndian), n.setFloat64(352, this.quatern_b, this.littleEndian), n.setFloat64(360, this.quatern_c, this.littleEndian), n.setFloat64(368, this.quatern_d, this.littleEndian), n.setFloat64(376, this.qoffset_x, this.littleEndian), n.setFloat64(384, this.qoffset_y, this.littleEndian), n.setFloat64(392, this.qoffset_z, this.littleEndian);
    const o = this.affine.flat();
    for (let l = 0; l < 12; l++)
      n.setFloat64(400 + 8 * l, o[l], this.littleEndian);
    if (n.setInt32(496, this.slice_code, this.littleEndian), n.setInt32(500, this.xyzt_units, this.littleEndian), n.setInt32(504, this.intent_code, this.littleEndian), a.set(new TextEncoder().encode(this.intent_name), 508), n.setUint8(524, this.dim_info), t) {
      a.set(Uint8Array.from([1, 0, 0, 0]), 540);
      let l = this.getExtensionLocation();
      for (const c of this.extensions)
        n.setInt32(l, c.esize, c.littleEndian), n.setInt32(l + 4, c.ecode, c.littleEndian), a.set(new Uint8Array(c.edata), l + 8), l += c.esize;
    } else
      a.set(new Uint8Array(4).fill(0), 540);
    return a.buffer;
  }
};
/*** Static Pseudo-constants ***/
P(Yt, "MAGIC_COOKIE", 540), P(Yt, "MAGIC_NUMBER_LOCATION", 4), P(Yt, "MAGIC_NUMBER", [110, 43, 50, 0, 13, 10, 26, 10]), // n+2\0
P(Yt, "MAGIC_NUMBER2", [110, 105, 50, 0, 13, 10, 26, 10]);
let Tt = Yt;
function Ma(e, t = !1) {
  var i, s, r, a;
  return e.byteLength < Z.STANDARD_HEADER_SIZE ? !1 : (i = new DataView(e), i && (s = i.getUint8(Z.MAGIC_NUMBER_LOCATION)), r = i.getUint8(Z.MAGIC_NUMBER_LOCATION + 1), a = i.getUint8(Z.MAGIC_NUMBER_LOCATION + 2), t && s === Z.MAGIC_NUMBER2[0] && r === Z.MAGIC_NUMBER2[1] && a === Z.MAGIC_NUMBER2[2] ? !0 : s === Z.MAGIC_NUMBER[0] && r === Z.MAGIC_NUMBER[1] && a === Z.MAGIC_NUMBER[2]);
}
function Ea(e, t = !1) {
  var i, s, r, a;
  return e.byteLength < Z.STANDARD_HEADER_SIZE ? !1 : (i = new DataView(e), s = i.getUint8(Tt.MAGIC_NUMBER_LOCATION), r = i.getUint8(Tt.MAGIC_NUMBER_LOCATION + 1), a = i.getUint8(Tt.MAGIC_NUMBER_LOCATION + 2), t && s === Tt.MAGIC_NUMBER2[0] && r === Tt.MAGIC_NUMBER2[1] && a === Tt.MAGIC_NUMBER2[2] ? !0 : s === Tt.MAGIC_NUMBER[0] && r === Tt.MAGIC_NUMBER[1] && a === Tt.MAGIC_NUMBER[2]);
}
function ps(e) {
  var t, i, s;
  return !!(e && (t = new DataView(e), i = t.getUint8(0), s = t.getUint8(1), i === G.GUNZIP_MAGIC_COOKIE1 || s === G.GUNZIP_MAGIC_COOKIE2));
}
function Da(e) {
  return ya(new Uint8Array(e)).buffer;
}
async function Sa(e) {
  const t = new Uint8Array(e), i = t[0] === 31 && t[1] === 139 && t[2] === 8 ? "gzip" : t[0] === 120 && (t[1] === 1 || t[1] === 94 || t[1] === 156 || t[1] === 218) ? "deflate" : "deflate-raw", s = new DecompressionStream(i), r = s.writable.getWriter();
  r.write(t).catch(console.error);
  const a = r.close().catch(console.error), o = await new Response(s.readable).arrayBuffer();
  return await a, o;
}
async function Ks(e, t = 1 / 0) {
  const i = (u) => u[0] === 31 && u[1] === 139 && u[2] === 8 ? "gzip" : u[0] === 120 && [1, 94, 156, 218].includes(u[1]) ? "deflate" : "deflate-raw", s = new Uint8Array(e), r = i(s), a = new DecompressionStream(r), n = new TransformStream({
    transform(u, m) {
      m.enqueue(u);
    },
    flush(u) {
      u.terminate();
    }
  }), { readable: o, writable: l } = a, c = l.getWriter(), h = o.pipeThrough(n).getReader();
  c.write(s).catch((u) => {
    u instanceof Error && u.name === "AbortError" || console.error("Error during write:", u);
  });
  const f = [];
  let d = 0;
  try {
    for (; d < t; ) {
      const { done: u, value: m } = await h.read();
      if (u)
        break;
      const g = t - d, p = m.subarray(0, Math.min(m.length, g));
      if (f.push(p), d += p.length, d >= t) {
        await Promise.all([
          h.cancel().catch(() => {
          }),
          c.abort().catch(() => {
          })
        ]);
        break;
      }
    }
  } catch (u) {
    u instanceof Error && u.name === "AbortError" || console.error("Error during decompression:", u);
  } finally {
    await Promise.allSettled([
      h.cancel().catch(() => {
      }),
      c.close().catch(() => {
      })
    ]);
  }
  return f.length === 1 ? f[0].buffer : f.reduce((u, m) => {
    const g = new Uint8Array(u.byteLength + m.byteLength);
    return g.set(new Uint8Array(u), 0), g.set(m, u.byteLength), g.buffer;
  }, new ArrayBuffer(0));
}
function Ia(e, t = !1) {
  let i = null;
  if (ps(e) && (e = Da(e)), Ma(e, t) ? i = new Z() : Ea(e, t) && (i = new Tt()), i)
    i.readHeader(e);
  else
    throw new Error("That file does not appear to be NIFTI!");
  return i;
}
async function Ie(e, t = !1) {
  if (!ps(e))
    return Ia(e, t);
  let i = null, s = await Ks(e, 540), r = !0, a = !0;
  var n = new DataView(s);
  const o = n.getInt32(0, !0), l = n.getInt32(0, !1);
  if (o !== 348) if (l === 348)
    r = !1;
  else if (o === 540)
    a = !1;
  else if (l === 540)
    a = !1, r = !1;
  else
    throw new Error("That file does not appear to be NIFTI!");
  let c = Math.round(n.getFloat32(108, r));
  return Tt && (c = G.getUint64At(n, 168, r)), c > s.byteLength && (s = await Ks(e, c)), a ? i = new Z() : i = new Tt(), i.readHeader(s), i;
}
function Ta(e) {
  return e.extensionFlag[0] != 0;
}
function Xs(e, t) {
  var i = e.vox_offset, s = 1, r = 1;
  e.dims[4] && (s = e.dims[4]), e.dims[5] && (r = e.dims[5]);
  var a = e.dims[1] * e.dims[2] * e.dims[3] * s * r * (e.numBitsPerVoxel / 8);
  return t.slice(i, i + a);
}
function Xr(e, t, i, s = {}) {
  return t !== void 0 && i !== void 0 && (s = {
    ...s,
    headers: {
      ...s.headers,
      Range: `bytes=${t}-${t + i - 1}`
    }
  }), fetch(e, s);
}
function Va(e, t) {
  return {
    ...e,
    ...t,
    headers: {
      ...e.headers,
      ...t.headers
    }
  };
}
function qs(e, t) {
  const i = typeof e == "string" ? new URL(e) : e;
  i.pathname.endsWith("/") || (i.pathname += "/");
  const s = new URL(t.slice(1), i);
  return s.search = i.search, s;
}
async function Hs(e) {
  if (e.status !== 404) {
    if (e.status === 200 || e.status === 206)
      return new Uint8Array(await e.arrayBuffer());
    throw new Error(`Unexpected response status ${e.status} ${e.statusText}`);
  }
}
async function Ba(e, t, i, s) {
  if (s)
    return fetch(e, {
      ...i,
      headers: { ...i.headers, Range: `bytes=-${t}` }
    });
  let r = await fetch(e, { ...i, method: "HEAD" });
  if (!r.ok)
    return r;
  let a = r.headers.get("Content-Length"), n = Number(a);
  return Xr(e, n - t, n, i);
}
var Oe, ze, Ge, es;
class Ua {
  constructor(t, i = {}) {
    gt(this, Ge);
    P(this, "url");
    gt(this, Oe);
    gt(this, ze);
    this.url = t, ft(this, Oe, i.overrides ?? {}), ft(this, ze, i.useSuffixRequest ?? !1);
  }
  async get(t, i = {}) {
    let s = qs(this.url, t).href, r = await fetch(s, Ui(this, Ge, es).call(this, i));
    return Hs(r);
  }
  async getRange(t, i, s = {}) {
    let r = qs(this.url, t), a = Ui(this, Ge, es).call(this, s), n;
    return "suffixLength" in i ? n = await Ba(r, i.suffixLength, a, J(this, ze)) : n = await Xr(r, i.offset, i.length, a), Hs(n);
  }
}
Oe = new WeakMap(), ze = new WeakMap(), Ge = new WeakSet(), es = function(t) {
  return Va(J(this, Oe), t);
};
var Bt;
class qr {
  constructor(t, i, s) {
    gt(this, Bt);
    typeof t == "number" ? ft(this, Bt, new Uint8Array(t)) : t instanceof ArrayBuffer ? ft(this, Bt, new Uint8Array(t, i, s)) : ft(this, Bt, new Uint8Array(Array.from(t, (r) => r ? 1 : 0)));
  }
  get BYTES_PER_ELEMENT() {
    return 1;
  }
  get byteOffset() {
    return J(this, Bt).byteOffset;
  }
  get byteLength() {
    return J(this, Bt).byteLength;
  }
  get buffer() {
    return J(this, Bt).buffer;
  }
  get length() {
    return J(this, Bt).length;
  }
  get(t) {
    let i = J(this, Bt)[t];
    return typeof i == "number" ? i !== 0 : i;
  }
  set(t, i) {
    J(this, Bt)[t] = i ? 1 : 0;
  }
  fill(t) {
    J(this, Bt).fill(t ? 1 : 0);
  }
  *[Symbol.iterator]() {
    for (let t = 0; t < this.length; t++)
      yield this.get(t);
  }
}
Bt = new WeakMap();
var we;
class As {
  constructor(t, i, s, r) {
    P(this, "_data");
    P(this, "chars");
    gt(this, we);
    if (this.chars = t, ft(this, we, new TextEncoder()), typeof i == "number")
      this._data = new Uint8Array(i * t);
    else if (i instanceof ArrayBuffer)
      r && (r = r * t), this._data = new Uint8Array(i, s, r);
    else {
      let a = Array.from(i);
      this._data = new Uint8Array(a.length * t);
      for (let n = 0; n < a.length; n++)
        this.set(n, a[n]);
    }
  }
  get BYTES_PER_ELEMENT() {
    return this.chars;
  }
  get byteOffset() {
    return this._data.byteOffset;
  }
  get byteLength() {
    return this._data.byteLength;
  }
  get buffer() {
    return this._data.buffer;
  }
  get length() {
    return this.byteLength / this.BYTES_PER_ELEMENT;
  }
  get(t) {
    const i = new Uint8Array(this.buffer, this.byteOffset + this.chars * t, this.chars);
    return new TextDecoder().decode(i).replace(/\x00/g, "");
  }
  set(t, i) {
    const s = new Uint8Array(this.buffer, this.byteOffset + this.chars * t, this.chars);
    s.fill(0), s.set(J(this, we).encode(i));
  }
  fill(t) {
    const i = J(this, we).encode(t);
    for (let s = 0; s < this.length; s++)
      this._data.set(i, s * this.chars);
  }
  *[Symbol.iterator]() {
    for (let t = 0; t < this.length; t++)
      yield this.get(t);
  }
}
we = new WeakMap();
var yt;
const Is = class Is {
  constructor(t, i, s, r) {
    gt(this, yt);
    P(this, "chars");
    if (this.chars = t, typeof i == "number")
      ft(this, yt, new Int32Array(i * t));
    else if (i instanceof ArrayBuffer)
      r && (r *= t), ft(this, yt, new Int32Array(i, s, r));
    else {
      const a = i, n = new Is(t, 1);
      ft(this, yt, new Int32Array(function* () {
        for (let o of a)
          n.set(0, o), yield* J(n, yt);
      }()));
    }
  }
  get BYTES_PER_ELEMENT() {
    return J(this, yt).BYTES_PER_ELEMENT * this.chars;
  }
  get byteLength() {
    return J(this, yt).byteLength;
  }
  get byteOffset() {
    return J(this, yt).byteOffset;
  }
  get buffer() {
    return J(this, yt).buffer;
  }
  get length() {
    return J(this, yt).length / this.chars;
  }
  get(t) {
    const i = this.chars * t;
    let s = "";
    for (let r = 0; r < this.chars; r++)
      s += String.fromCodePoint(J(this, yt)[i + r]);
    return s.replace(/\u0000/g, "");
  }
  set(t, i) {
    const s = this.chars * t, r = J(this, yt).subarray(s, s + this.chars);
    r.fill(0);
    for (let a = 0; a < this.chars; a++)
      r[a] = i.codePointAt(a) ?? 0;
  }
  fill(t) {
    this.set(0, t);
    let i = J(this, yt).subarray(0, this.chars);
    for (let s = 1; s < this.length; s++)
      J(this, yt).set(i, s * this.chars);
  }
  *[Symbol.iterator]() {
    for (let t = 0; t < this.length; t++)
      yield this.get(t);
  }
};
yt = new WeakMap();
let ke = Is;
function Je(e) {
  const t = new TextDecoder().decode(e);
  return JSON.parse(t);
}
function _s(e, t) {
  const i = t / 2, s = t - 1;
  let r = 0;
  for (let a = 0; a < e.length; a += t)
    for (let n = 0; n < i; n += 1)
      r = e[a + n], e[a + n] = e[a + s - n], e[a + s - n] = r;
}
function Hr(e) {
  if (e === "v2:object")
    return globalThis.Array;
  let t = e.match(/v2:([US])(\d+)/);
  if (t) {
    let [, s, r] = t;
    return (s === "U" ? ke : As).bind(null, Number(r));
  }
  let i = {
    int8: Int8Array,
    int16: Int16Array,
    int32: Int32Array,
    int64: globalThis.BigInt64Array,
    uint8: Uint8Array,
    uint16: Uint16Array,
    uint32: Uint32Array,
    uint64: globalThis.BigUint64Array,
    float16: globalThis.Float16Array,
    float32: Float32Array,
    float64: Float64Array,
    bool: qr
  }[e];
  return At(i, `Unknown or unsupported data_type: ${e}`), i;
}
function ce(e, t) {
  const i = e.length;
  typeof t == "string" && (t = t === "C" ? Array.from({ length: i }, (a, n) => n) : Array.from({ length: i }, (a, n) => i - 1 - n)), At(i === t.length, "Order length must match the number of dimensions.");
  let s = 1, r = new Array(i);
  for (let a = t.length - 1; a >= 0; a--)
    r[t[a]] = s, s *= e[t[a]];
  return r;
}
function Ra({ name: e, configuration: t }) {
  if (e === "default") {
    const i = (t == null ? void 0 : t.separator) ?? "/";
    return (s) => ["c", ...s].join(i);
  }
  if (e === "v2") {
    const i = (t == null ? void 0 : t.separator) ?? ".";
    return (s) => s.join(i) || "0";
  }
  throw new Error(`Unknown chunk key encoding: ${e}`);
}
function Pa(e) {
  if (e === "|O")
    return { data_type: "v2:object" };
  let t = e.match(/^([<|>])(.*)$/);
  At(t, `Invalid dtype: ${e}`);
  let [, i, s] = t, r = {
    b1: "bool",
    i1: "int8",
    u1: "uint8",
    i2: "int16",
    u2: "uint16",
    i4: "int32",
    u4: "uint32",
    i8: "int64",
    u8: "uint64",
    f2: "float16",
    f4: "float32",
    f8: "float64"
  }[s] ?? (s.startsWith("S") || s.startsWith("U") ? `v2:${s}` : void 0);
  return At(r, `Unsupported or unknown dtype: ${e}`), i === "|" ? { data_type: r } : { data_type: r, endian: i === "<" ? "little" : "big" };
}
function Na(e, t = {}) {
  let i = [], s = Pa(e.dtype);
  e.order === "F" && i.push({ name: "transpose", configuration: { order: "F" } }), "endian" in s && s.endian === "big" && i.push({ name: "bytes", configuration: { endian: "big" } });
  for (let { id: r, ...a } of e.filters ?? [])
    i.push({ name: r, configuration: a });
  if (e.compressor) {
    let { id: r, ...a } = e.compressor;
    i.push({ name: r, configuration: a });
  }
  return {
    zarr_format: 3,
    node_type: "array",
    shape: e.shape,
    data_type: s.data_type,
    chunk_grid: {
      name: "regular",
      configuration: {
        chunk_shape: e.chunks
      }
    },
    chunk_key_encoding: {
      name: "v2",
      configuration: {
        separator: e.dimension_separator ?? "."
      }
    },
    codecs: i,
    fill_value: e.fill_value,
    attributes: t
  };
}
function La(e, t = {}) {
  return {
    zarr_format: 3,
    node_type: "group",
    attributes: t
  };
}
function ka(e, t) {
  if (t !== "number" && t !== "bigint" && t !== "boolean" && t !== "object" && t !== "string")
    return e === t;
  let i = e === "bool";
  if (t === "boolean")
    return i;
  let s = e.startsWith("v2:U") || e.startsWith("v2:S");
  if (t === "string")
    return s;
  let r = e === "int64" || e === "uint64";
  if (t === "bigint")
    return r;
  let a = e === "v2:object";
  return t === "object" ? a : !s && !r && !i && !a;
}
function Oa(e) {
  return (e == null ? void 0 : e.name) === "sharding_indexed";
}
function _r(e) {
  return (e.data_type === "uint64" || e.data_type === "int64") && e.fill_value != null ? BigInt(e.fill_value) : e.fill_value;
}
function Qr(e, ...t) {
  if (!t.some((i) => e instanceof i))
    throw e;
}
function At(e, t = "") {
  if (!e)
    throw new Error(t);
}
async function jr(e, { format: t, signal: i }) {
  const s = e instanceof Response ? e : new Response(e);
  At(s.body, "Response does not contain body.");
  try {
    return await new Response(s.body.pipeThrough(new DecompressionStream(t), { signal: i })).arrayBuffer();
  } catch {
    throw i == null || i.throwIfAborted(), new Error(`Failed to decode ${t}`);
  }
}
class xs {
  constructor(t, i) {
    P(this, "kind", "array_to_array");
    At(t.keepbits >= 0, "keepbits must be zero or positive");
  }
  static fromConfig(t, i) {
    return new xs(t, i);
  }
  /**
   * Encode a chunk of data with bit-rounding.
   * @param _arr - The chunk to encode
   */
  encode(t) {
    throw new Error("`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.");
  }
  /**
   * Decode a chunk of data (no-op).
   * @param arr - The chunk to decode
   * @returns The decoded chunk
   */
  decode(t) {
    return t;
  }
}
const Qs = za();
function za() {
  const e = new Uint32Array([305419896]);
  return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)[0] !== 18;
}
function js(e) {
  return "BYTES_PER_ELEMENT" in e ? e.BYTES_PER_ELEMENT : 4;
}
var Ye, Qt, We, Ke, be;
const Ts = class Ts {
  constructor(t, i) {
    P(this, "kind", "array_to_bytes");
    gt(this, Ye);
    gt(this, Qt);
    gt(this, We);
    gt(this, Ke);
    gt(this, be);
    ft(this, be, t == null ? void 0 : t.endian), ft(this, Qt, Hr(i.data_type)), ft(this, Ke, i.shape), ft(this, Ye, ce(i.shape, "C"));
    const s = new (J(this, Qt))(0);
    ft(this, We, s.BYTES_PER_ELEMENT);
  }
  static fromConfig(t, i) {
    return new Ts(t, i);
  }
  encode(t) {
    let i = new Uint8Array(t.data.buffer);
    return Qs && J(this, be) === "big" && _s(i, js(J(this, Qt))), i;
  }
  decode(t) {
    return Qs && J(this, be) === "big" && _s(t, js(J(this, Qt))), {
      data: new (J(this, Qt))(t.buffer, t.byteOffset, t.byteLength / J(this, We)),
      shape: J(this, Ke),
      stride: J(this, Ye)
    };
  }
};
Ye = new WeakMap(), Qt = new WeakMap(), We = new WeakMap(), Ke = new WeakMap(), be = new WeakMap();
let Ci = Ts;
class vs {
  constructor() {
    P(this, "kind", "bytes_to_bytes");
  }
  static fromConfig() {
    return new vs();
  }
  encode(t) {
    throw new Error("Not implemented");
  }
  decode(t) {
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength - 4);
  }
}
class ws {
  constructor() {
    P(this, "kind", "bytes_to_bytes");
  }
  static fromConfig(t) {
    return new ws();
  }
  encode(t) {
    throw new Error("Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.");
  }
  async decode(t) {
    const i = await jr(t, { format: "gzip" });
    return new Uint8Array(i);
  }
}
function Ga(e, t) {
  return At(!Number.isNaN(t), "JsonCodec allow_nan is false but NaN was encountered during encoding."), At(t !== Number.POSITIVE_INFINITY, "JsonCodec allow_nan is false but Infinity was encountered during encoding."), At(t !== Number.NEGATIVE_INFINITY, "JsonCodec allow_nan is false but -Infinity was encountered during encoding."), t;
}
function Ya(e, t) {
  return t instanceof Object && !Array.isArray(t) ? Object.keys(t).sort().reduce((i, s) => (i[s] = t[s], i), {}) : t;
}
var Xe, qe;
const Vs = class Vs {
  constructor(t = {}) {
    P(this, "configuration");
    P(this, "kind", "array_to_bytes");
    gt(this, Xe);
    gt(this, qe);
    this.configuration = t;
    const { encoding: i = "utf-8", skipkeys: s = !1, ensure_ascii: r = !0, check_circular: a = !0, allow_nan: n = !0, sort_keys: o = !0, indent: l, strict: c = !0 } = t;
    let h = t.separators;
    h || (l ? h = [", ", ": "] : h = [",", ":"]), ft(this, Xe, {
      encoding: i,
      skipkeys: s,
      ensure_ascii: r,
      check_circular: a,
      allow_nan: n,
      indent: l,
      separators: h,
      sort_keys: o
    }), ft(this, qe, { strict: c });
  }
  static fromConfig(t) {
    return new Vs(t);
  }
  encode(t) {
    const { indent: i, encoding: s, ensure_ascii: r, check_circular: a, allow_nan: n, sort_keys: o } = J(this, Xe);
    At(s === "utf-8", "JsonCodec does not yet support non-utf-8 encoding.");
    const l = [];
    At(a, "JsonCodec does not yet support skipping the check for circular references during encoding."), n || l.push(Ga), o && l.push(Ya);
    const c = Array.from(t.data);
    c.push("|O"), c.push(t.shape);
    let h;
    l.length && (h = (d, u) => {
      let m = u;
      for (let g of l)
        m = g(d, m);
      return m;
    });
    let f = JSON.stringify(c, h, i);
    return r && (f = f.replace(/[\u007F-\uFFFF]/g, (d) => {
      const u = `0000${d.charCodeAt(0).toString(16)}`;
      return `\\u${u.substring(u.length - 4)}`;
    })), new TextEncoder().encode(f);
  }
  decode(t) {
    const { strict: i } = J(this, qe);
    At(i, "JsonCodec does not yet support non-strict decoding.");
    const s = Je(t), r = s.pop();
    s.pop(), At(r, "0D not implemented for JsonCodec.");
    const a = ce(r, "C");
    return { data: s, shape: r, stride: a };
  }
};
Xe = new WeakMap(), qe = new WeakMap();
let is = Vs;
function Zs(e) {
  return e instanceof qr || e instanceof As || e instanceof ke ? new Proxy(e, {
    get(i, s) {
      return i.get(Number(s));
    },
    set(i, s, r) {
      return i.set(Number(s), r), !0;
    }
  }) : e;
}
function Wa(e, t) {
  let i;
  return e.data instanceof As || e.data instanceof ke ? i = new e.constructor(
    // @ts-expect-error
    e.data.length,
    e.data.chars
  ) : i = new e.constructor(e.data.length), {
    data: i,
    shape: e.shape,
    stride: ce(e.shape, t)
  };
}
function Ka(e, t) {
  let i = Wa(e, t), s = e.shape.length, r = e.data.length, a = Array(s).fill(0), n = Zs(e.data), o = Zs(i.data);
  for (let l = 0; l < r; l++) {
    let c = 0;
    for (let h = 0; h < s; h++)
      c += a[h] * i.stride[h];
    o[c] = n[l], a[0] += 1;
    for (let h = 0; h < s; h++)
      if (a[h] === e.shape[h]) {
        if (h + 1 === s)
          break;
        a[h] = 0, a[h + 1] += 1;
      }
  }
  return i;
}
function Xa(e) {
  let t = e.shape.length;
  return At(t === e.stride.length, "Shape and stride must have the same length."), e.stride.map((i, s) => ({ stride: i, index: s })).sort((i, s) => s.stride - i.stride).map((i) => i.index);
}
function qa(e, t) {
  let i = Xa(e);
  return At(i.length === t.length, "Orders must match"), i.every((s, r) => s === t[r]);
}
var He, ye;
const Bs = class Bs {
  constructor(t, i) {
    P(this, "kind", "array_to_array");
    gt(this, He);
    gt(this, ye);
    let s = t.order ?? "C", r = i.shape.length, a = new Array(r), n = new Array(r);
    if (s === "C")
      for (let o = 0; o < r; ++o)
        a[o] = o, n[o] = o;
    else if (s === "F")
      for (let o = 0; o < r; ++o)
        a[o] = r - o - 1, n[o] = r - o - 1;
    else
      a = s, a.forEach((o, l) => {
        At(n[o] === void 0, `Invalid permutation: ${JSON.stringify(s)}`), n[o] = l;
      });
    ft(this, He, a), ft(this, ye, n);
  }
  static fromConfig(t, i) {
    return new Bs(t, i);
  }
  encode(t) {
    return qa(t, J(this, ye)) ? t : Ka(t, J(this, ye));
  }
  decode(t) {
    return {
      data: t.data,
      shape: t.shape,
      stride: ce(t.shape, J(this, He))
    };
  }
};
He = new WeakMap(), ye = new WeakMap();
let ss = Bs;
var _e, Qe;
const Us = class Us {
  constructor(t) {
    P(this, "kind", "array_to_bytes");
    gt(this, _e);
    gt(this, Qe);
    ft(this, _e, t), ft(this, Qe, ce(t, "C"));
  }
  static fromConfig(t, i) {
    return new Us(i.shape);
  }
  encode(t) {
    throw new Error("Method not implemented.");
  }
  decode(t) {
    let i = new TextDecoder(), s = new DataView(t.buffer), r = Array(s.getUint32(0, !0)), a = 4;
    for (let n = 0; n < r.length; n++) {
      let o = s.getUint32(a, !0);
      a += 4, r[n] = i.decode(t.buffer.slice(a, a + o)), a += o;
    }
    return { data: r, shape: J(this, _e), stride: J(this, Qe) };
  }
};
_e = new WeakMap(), Qe = new WeakMap();
let rs = Us;
class bs {
  constructor() {
    P(this, "kind", "bytes_to_bytes");
  }
  static fromConfig(t) {
    return new bs();
  }
  encode(t) {
    throw new Error("Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.");
  }
  async decode(t) {
    const i = await jr(t, { format: "deflate" });
    return new Uint8Array(i);
  }
}
function Ha() {
  return (/* @__PURE__ */ new Map()).set("blosc", () => import("./blosc-CDWbAvMh.mjs").then((e) => e.default)).set("lz4", () => import("./lz4-CpXtrgWV.mjs").then((e) => e.default)).set("zstd", () => import("./zstd-BdUNfrxH.mjs").then((e) => e.default)).set("gzip", () => ws).set("zlib", () => bs).set("transpose", () => ss).set("bytes", () => Ci).set("crc32c", () => vs).set("vlen-utf8", () => rs).set("json2", () => is).set("bitround", () => xs);
}
const _a = Ha();
function ns(e) {
  let t;
  return {
    async encode(i) {
      t || (t = await Js(e));
      for (const r of t.array_to_array)
        i = await r.encode(i);
      let s = await t.array_to_bytes.encode(i);
      for (const r of t.bytes_to_bytes)
        s = await r.encode(s);
      return s;
    },
    async decode(i) {
      t || (t = await Js(e));
      for (let r = t.bytes_to_bytes.length - 1; r >= 0; r--)
        i = await t.bytes_to_bytes[r].decode(i);
      let s = await t.array_to_bytes.decode(i);
      for (let r = t.array_to_array.length - 1; r >= 0; r--)
        s = await t.array_to_array[r].decode(s);
      return s;
    }
  };
}
async function Js(e) {
  let t = e.codecs.map(async (a) => {
    var o;
    let n = await ((o = _a.get(a.name)) == null ? void 0 : o());
    return At(n, `Unknown codec: ${a.name}`), { Codec: n, meta: a };
  }), i = [], s, r = [];
  for await (let { Codec: a, meta: n } of t) {
    let o = a.fromConfig(n.configuration, e);
    switch (o.kind) {
      case "array_to_array":
        i.push(o);
        break;
      case "array_to_bytes":
        s = o;
        break;
      default:
        r.push(o);
    }
  }
  return s || (At(Qa(e), `Cannot encode ${e.data_type} to bytes without a codec`), s = Ci.fromConfig({ endian: "little" }, e)), { array_to_array: i, array_to_bytes: s, bytes_to_bytes: r };
}
function Qa(e) {
  return e.data_type !== "v2:object";
}
class $e extends Error {
  constructor(t, i = {}) {
    super(`Node not found: ${t}`, i), this.name = "NodeNotFoundError";
  }
}
class ys extends Error {
  constructor(t) {
    super(`Missing key: ${t}`), this.name = "KeyError";
  }
}
const $s = 18446744073709551615n;
function ja(e, t, i, s) {
  At(e.store.getRange, "Store does not support range requests");
  let r = e.store.getRange.bind(e.store), a = t.map((l, c) => l / s.chunk_shape[c]), n = ns({
    data_type: "uint64",
    shape: [...a, 2],
    codecs: s.index_codecs
  }), o = {};
  return async (l) => {
    let c = l.map((x, w) => Math.floor(x / a[w])), h = e.resolve(i(c)).path, f;
    if (h in o)
      f = o[h];
    else {
      let x = 4, w = 16 * a.reduce((F, C) => F * C, 1), v = await r(h, {
        suffixLength: w + x
      });
      f = o[h] = v ? await n.decode(v) : null;
    }
    if (f === null)
      return;
    let { data: d, shape: u, stride: m } = f, g = l.map((x, w) => x % u[w]).reduce((x, w, v) => x + w * m[v], 0), p = d[g], A = d[g + 1];
    if (!(p === $s && A === $s))
      return r(h, {
        offset: Number(p),
        length: Number(A)
      });
  };
}
class fe {
  constructor(t, i = "/") {
    P(this, "store");
    P(this, "path");
    this.store = t, this.path = i;
  }
  resolve(t) {
    let i = new URL(`file://${this.path.endsWith("/") ? this.path : `${this.path}/`}`);
    return new fe(this.store, decodeURIComponent(new URL(t, i).pathname));
  }
}
function Za(e) {
  return new fe(e ?? /* @__PURE__ */ new Map());
}
var je;
class Cs extends fe {
  constructor(i, s, r) {
    super(i, s);
    P(this, "kind", "group");
    gt(this, je);
    ft(this, je, r);
  }
  get attrs() {
    return J(this, je).attributes;
  }
}
je = new WeakMap();
function tr(e) {
  var i;
  const t = e.find((s) => s.name === "transpose");
  return ((i = t == null ? void 0 : t.configuration) == null ? void 0 : i.order) ?? "C";
}
const Te = Symbol("zarrita.context");
function Ja(e) {
  return e[Te];
}
function $a(e, t) {
  let { configuration: i } = t.codecs.find(Oa) ?? {}, s = {
    encode_chunk_key: Ra(t.chunk_key_encoding),
    TypedArray: Hr(t.data_type),
    fill_value: t.fill_value
  };
  if (i) {
    let a = tr(i.codecs);
    return {
      ...s,
      kind: "sharded",
      chunk_shape: i.chunk_shape,
      codec: ns({
        data_type: t.data_type,
        shape: i.chunk_shape,
        codecs: i.codecs
      }),
      get_strides(n) {
        return ce(n, a);
      },
      get_chunk_bytes: ja(e, t.chunk_grid.configuration.chunk_shape, s.encode_chunk_key, i)
    };
  }
  let r = tr(t.codecs);
  return {
    ...s,
    kind: "regular",
    chunk_shape: t.chunk_grid.configuration.chunk_shape,
    codec: ns({
      data_type: t.data_type,
      shape: t.chunk_grid.configuration.chunk_shape,
      codecs: t.codecs
    }),
    get_strides(a) {
      return ce(a, r);
    },
    async get_chunk_bytes(a, n) {
      let o = s.encode_chunk_key(a), l = e.resolve(o).path;
      return e.store.get(l, n);
    }
  };
}
var Mr, Er, oe, Dr;
let Fi = (Dr = class extends (Er = fe, Mr = Te, Er) {
  constructor(i, s, r) {
    super(i, s);
    P(this, "kind", "array");
    gt(this, oe);
    P(this, Mr);
    ft(this, oe, {
      ...r,
      fill_value: _r(r)
    }), this[Te] = $a(this, r);
  }
  get attrs() {
    return J(this, oe).attributes;
  }
  get shape() {
    return J(this, oe).shape;
  }
  get chunks() {
    return this[Te].chunk_shape;
  }
  get dtype() {
    return J(this, oe).data_type;
  }
  async getChunk(i, s) {
    let r = this[Te], a = await r.get_chunk_bytes(i, s);
    if (!a) {
      let n = r.chunk_shape.reduce((l, c) => l * c, 1), o = new r.TypedArray(n);
      return o.fill(r.fill_value), {
        data: o,
        shape: r.chunk_shape,
        stride: r.get_strides(r.chunk_shape)
      };
    }
    return r.codec.decode(a);
  }
  /**
   * A helper method to narrow `zarr.Array` Dtype.
   *
   * ```typescript
   * let arr: zarr.Array<DataType, FetchStore> = zarr.open(store, { kind: "array" });
   *
   * // Option 1: narrow by scalar type (e.g. "bool", "raw", "bigint", "number")
   * if (arr.is("bigint")) {
   *   // zarr.Array<"int64" | "uint64", FetchStore>
   * }
   *
   * // Option 3: exact match
   * if (arr.is("float32")) {
   *   // zarr.Array<"float32", FetchStore, "/">
   * }
   * ```
   */
  is(i) {
    return ka(this.dtype, i);
  }
}, oe = new WeakMap(), Dr);
function* to(e, t, i = 1) {
  t === void 0 && (t = e, e = 0);
  for (let s = e; s < t; s += i)
    yield s;
}
function* eo(...e) {
  if (e.length === 0)
    return;
  const t = e.map((s) => s[Symbol.iterator]()), i = t.map((s) => s.next());
  if (i.some((s) => s.done))
    throw new Error("Input contains an empty iterator.");
  for (let s = 0; ; ) {
    if (i[s].done) {
      if (t[s] = e[s][Symbol.iterator](), i[s] = t[s].next(), ++s >= t.length)
        return;
    } else
      yield i.map(({ value: r }) => r), s = 0;
    i[s] = t[s].next();
  }
}
function io({ start: e, stop: t, step: i }, s) {
  if (i === 0)
    throw new Error("slice step cannot be zero");
  i = i ?? 1;
  const r = i < 0, [a, n] = r ? [-1, s - 1] : [0, s];
  return e === null ? e = r ? n : a : e < 0 ? (e += s, e < a && (e = a)) : e > n && (e = n), t === null ? t = r ? a : n : t < 0 ? (t += s, t < a && (t = a)) : t > n && (t = n), [e, t, i];
}
function Pe(e, t, i = null) {
  return t === void 0 && (t = e, e = null), {
    start: e,
    stop: t,
    step: i
  };
}
function so() {
  const e = [];
  return {
    add: (t) => e.push(t()),
    onIdle: () => Promise.all(e)
  };
}
class Fs extends Error {
  constructor(t) {
    super(t), this.name = "IndexError";
  }
}
function ro(e, t) {
  throw new Fs(`too many indicies for array; expected ${t.length}, got ${e.length}`);
}
function no(e) {
  throw new Fs(`index out of bounds for dimension with length ${e}`);
}
function ao() {
  throw new Fs("only slices with step >= 1 are supported");
}
function oo(e, t) {
  e.length > t.length && ro(e, t);
}
function lo(e, t) {
  return e = Math.trunc(e), e < 0 && (e = t + e), (e >= t || e < 0) && no(t), e;
}
class co {
  constructor({ dim_sel: t, dim_len: i, dim_chunk_len: s }) {
    P(this, "dim_sel");
    P(this, "dim_len");
    P(this, "dim_chunk_len");
    P(this, "nitems");
    t = lo(t, i), this.dim_sel = t, this.dim_len = i, this.dim_chunk_len = s, this.nitems = 1;
  }
  *[Symbol.iterator]() {
    const t = Math.floor(this.dim_sel / this.dim_chunk_len), i = t * this.dim_chunk_len, s = this.dim_sel - i;
    yield { dim_chunk_ix: t, dim_chunk_sel: s };
  }
}
class er {
  constructor({ dim_sel: t, dim_len: i, dim_chunk_len: s }) {
    P(this, "start");
    P(this, "stop");
    P(this, "step");
    P(this, "dim_len");
    P(this, "dim_chunk_len");
    P(this, "nitems");
    P(this, "nchunks");
    const [r, a, n] = io(t, i);
    this.start = r, this.stop = a, this.step = n, this.step < 1 && ao(), this.dim_len = i, this.dim_chunk_len = s, this.nitems = Math.max(0, Math.ceil((this.stop - this.start) / this.step)), this.nchunks = Math.ceil(this.dim_len / this.dim_chunk_len);
  }
  *[Symbol.iterator]() {
    const t = Math.floor(this.start / this.dim_chunk_len), i = Math.ceil(this.stop / this.dim_chunk_len);
    for (const s of to(t, i)) {
      const r = s * this.dim_chunk_len, a = Math.min(this.dim_len, (s + 1) * this.dim_chunk_len), n = a - r;
      let o = 0, l = 0;
      if (this.start < r) {
        const u = (r - this.start) % this.step;
        u && (l += this.step - u), o = Math.ceil((r - this.start) / this.step);
      } else
        l = this.start - r;
      const c = this.stop > a ? n : this.stop - r, h = [
        l,
        c,
        this.step
      ], f = Math.ceil((c - l) / this.step), d = [
        o,
        o + f,
        1
      ];
      yield { dim_chunk_ix: s, dim_chunk_sel: h, dim_out_sel: d };
    }
  }
}
function ho(e, t) {
  let i = [];
  return e === null ? i = t.map((s) => Pe(null)) : Array.isArray(e) && (i = e.map((s) => s ?? Pe(null))), oo(i, t), i;
}
class fo {
  constructor({ selection: t, shape: i, chunk_shape: s }) {
    P(this, "dim_indexers");
    P(this, "shape");
    this.dim_indexers = ho(t, i).map((r, a) => new (typeof r == "number" ? co : er)({
      // @ts-expect-error ts inference not strong enough to know correct chunk
      dim_sel: r,
      dim_len: i[a],
      dim_chunk_len: s[a]
    })), this.shape = this.dim_indexers.filter((r) => r instanceof er).map((r) => r.nitems);
  }
  *[Symbol.iterator]() {
    for (const t of eo(...this.dim_indexers)) {
      const i = t.map((r) => r.dim_chunk_ix), s = t.map((r) => "dim_out_sel" in r ? { from: r.dim_chunk_sel, to: r.dim_out_sel } : { from: r.dim_chunk_sel, to: null });
      yield { chunk_coords: i, mapping: s };
    }
  }
}
function uo(e, t) {
  return "get" in e ? e.get(t) : e[t];
}
async function mo(e, t, i, s) {
  var l;
  let r = Ja(e), a = new fo({
    selection: t,
    shape: e.shape,
    chunk_shape: e.chunks
  }), n = s.prepare(new r.TypedArray(a.shape.reduce((c, h) => c * h, 1)), a.shape, r.get_strides(a.shape)), o = ((l = i.create_queue) == null ? void 0 : l.call(i)) ?? so();
  for (const { chunk_coords: c, mapping: h } of a)
    o.add(async () => {
      let { data: f, shape: d, stride: u } = await e.getChunk(c, i.opts), m = s.prepare(f, d, u);
      s.set_from_chunk(n, m, h);
    });
  return await o.onIdle(), a.shape.length === 0 ? uo(n.data, 0) : n;
}
function Ms(e, t = 0, i) {
  let s = i ?? e.length - t;
  return {
    length: s,
    subarray(r, a = s) {
      return Ms(e, t + r, a - r);
    },
    set(r, a = 0) {
      for (let n = 0; n < r.length; n++)
        e[t + a + n] = r.get(n);
    },
    get(r) {
      return e[t + r];
    }
  };
}
function ki(e) {
  return globalThis.Array.isArray(e.data) ? {
    // @ts-expect-error
    data: Ms(e.data),
    stride: e.stride,
    bytes_per_element: 1
  } : {
    data: new Uint8Array(e.data.buffer, e.data.byteOffset, e.data.byteLength),
    stride: e.stride,
    bytes_per_element: e.data.BYTES_PER_ELEMENT
  };
}
function go(e) {
  return "chars" in e ? e.constructor.bind(null, e.chars) : e.constructor;
}
function po(e, t) {
  if (globalThis.Array.isArray(e.data))
    return Ms([t]);
  let i = go(e.data), s = new i([t]);
  return new Uint8Array(s.buffer, s.byteOffset, s.byteLength);
}
const Ao = {
  prepare(e, t, i) {
    return { data: e, shape: t, stride: i };
  },
  set_scalar(e, t, i) {
    let s = ki(e);
    as(s, t, po(e, i), s.bytes_per_element);
  },
  set_from_chunk(e, t, i) {
    let s = ki(e);
    Ai(s, ki(t), s.bytes_per_element, i);
  }
};
async function ir(e, t = null, i = {}) {
  return mo(e, t, i, Ao);
}
function Zr(e, t, i) {
  return i < 0 && t < e ? Math.floor((e - t - 1) / -i) + 1 : e < t ? Math.floor((t - e - 1) / i) + 1 : 0;
}
function as(e, t, i, s) {
  if (t.length === 0) {
    e.data.set(i, 0);
    return;
  }
  const [r, ...a] = t, [n, ...o] = e.stride;
  if (typeof r == "number") {
    const d = e.data.subarray(n * r * s);
    as({ data: d, stride: o }, a, i, s);
    return;
  }
  const [l, c, h] = r, f = Zr(l, c, h);
  if (a.length === 0) {
    for (let d = 0; d < f; d++)
      e.data.set(i, n * (l + h * d) * s);
    return;
  }
  for (let d = 0; d < f; d++) {
    const u = e.data.subarray(n * (l + h * d) * s);
    as({ data: u, stride: o }, a, i, s);
  }
}
function Ai(e, t, i, s) {
  const [r, ...a] = s, [n, ...o] = e.stride, [l, ...c] = t.stride;
  if (r.from === null) {
    if (a.length === 0) {
      e.data.set(t.data.subarray(0, i), r.to * i);
      return;
    }
    Ai({
      data: e.data.subarray(n * r.to * i),
      stride: o
    }, t, i, a);
    return;
  }
  if (r.to === null) {
    if (a.length === 0) {
      let A = r.from * i;
      e.data.set(t.data.subarray(A, A + i), 0);
      return;
    }
    Ai(e, {
      data: t.data.subarray(l * r.from * i),
      stride: c
    }, i, a);
    return;
  }
  const [h, f, d] = r.to, [u, m, g] = r.from, p = Zr(h, f, d);
  if (a.length === 0) {
    if (d === 1 && g === 1 && n === 1 && l === 1) {
      let A = u * i, x = p * i;
      e.data.set(t.data.subarray(A, A + x), h * i);
      return;
    }
    for (let A = 0; A < p; A++) {
      let x = l * (u + g * A) * i;
      e.data.set(t.data.subarray(x, x + i), n * (h + d * A) * i);
    }
    return;
  }
  for (let A = 0; A < p; A++)
    Ai({
      data: e.data.subarray(n * (h + A * d) * i),
      stride: o
    }, {
      data: t.data.subarray(l * (u + A * g) * i),
      stride: c
    }, i, a);
}
let Si = xo();
function xo() {
  let e = /* @__PURE__ */ new WeakMap();
  function t(i) {
    let s = e.get(i) ?? { v2: 0, v3: 0 };
    return e.set(i, s), s;
  }
  return {
    increment(i, s) {
      t(i)[s] += 1;
    },
    version_max(i) {
      let s = t(i);
      return s.v3 > s.v2 ? "v3" : "v2";
    }
  };
}
async function vo(e) {
  let t = await e.store.get(e.resolve(".zattrs").path);
  return t ? Je(t) : {};
}
async function wo(e, t = {}) {
  let i = "store" in e ? e : new fe(e), s = {};
  return (t.attrs ?? !0) && (s = await vo(i)), t.kind === "array" ? sr(i, s) : t.kind === "group" ? rr(i, s) : sr(i, s).catch((r) => (Qr(r, $e), rr(i, s)));
}
async function sr(e, t) {
  let { path: i } = e.resolve(".zarray"), s = await e.store.get(i);
  if (!s)
    throw new $e("v2 array", {
      cause: new ys(i)
    });
  return Si.increment(e.store, "v2"), new Fi(e.store, e.path, Na(Je(s), t));
}
async function rr(e, t) {
  let { path: i } = e.resolve(".zgroup"), s = await e.store.get(i);
  if (!s)
    throw new $e("v2 group", {
      cause: new ys(i)
    });
  return Si.increment(e.store, "v2"), new Cs(e.store, e.path, La(Je(s), t));
}
async function bo(e) {
  let { store: t, path: i } = e.resolve("zarr.json"), s = await e.store.get(i);
  if (!s)
    throw new $e("v3 array or group", {
      cause: new ys(i)
    });
  let r = Je(s);
  return r.node_type === "array" && (r.fill_value = _r(r)), r.node_type === "array" ? new Fi(t, e.path, r) : new Cs(t, e.path, r);
}
async function yo(e, t = {}) {
  let i = "store" in e ? e : new fe(e), s = await bo(i);
  if (Si.increment(i.store, "v3"), t.kind === void 0 || t.kind === "array" && s instanceof Fi || t.kind === "group" && s instanceof Cs)
    return s;
  let r = s instanceof Fi ? "array" : "group";
  throw new Error(`Expected node of kind ${t.kind}, found ${r}.`);
}
async function Jt(e, t = {}) {
  let i = "store" in e ? e.store : e, s = Si.version_max(i), r = s === "v2" ? Jt.v2 : Jt.v3, a = s === "v2" ? Jt.v3 : Jt.v2;
  return r(e, t).catch((n) => (Qr(n, $e), a(e, t)));
}
Jt.v2 = wo;
Jt.v3 = yo;
var Jr = Object.defineProperty, $r = (e) => {
  throw TypeError(e);
}, Co = (e, t, i) => t in e ? Jr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, Ii = (e, t) => {
  for (var i in t)
    Jr(e, i, { get: t[i], enumerable: !0 });
}, I = (e, t, i) => Co(e, typeof t != "symbol" ? t + "" : t, i), tn = (e, t, i) => t.has(e) || $r("Cannot " + i), X = (e, t, i) => (tn(e, t, "read from private field"), i ? i.call(e) : t.get(e)), ge = (e, t, i) => t.has(e) ? $r("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, i), _t = (e, t, i, s) => (tn(e, t, "write to private field"), t.set(e, i), i), Fo = {
  version: "0.65.0"
}, Mo = new Float32Array([
  -1,
  -1,
  -1,
  0.28,
  0.28,
  0.28,
  -1,
  -1,
  -1,
  0.28,
  0.28,
  0.28,
  -1,
  1,
  -1,
  0.28,
  0.28,
  0.28,
  1,
  -1,
  -1,
  0.28,
  0.28,
  0.28,
  1,
  1,
  -1,
  0.28,
  0.28,
  0.28,
  1,
  1,
  -1,
  0.28,
  0.28,
  0.28,
  -1,
  -1,
  1,
  0.8,
  0.8,
  0.8,
  -1,
  -1,
  1,
  0.8,
  0.8,
  0.8,
  1,
  -1,
  1,
  0.8,
  0.8,
  0.8,
  -1,
  1,
  1,
  0.8,
  0.8,
  0.8,
  1,
  1,
  1,
  0.8,
  0.8,
  0.8,
  1,
  1,
  1,
  0.8,
  0.8,
  0.8,
  -1,
  1,
  -1,
  0,
  0,
  0.74,
  -1,
  1,
  -1,
  0,
  0,
  0.74,
  -1,
  1,
  1,
  0,
  0,
  0.74,
  1,
  1,
  -1,
  0,
  0,
  0.74,
  1,
  1,
  1,
  0,
  0,
  0.74,
  1,
  1,
  1,
  0,
  0,
  0.74,
  -1,
  -1,
  -1,
  0.42,
  0,
  0.42,
  -1,
  -1,
  -1,
  0.42,
  0,
  0.42,
  1,
  -1,
  -1,
  0.42,
  0,
  0.42,
  -1,
  -1,
  1,
  0.42,
  0,
  0.42,
  1,
  -1,
  1,
  0.42,
  0,
  0.42,
  1,
  -1,
  1,
  0.42,
  0,
  0.42,
  -1,
  -1,
  -1,
  0.64,
  0,
  0,
  -1,
  -1,
  -1,
  0.64,
  0,
  0,
  -1,
  -1,
  1,
  0.64,
  0,
  0,
  -1,
  1,
  -1,
  0.64,
  0,
  0,
  -1,
  1,
  1,
  0.64,
  0,
  0,
  -1,
  1,
  1,
  0.64,
  0,
  0,
  1,
  -1,
  -1,
  0,
  0.5,
  0,
  1,
  -1,
  -1,
  0,
  0.5,
  0,
  1,
  1,
  -1,
  0,
  0.5,
  0,
  1,
  -1,
  1,
  0,
  0.5,
  0,
  1,
  1,
  1,
  0,
  0.5,
  0,
  1,
  1,
  1,
  0,
  0.5,
  0,
  // P
  -0.45,
  1,
  -0.8,
  0,
  0,
  0,
  -0.45,
  1,
  -0.8,
  0,
  0,
  0,
  -0.45,
  1,
  0.8,
  0,
  0,
  0,
  -0.25,
  1,
  -0.8,
  0,
  0,
  0,
  -0.25,
  1,
  0.8,
  0,
  0,
  0,
  -0.25,
  1,
  0.8,
  0,
  0,
  0,
  -0.25,
  1,
  0.6,
  0,
  0,
  0,
  -0.25,
  1,
  0.6,
  0,
  0,
  0,
  -0.25,
  1,
  0.8,
  0,
  0,
  0,
  0.45,
  1,
  0.6,
  0,
  0,
  0,
  0.25,
  1,
  0.8,
  0,
  0,
  0,
  0.25,
  1,
  0.8,
  0,
  0,
  0,
  0.25,
  1,
  0.1,
  0,
  0,
  0,
  0.25,
  1,
  0.1,
  0,
  0,
  0,
  0.25,
  1,
  0.6,
  0,
  0,
  0,
  0.45,
  1,
  0.1,
  0,
  0,
  0,
  0.45,
  1,
  0.6,
  0,
  0,
  0,
  0.45,
  1,
  0.6,
  0,
  0,
  0,
  -0.25,
  1,
  -0.1,
  0,
  0,
  0,
  -0.25,
  1,
  -0.1,
  0,
  0,
  0,
  -0.25,
  1,
  0.1,
  0,
  0,
  0,
  0.25,
  1,
  -0.1,
  0,
  0,
  0,
  0.45,
  1,
  0.1,
  0,
  0,
  0,
  0.45,
  1,
  0.1,
  0,
  0,
  0,
  // A
  0.45,
  -1,
  -0.8,
  0,
  0,
  0,
  0.45,
  -1,
  -0.8,
  0,
  0,
  0,
  0.05,
  -1,
  0.8,
  0,
  0,
  0,
  0.25,
  -1,
  -0.8,
  0,
  0,
  0,
  -0.15,
  -1,
  0.8,
  0,
  0,
  0,
  -0.15,
  -1,
  0.8,
  0,
  0,
  0,
  -0.25,
  -1,
  -0.8,
  0,
  0,
  0,
  -0.25,
  -1,
  -0.8,
  0,
  0,
  0,
  0.05,
  -1,
  0.8,
  0,
  0,
  0,
  -0.45,
  -1,
  -0.8,
  0,
  0,
  0,
  -0.15,
  -1,
  0.8,
  0,
  0,
  0,
  -0.15,
  -1,
  0.8,
  0,
  0,
  0,
  0.13,
  -1,
  -0.3,
  0,
  0,
  0,
  0.13,
  -1,
  -0.3,
  0,
  0,
  0,
  0.07,
  -1,
  -0.1,
  0,
  0,
  0,
  -0.33,
  -1,
  -0.3,
  0,
  0,
  0,
  -0.27,
  -1,
  -0.1,
  0,
  0,
  0,
  -0.27,
  -1,
  -0.1,
  0,
  0,
  0,
  // S
  -0.45,
  0.6,
  1,
  0,
  0,
  0,
  -0.45,
  0.6,
  1,
  0,
  0,
  0,
  -0.45,
  0.4,
  1,
  0,
  0,
  0,
  -0.25,
  0.8,
  1,
  0,
  0,
  0,
  -0.25,
  0.4,
  1,
  0,
  0,
  0,
  -0.25,
  0.4,
  1,
  0,
  0,
  0,
  -0.25,
  0.8,
  1,
  0,
  0,
  0,
  -0.25,
  0.8,
  1,
  0,
  0,
  0,
  -0.25,
  0.6,
  1,
  0,
  0,
  0,
  0.25,
  0.8,
  1,
  0,
  0,
  0,
  0.45,
  0.6,
  1,
  0,
  0,
  0,
  0.45,
  0.6,
  1,
  0,
  0,
  0,
  0.25,
  0.8,
  1,
  0,
  0,
  0,
  0.25,
  0.8,
  1,
  0,
  0,
  0,
  0.25,
  -0.1,
  1,
  0,
  0,
  0,
  0.45,
  0.6,
  1,
  0,
  0,
  0,
  0.45,
  0.1,
  1,
  0,
  0,
  0,
  0.45,
  0.1,
  1,
  0,
  0,
  0,
  -0.25,
  0.1,
  1,
  0,
  0,
  0,
  -0.25,
  0.1,
  1,
  0,
  0,
  0,
  -0.45,
  -0.1,
  1,
  0,
  0,
  0,
  0.25,
  0.1,
  1,
  0,
  0,
  0,
  0.25,
  -0.1,
  1,
  0,
  0,
  0,
  0.25,
  -0.1,
  1,
  0,
  0,
  0,
  -0.45,
  -0.1,
  1,
  0,
  0,
  0,
  -0.45,
  -0.1,
  1,
  0,
  0,
  0,
  -0.45,
  -0.6,
  1,
  0,
  0,
  0,
  -0.25,
  -0.1,
  1,
  0,
  0,
  0,
  -0.25,
  -0.8,
  1,
  0,
  0,
  0,
  -0.25,
  -0.8,
  1,
  0,
  0,
  0,
  -0.25,
  -0.6,
  1,
  0,
  0,
  0,
  -0.25,
  -0.6,
  1,
  0,
  0,
  0,
  -0.25,
  -0.8,
  1,
  0,
  0,
  0,
  0.45,
  -0.6,
  1,
  0,
  0,
  0,
  0.25,
  -0.8,
  1,
  0,
  0,
  0,
  0.25,
  -0.8,
  1,
  0,
  0,
  0,
  0.25,
  -0.4,
  1,
  0,
  0,
  0,
  0.25,
  -0.4,
  1,
  0,
  0,
  0,
  0.25,
  -0.6,
  1,
  0,
  0,
  0,
  0.45,
  -0.4,
  1,
  0,
  0,
  0,
  0.45,
  -0.6,
  1,
  0,
  0,
  0,
  0.45,
  -0.6,
  1,
  0,
  0,
  0,
  // I
  -0.1,
  -0.8,
  -1,
  0,
  0,
  0,
  -0.1,
  -0.8,
  -1,
  0,
  0,
  0,
  -0.1,
  0.8,
  -1,
  0,
  0,
  0,
  0.1,
  -0.8,
  -1,
  0,
  0,
  0,
  0.1,
  0.8,
  -1,
  0,
  0,
  0,
  0.1,
  0.8,
  -1,
  0,
  0,
  0,
  // L
  -1,
  -0.45,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.45,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.45,
  0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  -1,
  -0.25,
  -0.6,
  0,
  0,
  0,
  -1,
  0.45,
  -0.8,
  0,
  0,
  0,
  -1,
  0.45,
  -0.6,
  0,
  0,
  0,
  -1,
  0.45,
  -0.6,
  0,
  0,
  0,
  // R
  1,
  0.45,
  -0.8,
  0,
  0,
  0,
  1,
  0.45,
  -0.8,
  0,
  0,
  0,
  1,
  0.45,
  0.8,
  0,
  0,
  0,
  1,
  0.25,
  -0.8,
  0,
  0,
  0,
  1,
  0.25,
  0.8,
  0,
  0,
  0,
  1,
  0.25,
  0.8,
  0,
  0,
  0,
  1,
  0.25,
  0.6,
  0,
  0,
  0,
  1,
  0.25,
  0.6,
  0,
  0,
  0,
  1,
  0.25,
  0.8,
  0,
  0,
  0,
  1,
  -0.45,
  0.6,
  0,
  0,
  0,
  1,
  -0.25,
  0.8,
  0,
  0,
  0,
  1,
  -0.25,
  0.8,
  0,
  0,
  0,
  1,
  -0.25,
  0.1,
  0,
  0,
  0,
  1,
  -0.25,
  0.1,
  0,
  0,
  0,
  1,
  -0.25,
  0.6,
  0,
  0,
  0,
  1,
  -0.45,
  0.1,
  0,
  0,
  0,
  1,
  -0.45,
  0.6,
  0,
  0,
  0,
  1,
  -0.45,
  0.6,
  0,
  0,
  0,
  1,
  0.25,
  -0.1,
  0,
  0,
  0,
  1,
  0.25,
  -0.1,
  0,
  0,
  0,
  1,
  0.25,
  0.1,
  0,
  0,
  0,
  1,
  -0.25,
  -0.1,
  0,
  0,
  0,
  1,
  -0.45,
  0.1,
  0,
  0,
  0,
  1,
  -0.45,
  0.1,
  0,
  0,
  0,
  1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  1,
  -0.25,
  -0.8,
  0,
  0,
  0,
  1,
  -0.05,
  -0.1,
  0,
  0,
  0,
  1,
  -0.45,
  -0.8,
  0,
  0,
  0,
  1,
  -0.25,
  -0.1,
  0,
  0,
  0,
  1,
  -0.25,
  -0.1,
  0,
  0,
  0
]), st = class {
  constructor(t, i, s, r, a = null, n = null) {
    I(this, "sphereIdx", []), I(this, "sphereVtx", []), I(this, "renderShaders", []), I(this, "isVisible", !0), I(this, "isPickable", !0), I(this, "vertexBuffer"), I(this, "indexCount"), I(this, "indexBuffer"), I(this, "vao"), I(this, "mode"), I(this, "glFlags", 0), I(this, "id"), I(this, "colorId"), I(this, "modelMatrix", it()), I(this, "scale", [1, 1, 1]), I(this, "position", [0, 0, 0]), I(this, "rotation", [0, 0, 0]), I(this, "rotationRadians", 0), I(this, "extentsMin", []), I(this, "extentsMax", []), I(this, "furthestVertexFromOrigin"), I(this, "originNegate"), I(this, "fieldOfViewDeObliqueMM"), I(this, "mm"), this.vertexBuffer = i, this.indexCount = r, this.indexBuffer = a, this.vao = n, this.mode = s, this.id = t, this.colorId = [
      (t >> 0 & 255) / 255,
      (t >> 8 & 255) / 255,
      (t >> 16 & 255) / 255,
      (t >> 24 & 255) / 255
    ];
  }
};
I(st, "BLEND", 1);
I(st, "CULL_FACE", 2);
I(st, "CULL_FRONT", 4);
I(st, "CULL_BACK", 8);
I(st, "ENABLE_DEPTH_TEST", 16);
I(st, "generateCrosshairs", function(e, t, i, s, r, a, n = 20, o = 0) {
  const l = st.generateCrosshairsGeometry(e, i, s, r, a, n, o);
  return new st(
    t,
    l.vertexBuffer,
    e.TRIANGLES,
    l.indexCount,
    l.indexBuffer,
    l.vao
  );
});
I(st, "generateCrosshairsGeometry", function(e, t, i, s, r, a = 20, n = 0) {
  const o = [], l = [], c = r * n;
  if (c <= 0) {
    let u = O(i[0], t[1], t[2]), m = O(s[0], t[1], t[2]);
    st.makeCylinder(o, l, u, m, r, a), u = O(t[0], i[1], t[2]), m = O(t[0], s[1], t[2]), st.makeCylinder(o, l, u, m, r, a), u = O(t[0], t[1], i[2]), m = O(t[0], t[1], s[2]), st.makeCylinder(o, l, u, m, r, a);
  } else {
    let u = O(i[0], t[1], t[2]), m = O(t[0] - c, t[1], t[2]);
    st.makeCylinder(o, l, u, m, r, a, !1), u = O(t[0] + c, t[1], t[2]), m = O(s[0], t[1], t[2]), st.makeCylinder(o, l, u, m, r, a, !1), u = O(t[0], i[1], t[2]), m = O(t[0], t[1] - c, t[2]), st.makeCylinder(o, l, u, m, r, a, !1), u = O(t[0], t[1] + c, t[2]), m = O(t[0], s[1], t[2]), st.makeCylinder(o, l, u, m, r, a, !1), u = O(t[0], t[1], i[2]), m = O(t[0], t[1], t[2] - c), st.makeCylinder(o, l, u, m, r, a, !1), u = O(t[0], t[1], t[2] + c), m = O(t[0], t[1], s[2]), st.makeCylinder(o, l, u, m, r, a, !1);
  }
  const h = e.createBuffer();
  if (h === null)
    throw new Error("could not instantiate vertex buffer");
  e.bindBuffer(e.ARRAY_BUFFER, h), e.bufferData(e.ARRAY_BUFFER, new Float32Array(o), e.STATIC_DRAW);
  const f = e.createBuffer();
  if (f === null)
    throw new Error("could not instantiate index buffer");
  e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, f), e.bufferData(e.ELEMENT_ARRAY_BUFFER, new Uint32Array(l), e.STATIC_DRAW);
  const d = e.createVertexArray();
  return e.bindVertexArray(d), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, f), e.bindBuffer(e.ARRAY_BUFFER, h), e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 3, e.FLOAT, !1, 0, 0), e.bindVertexArray(null), {
    vertexBuffer: h,
    indexBuffer: f,
    indexCount: l.length,
    vao: d
  };
});
I(st, "getFirstPerpVector", function(e) {
  const t = O(0, 0, 0);
  return e[0] === 0 ? t[0] = 1 : e[1] === 0 ? t[1] = 1 : e[2] === 0 ? t[2] = 1 : (t[0] = e[2], t[1] = e[2], t[2] = -(e[0] + e[1]), Rt(t, t)), t;
});
I(st, "subdivide", function(e, t) {
  let i = e.length / 3, s = t.length / 3;
  const r = s, a = nt(), n = nt();
  for (let o = 0; o < r; o++) {
    const l = t[o * 3 + 0], c = t[o * 3 + 1], h = t[o * 3 + 2], f = O(e[l * 3 + 0], e[l * 3 + 1], e[l * 3 + 2]), d = O(e[c * 3 + 0], e[c * 3 + 1], e[c * 3 + 2]), u = O(e[h * 3 + 0], e[h * 3 + 1], e[h * 3 + 2]);
    le(a, f, d), Rt(n, a), e.push(...n), le(a, d, u), Rt(n, a), e.push(...n), le(a, f, u), Rt(n, a), e.push(...n);
    let m = [i, i + 1, i + 2];
    t.push(...m), m = [l, i, i + 2], t.push(...m), m = [i, c, i + 1], t.push(...m), t[o * 3 + 0] = i + 2, t[o * 3 + 1] = i + 1, t[o * 3 + 2] = h, s = s + 3, i = i + 3;
  }
});
I(st, "weldVertices", function(e, t) {
  const i = e.length / 3;
  let s = 0;
  const r = new Int32Array(i);
  for (let o = 0; o < i - 1; o++) {
    if (r[o] !== 0)
      continue;
    r[o] = s;
    let l = o * 3;
    const c = e[l], h = e[l + 1], f = e[l + 2];
    for (let d = o + 1; d < i; d++)
      l += 3, c === e[l] && h === e[l + 1] && f === e[l + 2] && (r[d] = s);
    s++;
  }
  if (s === i)
    return e;
  const a = t.length;
  for (let o = 0; o < a; o++)
    t[o] = r[t[o]];
  const n = e.slice(0, s * 3 - 1);
  for (let o = 0; o < i - 1; o++) {
    const l = o * 3, c = r[o] * 3;
    n[c] = e[l], n[c + 1] = e[l + 1], n[c + 2] = e[l + 2];
  }
  return n;
});
I(st, "makeSphere", function(e, t, i, s = [0, 0, 0]) {
  let r = [
    0,
    0,
    1,
    0.894,
    0,
    0.447,
    0.276,
    0.851,
    0.447,
    -0.724,
    0.526,
    0.447,
    -0.724,
    -0.526,
    0.447,
    0.276,
    -0.851,
    0.447,
    0.724,
    0.526,
    -0.447,
    -0.276,
    0.851,
    -0.447,
    -0.894,
    0,
    -0.447,
    -0.276,
    -0.851,
    -0.447,
    0.724,
    -0.526,
    -0.447,
    0,
    0,
    -1
  ];
  const a = [
    0,
    1,
    2,
    0,
    2,
    3,
    0,
    3,
    4,
    0,
    4,
    5,
    0,
    5,
    1,
    7,
    6,
    11,
    8,
    7,
    11,
    9,
    8,
    11,
    10,
    9,
    11,
    6,
    10,
    11,
    6,
    2,
    1,
    7,
    3,
    2,
    8,
    4,
    3,
    9,
    5,
    4,
    10,
    1,
    5,
    6,
    7,
    2,
    7,
    8,
    3,
    8,
    9,
    4,
    9,
    10,
    5,
    10,
    6,
    1
  ];
  st.subdivide(r, a), st.subdivide(r, a), r = st.weldVertices(r, a);
  for (let c = 0; c < r.length; c++)
    r[c] = r[c] * i;
  const n = r.length / 3;
  let o = 0;
  for (let c = 0; c < n; c++)
    r[o] = r[o] + s[0], o++, r[o] = r[o] + s[1], o++, r[o] = r[o] + s[2], o++;
  const l = Math.floor(e.length / 3);
  for (let c = 0; c < a.length; c++)
    a[c] = a[c] + l;
  t.push(...a), e.push(...r);
});
I(st, "makeCylinder", function(e, t, i, s, r, a = 20, n = !0) {
  a < 3 && (a = 3);
  const o = nt();
  ot(o, s, i), Rt(o, o);
  const l = st.getFirstPerpVector(o), c = nt();
  mi(c, o, l), Rt(c, c);
  let h = 2 * a, f = 2 * a;
  n && (f += 2 * a, h += 2);
  const d = Math.floor(e.length / 3), u = new Uint32Array(f * 3), m = new Float32Array(h * 3);
  function g(F, C) {
    m[F * 3 + 0] = C[0], m[F * 3 + 1] = C[1], m[F * 3 + 2] = C[2];
  }
  function p(F, C, b, y) {
    u[F * 3 + 0] = C + d, u[F * 3 + 1] = b + d, u[F * 3 + 2] = y + d;
  }
  const A = 2 * a, x = A + 1;
  n && (g(A, i), g(x, s));
  const w = nt(), v = nt();
  for (let F = 0; F < a; F++) {
    const C = Math.cos(F / a * 2 * Math.PI), b = Math.sin(F / a * 2 * Math.PI);
    w[0] = r * (C * l[0] + b * c[0]), w[1] = r * (C * l[1] + b * c[1]), w[2] = r * (C * l[2] + b * c[2]), le(v, i, w), g(F, v), le(v, s, w), g(F + a, v);
    let y = 0;
    F < a - 1 && (y = F + 1), p(F * 2, F, y, F + a), p(F * 2 + 1, y, y + a, F + a), n && (p(a * 2 + F, F, A, y), p(a * 2 + F + a, x, F + a, y + a));
  }
  t.push(...u), e.push(...m);
});
I(st, "makeColoredCylinder", function(e, t, i, s, r, a, n = [192, 0, 0, 255], o = 20, l = !1) {
  let c = e.length / 3;
  st.makeCylinder(e, t, s, r, a, o, l), c = e.length / 3 - c;
  const h = [];
  for (let f = 0; f < c * 4 - 1; f += 4)
    h[f] = n[0], h[f + 1] = n[1], h[f + 2] = n[2], h[f + 3] = n[3];
  i.push(...h);
});
I(st, "makeColoredSphere", function(e, t, i, s, r = [0, 0, 0], a = [0, 0, 192, 255]) {
  let n = e.length / 3;
  st.makeSphere(e, t, s, r), n = e.length / 3 - n;
  const o = [];
  for (let l = 0; l < n * 4 - 1; l += 4)
    o[l] = a[0], o[l + 1] = a[1], o[l + 2] = a[2], o[l + 3] = a[3];
  i.push(...o);
});
var he = st, en = class Lt {
  constructor({ name: t = "niivue", level: i = "info" } = {}) {
    I(this, "level"), I(this, "name"), this.name = `${t}`, this.level = i;
  }
  debug(...t) {
    Lt.levels[this.level] > Lt.levels.debug || console.debug(`${this.name}-debug`, ...t);
  }
  info(...t) {
    Lt.levels[this.level] > Lt.levels.info || console.info(`${this.name}-info`, ...t);
  }
  warn(...t) {
    Lt.levels[this.level] > Lt.levels.warn || console.warn(`${this.name}-warn`, ...t);
  }
  error(...t) {
    Lt.levels[this.level] > Lt.levels.error || console.error(`${this.name}-error`, ...t);
  }
  fatal(...t) {
    Lt.levels[this.level] > Lt.levels.fatal || console.error(`${this.name}-fatal`, ...t);
  }
  setLogLevel(t) {
    this.level = t;
  }
  setName(t) {
    this.name = t;
  }
};
I(en, "levels", {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  fatal: 4,
  silent: 1 / 0
});
var Eo = en, V = new Eo({ name: "niivue", level: "info" }), xi = {};
Ii(xi, {
  $itksnap: () => Do,
  $slicer3d: () => So,
  actc: () => Io,
  afni_blues_inv: () => Yl,
  afni_reds_inv: () => Wl,
  batlow: () => To,
  bcgwhw: () => Bo,
  bcgwhw_dark: () => Vo,
  blue: () => Lo,
  blue2cyan: () => Po,
  blue2magenta: () => Ro,
  blue2red: () => Uo,
  bluegrn: () => No,
  bone: () => ko,
  bronze: () => Oo,
  cet_l17: () => zo,
  cividis: () => Go,
  cool: () => Yo,
  copper: () => Ko,
  copper2: () => Wo,
  ct_airways: () => Xo,
  ct_artery: () => qo,
  ct_bones: () => Ho,
  ct_brain: () => Qo,
  ct_brain_gray: () => _o,
  ct_cardiac: () => jo,
  ct_head: () => Zo,
  ct_kidneys: () => Jo,
  ct_liver: () => $o,
  ct_muscles: () => tl,
  ct_scalp: () => el,
  ct_skull: () => il,
  ct_soft: () => sl,
  ct_soft_tissue: () => rl,
  ct_surface: () => nl,
  ct_vessels: () => al,
  ct_w_contrast: () => ol,
  cubehelix: () => ll,
  electric_blue: () => cl,
  freesurfer: () => hl,
  ge_color: () => fl,
  gold: () => dl,
  gray: () => ul,
  green: () => ml,
  green2cyan: () => gl,
  green2orange: () => pl,
  hot: () => xl,
  hotiron: () => Al,
  hsv: () => vl,
  inferno: () => wl,
  jet: () => bl,
  kry: () => yl,
  linspecer: () => Cl,
  lipari: () => Fl,
  magma: () => Ml,
  mako: () => El,
  navia: () => Dl,
  nih: () => Sl,
  plasma: () => Il,
  random: () => Tl,
  red: () => Vl,
  redyell: () => Bl,
  rocket: () => Ul,
  roi_i256: () => Kl,
  surface: () => Rl,
  thermal: () => Pl,
  turbo: () => Nl,
  violet: () => Ll,
  viridis: () => kl,
  warm: () => Ol,
  winter: () => zl,
  x_rain: () => Gl
});
var Do = {
  R: [
    0,
    255,
    0,
    0,
    255,
    0,
    255,
    255,
    0,
    205,
    210,
    102,
    0,
    0,
    46,
    255,
    106,
    221,
    233,
    165,
    255,
    147,
    218,
    75,
    255,
    60,
    255,
    255,
    218,
    0,
    188,
    255,
    255,
    222,
    127,
    139,
    124,
    255,
    70,
    0,
    238,
    238,
    240,
    245,
    184,
    32,
    255,
    25,
    112,
    34,
    248,
    245,
    255,
    144,
    173,
    65,
    255,
    250,
    128,
    50,
    244,
    255,
    123,
    255,
    173,
    255,
    127,
    255,
    143,
    220,
    253,
    255,
    0,
    0,
    128,
    255,
    250,
    148,
    178,
    255,
    135,
    100,
    240,
    250,
    255,
    107,
    135,
    0,
    139,
    245,
    186,
    255,
    255,
    0,
    210,
    255,
    47,
    72,
    175,
    128,
    176,
    255,
    139,
    240,
    255,
    216,
    119,
    219,
    72,
    255,
    199,
    154,
    189,
    240,
    230,
    0,
    85,
    64,
    153,
    205,
    250,
    95,
    0,
    255,
    224,
    176,
    138,
    30,
    240,
    152,
    160
  ],
  G: [
    0,
    0,
    255,
    0,
    255,
    255,
    0,
    239,
    0,
    133,
    180,
    205,
    0,
    139,
    139,
    228,
    90,
    160,
    150,
    42,
    250,
    112,
    112,
    0,
    182,
    179,
    235,
    228,
    165,
    128,
    143,
    105,
    218,
    184,
    255,
    69,
    252,
    255,
    130,
    100,
    130,
    232,
    255,
    222,
    134,
    178,
    20,
    25,
    128,
    139,
    248,
    255,
    160,
    238,
    255,
    105,
    99,
    240,
    0,
    205,
    164,
    255,
    104,
    165,
    216,
    192,
    255,
    140,
    188,
    20,
    245,
    250,
    206,
    255,
    0,
    250,
    128,
    0,
    34,
    127,
    206,
    149,
    230,
    235,
    245,
    142,
    206,
    0,
    0,
    245,
    85,
    228,
    222,
    191,
    105,
    248,
    79,
    61,
    238,
    128,
    224,
    240,
    0,
    255,
    215,
    191,
    136,
    112,
    209,
    0,
    21,
    205,
    183,
    248,
    230,
    250,
    107,
    224,
    50,
    92,
    250,
    158,
    128,
    69,
    255,
    196,
    43,
    144,
    128,
    251,
    82
  ],
  B: [
    0,
    0,
    0,
    255,
    0,
    255,
    255,
    213,
    205,
    63,
    140,
    170,
    128,
    139,
    87,
    225,
    205,
    221,
    122,
    42,
    250,
    219,
    214,
    130,
    193,
    113,
    205,
    196,
    32,
    128,
    143,
    180,
    185,
    135,
    0,
    19,
    0,
    224,
    180,
    0,
    238,
    170,
    240,
    179,
    11,
    170,
    147,
    112,
    144,
    34,
    255,
    250,
    122,
    144,
    47,
    225,
    71,
    230,
    0,
    50,
    96,
    240,
    238,
    0,
    230,
    203,
    212,
    0,
    143,
    60,
    230,
    240,
    209,
    127,
    128,
    205,
    114,
    211,
    34,
    80,
    235,
    237,
    140,
    215,
    238,
    35,
    250,
    139,
    139,
    220,
    211,
    181,
    173,
    255,
    30,
    220,
    79,
    139,
    238,
    0,
    230,
    245,
    0,
    255,
    0,
    216,
    153,
    147,
    204,
    255,
    133,
    50,
    107,
    255,
    250,
    154,
    47,
    208,
    204,
    92,
    210,
    160,
    0,
    0,
    255,
    222,
    226,
    255,
    128,
    152,
    45
  ],
  A: [
    0,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130
  ]
}, So = {
  labels: [
    "background",
    "tissue",
    "bone",
    "skin",
    "connective tissue",
    "blood",
    "organ",
    "mass",
    "muscle",
    "foreign object",
    "waste",
    "teeth",
    "fat",
    "gray matter",
    "white matter",
    "nerve",
    "vein",
    "artery",
    "capillary",
    "ligament",
    "tendon",
    "cartilage",
    "meniscus",
    "lymph node",
    "lymphatic vessel",
    "cerebro-spinal fluid",
    "bile",
    "urine",
    "feces",
    "gas",
    "fluid",
    "edema",
    "bleeding",
    "necrosis",
    "clot",
    "embolism",
    "head",
    "central nervous system",
    "brain",
    "gray matter of brain",
    "telencephalon",
    "cerebral cortex",
    "right frontal lobe",
    "left frontal lobe",
    "right temporal lobe",
    "left temporal lobe",
    "right parietal lobe",
    "left parietal lobe",
    "right occipital lobe",
    "left occipital lobe",
    "right insular lobe",
    "left insular lobe",
    "right limbic lobe",
    "left limbic lobe",
    "right striatum",
    "left striatum",
    "right caudate nucleus",
    "left caudate nucleus",
    "right putamen",
    "left putamen",
    "right pallidum",
    "left pallidum",
    "right amygdaloid complex",
    "left amygdaloid complex",
    "diencephalon",
    "thalamus",
    "right thalamus",
    "left thalamus",
    "pineal gland",
    "midbrain",
    "substantia nigra",
    "right substantia nigra",
    "left substantia nigra",
    "cerebral white matter",
    "right superior longitudinal fasciculus",
    "left superior longitudinal fasciculus",
    "right inferior longitudinal fasciculus",
    "left inferior longitudinal fasciculus",
    "right arcuate fasciculus",
    "left arcuate fasciculus",
    "right uncinate fasciculus",
    "left uncinate fasciculus",
    "right cingulum bundle",
    "left cingulum bundle",
    "projection fibers",
    "right corticospinal tract",
    "left corticospinal tract",
    "right optic radiation",
    "left optic radiation",
    "right medial lemniscus",
    "left medial lemniscus",
    "right superior cerebellar peduncle",
    "left superior cerebellar peduncle",
    "right middle cerebellar peduncle",
    "left middle cerebellar peduncle",
    "right inferior cerebellar peduncle",
    "left inferior cerebellar peduncle",
    "optic chiasm",
    "right optic tract",
    "left optic tract",
    "right fornix",
    "left fornix",
    "commissural fibers",
    "corpus callosum",
    "posterior commissure",
    "cerebellar white matter",
    "CSF space",
    "ventricles of brain",
    "right lateral ventricle",
    "left lateral ventricle",
    "right third ventricle",
    "left third ventricle",
    "cerebral aqueduct",
    "fourth ventricle",
    "subarachnoid space",
    "spinal cord",
    "gray matter of spinal cord",
    "white matter of spinal cord",
    "endocrine system of brain",
    "pituitary gland",
    "adenohypophysis",
    "neurohypophysis",
    "meninges",
    "dura mater",
    "arachnoid",
    "pia mater",
    "muscles of head",
    "salivary glands",
    "lips",
    "nose",
    "tongue",
    "soft palate",
    "right inner ear",
    "left inner ear",
    "right external ear",
    "left external ear",
    "right middle ear",
    "left middle ear",
    "right eyeball",
    "left eyeball",
    "skull",
    "right frontal bone",
    "left frontal bone",
    "right parietal bone",
    "left parietal bone",
    "right temporal bone",
    "left temporal bone",
    "right sphenoid bone",
    "left sphenoid bone",
    "right ethmoid bone",
    "left ethmoid bone",
    "occipital bone",
    "maxilla",
    "right zygomatic bone",
    "right lacrimal bone",
    "vomer bone",
    "right palatine bone",
    "left palatine bone",
    "mandible",
    "neck",
    "muscles of neck",
    "pharynx",
    "larynx",
    "thyroid gland",
    "right parathyroid glands",
    "left parathyroid glands",
    "skeleton of neck",
    "hyoid bone",
    "cervical vertebral column",
    "thorax",
    "trachea",
    "bronchi",
    "right lung",
    "left lung",
    "superior lobe of right lung",
    "superior lobe of left lung",
    "middle lobe of right lung",
    "inferior lobe of right lung",
    "inferior lobe of left lung",
    "pleura",
    "heart",
    "right atrium",
    "left atrium",
    "atrial septum",
    "ventricular septum",
    "right ventricle of heart",
    "left ventricle of heart",
    "mitral valve",
    "tricuspid valve",
    "aortic valve",
    "pulmonary valve",
    "aorta",
    "pericardium",
    "pericardial cavity",
    "esophagus",
    "thymus",
    "mediastinum",
    "skin of thoracic wall",
    "muscles of thoracic wall",
    "skeleton of thorax",
    "thoracic vertebral column",
    "ribs",
    "sternum",
    "right clavicle",
    "left clavicle",
    "abdominal cavity",
    "abdomen",
    "peritoneum",
    "omentum",
    "peritoneal cavity",
    "retroperitoneal space",
    "stomach",
    "duodenum",
    "small bowel",
    "colon",
    "anus",
    "liver",
    "biliary tree",
    "gallbladder",
    "pancreas",
    "spleen",
    "urinary system",
    "right kidney",
    "left kidney",
    "right ureter",
    "left ureter",
    "urinary bladder",
    "urethra",
    "right adrenal gland",
    "left adrenal gland",
    "female internal genitalia",
    "uterus",
    "right fallopian tube",
    "left fallopian tube",
    "right ovary",
    "left ovary",
    "vagina",
    "male internal genitalia",
    "prostate",
    "right seminal vesicle",
    "left seminal vesicle",
    "right deferent duct",
    "left deferent duct",
    "skin of abdominal wall",
    "muscles of abdominal wall",
    "skeleton of abdomen",
    "lumbar vertebral column",
    "female external genitalia",
    "male external genitalia",
    "skeleton of upper limb",
    "muscles of upper limb",
    "right upper limb",
    "left upper limb",
    "right shoulder",
    "left shoulder",
    "right arm"
  ],
  R: [
    0,
    128,
    241,
    177,
    111,
    216,
    221,
    144,
    192,
    220,
    78,
    255,
    230,
    200,
    250,
    244,
    0,
    216,
    183,
    183,
    152,
    111,
    178,
    68,
    111,
    85,
    0,
    214,
    78,
    218,
    170,
    140,
    188,
    216,
    145,
    150,
    177,
    244,
    250,
    200,
    68,
    128,
    83,
    83,
    162,
    162,
    141,
    141,
    182,
    182,
    188,
    188,
    154,
    154,
    177,
    177,
    30,
    30,
    210,
    210,
    48,
    48,
    98,
    98,
    69,
    166,
    122,
    122,
    253,
    145,
    46,
    0,
    0,
    250,
    127,
    127,
    159,
    159,
    125,
    125,
    106,
    106,
    154,
    154,
    126,
    201,
    201,
    78,
    78,
    174,
    174,
    139,
    139,
    148,
    148,
    186,
    186,
    99,
    156,
    156,
    64,
    64,
    138,
    97,
    126,
    194,
    85,
    88,
    88,
    88,
    88,
    88,
    88,
    88,
    88,
    244,
    200,
    250,
    82,
    57,
    60,
    92,
    255,
    255,
    255,
    255,
    201,
    70,
    188,
    177,
    166,
    182,
    229,
    229,
    174,
    174,
    201,
    201,
    194,
    194,
    241,
    203,
    203,
    229,
    229,
    255,
    255,
    209,
    209,
    248,
    248,
    255,
    196,
    255,
    255,
    255,
    242,
    242,
    222,
    177,
    213,
    184,
    150,
    62,
    62,
    62,
    242,
    250,
    255,
    177,
    182,
    175,
    197,
    197,
    172,
    172,
    202,
    224,
    224,
    255,
    206,
    210,
    203,
    233,
    195,
    181,
    152,
    159,
    166,
    218,
    225,
    224,
    255,
    184,
    211,
    47,
    255,
    173,
    188,
    255,
    226,
    253,
    244,
    205,
    205,
    186,
    177,
    255,
    234,
    204,
    180,
    216,
    255,
    205,
    204,
    255,
    221,
    0,
    139,
    249,
    157,
    203,
    185,
    185,
    247,
    247,
    222,
    124,
    249,
    249,
    244,
    255,
    255,
    227,
    213,
    213,
    193,
    216,
    230,
    245,
    245,
    241,
    241,
    177,
    171,
    217,
    212,
    185,
    185,
    198,
    194,
    177,
    177,
    177,
    177,
    177
  ],
  G: [
    0,
    174,
    214,
    122,
    184,
    101,
    130,
    238,
    104,
    245,
    63,
    250,
    220,
    200,
    250,
    214,
    151,
    101,
    156,
    214,
    189,
    184,
    212,
    172,
    197,
    188,
    145,
    230,
    63,
    255,
    250,
    224,
    65,
    191,
    60,
    98,
    122,
    214,
    250,
    200,
    131,
    174,
    146,
    146,
    115,
    115,
    93,
    93,
    166,
    166,
    135,
    135,
    150,
    150,
    140,
    140,
    111,
    111,
    157,
    157,
    129,
    129,
    153,
    153,
    110,
    113,
    101,
    101,
    135,
    92,
    101,
    108,
    108,
    250,
    150,
    150,
    116,
    116,
    102,
    102,
    174,
    174,
    146,
    146,
    126,
    160,
    160,
    152,
    152,
    140,
    140,
    126,
    126,
    120,
    120,
    135,
    135,
    106,
    171,
    171,
    123,
    123,
    95,
    113,
    161,
    195,
    188,
    106,
    106,
    106,
    106,
    106,
    106,
    106,
    106,
    214,
    200,
    250,
    174,
    157,
    143,
    162,
    244,
    244,
    244,
    244,
    121,
    163,
    91,
    122,
    84,
    105,
    147,
    147,
    122,
    122,
    112,
    112,
    142,
    142,
    213,
    179,
    179,
    204,
    204,
    243,
    243,
    185,
    185,
    223,
    223,
    230,
    172,
    255,
    250,
    237,
    217,
    217,
    198,
    122,
    124,
    105,
    208,
    162,
    162,
    162,
    206,
    210,
    255,
    122,
    228,
    216,
    165,
    165,
    138,
    138,
    164,
    186,
    186,
    245,
    110,
    115,
    108,
    138,
    100,
    85,
    55,
    63,
    70,
    123,
    130,
    97,
    244,
    122,
    171,
    150,
    244,
    121,
    95,
    239,
    202,
    232,
    217,
    179,
    179,
    124,
    122,
    255,
    234,
    142,
    119,
    132,
    253,
    167,
    168,
    224,
    130,
    145,
    150,
    180,
    108,
    136,
    102,
    102,
    182,
    182,
    154,
    186,
    186,
    186,
    170,
    181,
    190,
    153,
    141,
    141,
    123,
    146,
    158,
    172,
    172,
    172,
    172,
    124,
    85,
    198,
    188,
    135,
    135,
    175,
    98,
    122,
    122,
    122,
    122,
    122
  ],
  B: [
    0,
    128,
    145,
    101,
    210,
    79,
    101,
    144,
    88,
    20,
    0,
    220,
    70,
    235,
    210,
    49,
    206,
    79,
    220,
    211,
    207,
    210,
    242,
    100,
    131,
    255,
    30,
    130,
    0,
    255,
    250,
    228,
    28,
    216,
    66,
    83,
    101,
    49,
    225,
    215,
    98,
    128,
    164,
    164,
    105,
    105,
    137,
    137,
    110,
    110,
    166,
    166,
    201,
    201,
    190,
    190,
    85,
    85,
    166,
    166,
    126,
    126,
    112,
    112,
    53,
    137,
    38,
    38,
    192,
    109,
    131,
    112,
    112,
    225,
    88,
    88,
    163,
    163,
    154,
    154,
    155,
    155,
    83,
    83,
    55,
    133,
    133,
    141,
    141,
    103,
    103,
    177,
    177,
    72,
    72,
    135,
    135,
    24,
    108,
    108,
    147,
    147,
    74,
    158,
    197,
    164,
    255,
    215,
    215,
    215,
    215,
    215,
    215,
    215,
    215,
    49,
    215,
    225,
    128,
    110,
    83,
    109,
    209,
    209,
    209,
    209,
    77,
    117,
    95,
    101,
    94,
    107,
    118,
    118,
    90,
    90,
    73,
    73,
    0,
    0,
    144,
    77,
    77,
    109,
    109,
    152,
    152,
    85,
    85,
    131,
    131,
    138,
    68,
    167,
    160,
    145,
    123,
    123,
    101,
    101,
    109,
    108,
    243,
    114,
    114,
    114,
    142,
    139,
    207,
    101,
    255,
    244,
    145,
    145,
    115,
    115,
    140,
    162,
    162,
    217,
    84,
    89,
    81,
    112,
    73,
    57,
    13,
    27,
    38,
    97,
    104,
    76,
    209,
    154,
    143,
    103,
    209,
    88,
    76,
    172,
    134,
    158,
    154,
    108,
    108,
    161,
    101,
    220,
    194,
    178,
    153,
    105,
    229,
    142,
    143,
    199,
    101,
    30,
    98,
    111,
    162,
    116,
    83,
    83,
    164,
    164,
    132,
    223,
    150,
    150,
    147,
    158,
    165,
    130,
    113,
    113,
    103,
    127,
    140,
    147,
    147,
    151,
    151,
    92,
    68,
    131,
    102,
    134,
    134,
    125,
    79,
    101,
    101,
    101,
    101,
    101
  ],
  A: [
    0,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ]
}, Io = {
  R: [0, 0, 24, 248, 255],
  G: [0, 0, 177, 254, 0],
  B: [0, 136, 0, 0, 0],
  A: [0, 32, 64, 78, 128],
  I: [0, 64, 128, 156, 255]
}, To = {
  R: [1, 10, 15, 17, 21, 27, 36, 49, 65, 82, 99, 118, 140, 161, 183, 203, 222, 238, 248, 253, 253, 253, 252, 250],
  G: [25, 42, 56, 68, 79, 88, 97, 105, 111, 116, 122, 127, 133, 138, 142, 146, 150, 155, 162, 170, 178, 186, 195, 204],
  B: [89, 92, 95, 96, 98, 98, 96, 91, 83, 74, 64, 55, 46, 43, 49, 62, 79, 100, 126, 151, 175, 199, 223, 250],
  A: [0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64],
  I: [0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 133, 144, 155, 166, 177, 188, 199, 210, 221, 232, 243, 255]
}, Vo = {
  R: [
    0,
    248,
    242,
    235,
    229,
    222,
    212,
    202,
    193,
    183,
    173,
    145,
    117,
    78,
    39,
    0,
    0,
    0,
    0,
    0,
    0,
    64,
    128,
    191,
    255,
    255,
    255,
    255,
    255,
    238,
    221,
    204,
    214,
    224,
    235,
    245,
    255,
    249,
    242,
    236,
    229,
    223,
    217,
    210,
    204,
    197,
    191,
    184,
    176,
    169,
    161,
    154,
    146,
    139,
    132,
    124,
    117,
    109,
    102,
    0
  ],
  G: [
    0,
    251,
    247,
    243,
    239,
    235,
    235,
    235,
    235,
    235,
    235,
    216,
    197,
    174,
    150,
    127,
    153,
    178,
    204,
    229,
    255,
    255,
    255,
    255,
    255,
    220,
    185,
    150,
    115,
    77,
    38,
    0,
    31,
    61,
    92,
    122,
    153,
    138,
    122,
    107,
    92,
    77,
    61,
    46,
    31,
    15,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  B: [
    0,
    254,
    253,
    252,
    251,
    250,
    251,
    252,
    253,
    254,
    255,
    226,
    198,
    132,
    66,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    40,
    80,
    120,
    160,
    200,
    199,
    198,
    197,
    196,
    196,
    195,
    194,
    193,
    192,
    191,
    184,
    176,
    169,
    161,
    154,
    146,
    139,
    132,
    124,
    117,
    109,
    102,
    0
  ],
  A: [
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256
  ],
  I: [
    0,
    4,
    8,
    12,
    16,
    20,
    24,
    28,
    32,
    36,
    40,
    44,
    48,
    52,
    56,
    60,
    64,
    68,
    72,
    76,
    80,
    84,
    88,
    92,
    96,
    100,
    104,
    108,
    112,
    116,
    120,
    124,
    128,
    132,
    136,
    140,
    144,
    148,
    152,
    156,
    160,
    164,
    168,
    172,
    176,
    180,
    184,
    188,
    192,
    196,
    200,
    204,
    208,
    212,
    216,
    220,
    224,
    228,
    232,
    236,
    240,
    244,
    248,
    255
  ]
}, Bo = {
  R: [
    255,
    248,
    242,
    235,
    229,
    222,
    212,
    202,
    193,
    183,
    173,
    145,
    117,
    78,
    39,
    0,
    0,
    0,
    0,
    0,
    0,
    64,
    128,
    191,
    255,
    255,
    255,
    255,
    255,
    238,
    221,
    204,
    214,
    224,
    235,
    245,
    255,
    249,
    242,
    236,
    229,
    223,
    217,
    210,
    204,
    197,
    191,
    184,
    176,
    169,
    161,
    154,
    146,
    139,
    132,
    124,
    117,
    109,
    102,
    0
  ],
  G: [
    255,
    251,
    247,
    243,
    239,
    235,
    235,
    235,
    235,
    235,
    235,
    216,
    197,
    174,
    150,
    127,
    153,
    178,
    204,
    229,
    255,
    255,
    255,
    255,
    255,
    220,
    185,
    150,
    115,
    77,
    38,
    0,
    31,
    61,
    92,
    122,
    153,
    138,
    122,
    107,
    92,
    77,
    61,
    46,
    31,
    15,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  B: [
    255,
    254,
    253,
    252,
    251,
    250,
    251,
    252,
    253,
    254,
    255,
    226,
    198,
    132,
    66,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    40,
    80,
    120,
    160,
    200,
    199,
    198,
    197,
    196,
    196,
    195,
    194,
    193,
    192,
    191,
    184,
    176,
    169,
    161,
    154,
    146,
    139,
    132,
    124,
    117,
    109,
    102,
    0
  ],
  A: [
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256
  ],
  I: [
    0,
    4,
    8,
    12,
    16,
    20,
    24,
    28,
    32,
    36,
    40,
    44,
    48,
    52,
    56,
    60,
    64,
    68,
    72,
    76,
    80,
    84,
    88,
    92,
    96,
    100,
    104,
    108,
    112,
    116,
    120,
    124,
    128,
    132,
    136,
    140,
    144,
    148,
    152,
    156,
    160,
    164,
    168,
    172,
    176,
    180,
    184,
    188,
    192,
    196,
    200,
    204,
    208,
    212,
    216,
    220,
    224,
    228,
    232,
    236,
    240,
    244,
    248,
    255
  ]
}, Uo = {
  R: [0, 0, 0, 0, 196, 255],
  G: [0, 32, 128, 128, 128, 32],
  B: [0, 255, 196, 0, 0, 0],
  A: [0, 128, 64, 64, 64, 128],
  I: [0, 1, 64, 128, 192, 255]
}, Ro = {
  R: [0, 255],
  G: [0, 0],
  B: [255, 255],
  A: [0, 128],
  I: [0, 255]
}, Po = {
  R: [0, 0],
  G: [0, 255],
  B: [255, 255],
  A: [0, 128],
  I: [0, 255]
}, No = {
  R: [0, 0, 0, 0],
  G: [0, 1, 128, 255],
  B: [0, 222, 127, 32],
  A: [0, 0, 64, 128],
  I: [0, 1, 128, 255]
}, Lo = {
  R: [0, 0, 0],
  G: [0, 0, 0],
  B: [0, 128, 255],
  A: [0, 64, 128],
  I: [0, 128, 255]
}, ko = {
  R: [0, 103, 255],
  G: [0, 126, 255],
  B: [0, 165, 255],
  A: [0, 76, 128],
  I: [0, 153, 255]
}, Oo = {
  R: [0, 43, 103, 199, 216, 255],
  G: [0, 0, 37, 155, 213, 255],
  B: [0, 0, 20, 97, 201, 255],
  A: [0, 44, 48, 54, 56, 56],
  I: [0, 64, 128, 196, 240, 255]
}, zo = {
  R: [
    0,
    9,
    24,
    33,
    40,
    46,
    52,
    57,
    62,
    66,
    70,
    74,
    78,
    81,
    85,
    88,
    91,
    94,
    98,
    101,
    103,
    106,
    109,
    112,
    114,
    117,
    119,
    121,
    124,
    126,
    128,
    130,
    133,
    135,
    137,
    139,
    141,
    143,
    145,
    147,
    149,
    151,
    153,
    155,
    157,
    159,
    161,
    163,
    164,
    166,
    168,
    169,
    171,
    172,
    174,
    175,
    177,
    178,
    180,
    181,
    183,
    184,
    186,
    187,
    189,
    190,
    191,
    193,
    194,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    222,
    223,
    224,
    224,
    225,
    226,
    226,
    227,
    228,
    228,
    229,
    229,
    230,
    231,
    231,
    232,
    233,
    233,
    234,
    234,
    235,
    235,
    236,
    236,
    236,
    237,
    237,
    237,
    238,
    238,
    238,
    239,
    239,
    239,
    240,
    240,
    240,
    241,
    241,
    241,
    242,
    242,
    242,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    245,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    244,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    243,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    241,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    242,
    243,
    243,
    244,
    244,
    245,
    246,
    246,
    247,
    247,
    248,
    249,
    249,
    250,
    250,
    251,
    251,
    252,
    252,
    253,
    253,
    254,
    254,
    254
  ],
  G: [
    42,
    41,
    41,
    41,
    40,
    40,
    40,
    39,
    39,
    39,
    38,
    38,
    37,
    37,
    36,
    36,
    35,
    35,
    34,
    34,
    33,
    32,
    32,
    31,
    30,
    30,
    30,
    30,
    29,
    29,
    29,
    29,
    28,
    28,
    28,
    27,
    27,
    27,
    26,
    26,
    26,
    25,
    25,
    25,
    24,
    24,
    24,
    24,
    24,
    25,
    25,
    26,
    27,
    27,
    28,
    28,
    29,
    30,
    30,
    31,
    31,
    32,
    33,
    33,
    34,
    34,
    35,
    36,
    36,
    37,
    38,
    39,
    40,
    42,
    43,
    44,
    45,
    47,
    48,
    49,
    50,
    51,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    62,
    63,
    64,
    65,
    66,
    68,
    69,
    71,
    72,
    73,
    75,
    76,
    77,
    79,
    80,
    81,
    83,
    84,
    85,
    87,
    88,
    89,
    90,
    92,
    93,
    94,
    95,
    97,
    98,
    100,
    101,
    102,
    104,
    105,
    107,
    108,
    109,
    111,
    112,
    113,
    115,
    116,
    117,
    119,
    120,
    121,
    122,
    124,
    125,
    126,
    128,
    129,
    130,
    132,
    133,
    134,
    136,
    137,
    138,
    140,
    141,
    142,
    144,
    145,
    146,
    147,
    149,
    150,
    151,
    153,
    154,
    155,
    156,
    158,
    159,
    160,
    161,
    163,
    164,
    165,
    167,
    168,
    169,
    170,
    172,
    173,
    174,
    175,
    176,
    178,
    179,
    180,
    181,
    183,
    184,
    185,
    186,
    187,
    189,
    190,
    191,
    192,
    193,
    194,
    196,
    197,
    198,
    199,
    200,
    201,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    238,
    239,
    240,
    241,
    241,
    242,
    243,
    244,
    244,
    245,
    246,
    247,
    248,
    248,
    249,
    250,
    251,
    251,
    252,
    253,
    254,
    255
  ],
  B: [
    167,
    167,
    166,
    166,
    166,
    165,
    165,
    165,
    164,
    164,
    164,
    163,
    163,
    162,
    162,
    162,
    161,
    161,
    161,
    160,
    160,
    160,
    159,
    159,
    158,
    158,
    157,
    157,
    156,
    155,
    155,
    154,
    154,
    153,
    153,
    152,
    151,
    151,
    150,
    150,
    149,
    149,
    148,
    147,
    147,
    146,
    146,
    145,
    144,
    144,
    143,
    143,
    142,
    141,
    141,
    140,
    139,
    139,
    138,
    137,
    137,
    136,
    135,
    135,
    134,
    133,
    133,
    132,
    131,
    131,
    130,
    130,
    129,
    128,
    128,
    127,
    127,
    126,
    125,
    125,
    124,
    124,
    123,
    123,
    122,
    121,
    121,
    120,
    119,
    119,
    118,
    118,
    117,
    116,
    116,
    116,
    115,
    115,
    114,
    114,
    113,
    113,
    113,
    112,
    112,
    111,
    111,
    110,
    110,
    109,
    109,
    109,
    108,
    108,
    107,
    107,
    106,
    106,
    106,
    106,
    106,
    105,
    105,
    105,
    105,
    105,
    105,
    105,
    104,
    104,
    104,
    104,
    104,
    103,
    103,
    103,
    103,
    103,
    102,
    102,
    102,
    103,
    103,
    103,
    103,
    104,
    104,
    104,
    104,
    104,
    105,
    105,
    105,
    105,
    106,
    106,
    106,
    106,
    106,
    107,
    107,
    107,
    107,
    108,
    108,
    109,
    110,
    111,
    111,
    112,
    113,
    113,
    114,
    115,
    115,
    116,
    117,
    117,
    118,
    119,
    120,
    120,
    121,
    122,
    122,
    123,
    124,
    125,
    126,
    128,
    129,
    130,
    131,
    132,
    134,
    135,
    136,
    137,
    138,
    140,
    141,
    142,
    143,
    144,
    146,
    147,
    148,
    149,
    150,
    152,
    153,
    155,
    157,
    158,
    160,
    162,
    163,
    165,
    167,
    168,
    170,
    172,
    173,
    175,
    177,
    178,
    180,
    182,
    183,
    185,
    187,
    188,
    190,
    193,
    196,
    199,
    201,
    204,
    207,
    210,
    212,
    215,
    218,
    221,
    224,
    226,
    229,
    232,
    235,
    238,
    240,
    243,
    246,
    249,
    252,
    255
  ],
  A: [
    0,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ]
}, Go = {
  R: [0, 86, 166, 255],
  G: [32, 92, 156, 233],
  B: [76, 108, 117, 69],
  A: [0, 56, 80, 88],
  I: [0, 64, 192, 255]
}, Yo = {
  R: [0, 0, 0],
  G: [127, 196, 254],
  B: [255, 255, 255],
  A: [0, 64, 128],
  I: [0, 128, 255]
}, Wo = {
  R: [0, 61, 122, 183, 244, 255],
  G: [0, 41, 81, 122, 163, 255],
  B: [0, 25, 51, 76, 102, 255],
  A: [0, 25, 51, 71, 102, 128],
  I: [0, 51, 102, 153, 204, 255]
}, Ko = {
  R: [0, 61, 122, 183, 244, 255],
  G: [0, 41, 81, 122, 163, 203],
  B: [0, 25, 51, 76, 102, 127],
  A: [0, 25, 51, 71, 102, 128],
  I: [0, 51, 102, 153, 204, 255]
}, Xo = {
  min: -643,
  max: -235,
  R: [0, 0, 0],
  G: [154, 154, 154],
  B: [179, 179, 101],
  A: [0, 32, 0],
  I: [0, 163, 255]
}, qo = {
  min: 114,
  max: 800,
  R: [0, 255, 255, 255],
  G: [0, 0, 129, 255],
  B: [0, 0, 0, 255],
  A: [0, 64, 88, 228],
  I: [0, 80, 160, 255]
}, Ho = {
  min: 180,
  max: 600,
  R: [0, 0, 113, 255],
  G: [0, 0, 109, 250],
  B: [0, 0, 101, 245],
  A: [0, 0, 100, 160],
  I: [0, 1, 128, 255]
}, _o = {
  min: -10,
  max: 110,
  R: [0, 127, 255],
  G: [0, 127, 255],
  B: [0, 127, 255],
  A: [0, 48, 128],
  I: [0, 124, 255]
}, Qo = {
  min: -10,
  max: 110,
  R: [0, 199, 255],
  G: [0, 127, 255],
  B: [0, 127, 255],
  A: [0, 48, 128],
  I: [0, 124, 255]
}, jo = {
  min: -80,
  max: 1e3,
  R: [0, 189, 150, 150, 150, 150, 255],
  G: [0, 169, 54, 54, 54, 54, 240],
  B: [0, 153, 52, 52, 52, 52, 242],
  A: [0, 32, 64, 0, 0, 64, 64],
  I: [0, 1, 82, 92, 234, 242, 255]
}, Zo = {
  min: -590,
  max: 600,
  R: [0, 241, 241, 248, 248, 178, 178, 232, 255, 255, 255],
  G: [0, 156, 156, 222, 222, 36, 36, 51, 255, 255, 255],
  B: [0, 130, 130, 169, 169, 24, 24, 37, 255, 255, 255],
  A: [0, 8, 0, 0, 0, 64, 64, 0, 0, 222, 222],
  I: [0, 2, 3, 64, 122, 142, 172, 182, 252, 253, 255]
}, Jo = {
  min: 114,
  max: 302,
  R: [0, 255, 255],
  G: [0, 129, 255],
  B: [0, 0, 255],
  A: [0, 88, 228],
  I: [0, 103, 255]
}, $o = {
  min: -23,
  max: 246,
  R: [0, 44, 255, 255, 255],
  G: [0, 128, 90, 255, 255],
  B: [0, 0, 70, 0, 255],
  A: [0, 0, 82, 184, 228],
  I: [0, 64, 131, 196, 255]
}, tl = {
  min: -100,
  max: 246,
  R: [0, 128, 159, 255, 255, 255, 255],
  G: [0, 0, 56, 90, 0, 255, 255],
  B: [0, 0, 41, 70, 0, 0, 255],
  A: [0, 63, 105, 135, 167, 184, 228],
  I: [0, 100, 128, 155, 180, 209, 255]
}, el = {
  min: -590,
  max: 600,
  R: [0, 241, 241, 248, 248, 178, 232, 255, 255],
  G: [0, 156, 156, 222, 222, 36, 51, 255, 255],
  B: [0, 130, 130, 169, 169, 24, 37, 255, 255],
  A: [0, 63, 105, 135, 167, 184, 228, 228, 228],
  I: [0, 1, 52, 127, 137, 162, 172, 252, 255]
}, il = {
  min: 140,
  max: 1024,
  R: [0, 2, 113, 255],
  G: [0, 1, 109, 250],
  B: [0, 1, 101, 245],
  A: [0, 1, 96, 168],
  I: [0, 1, 128, 255]
}, sl = {
  min: -923,
  max: 679,
  R: [0, 0, 0, 0, 0, 255, 255, 255],
  G: [154, 154, 154, 154, 0, 0, 254, 255],
  B: [179, 179, 179, 179, 0, 0, 0, 255],
  A: [0, 3, 8, 0, 0, 10, 15, 20],
  I: [0, 30, 62, 88, 170, 200, 232, 255]
}, rl = {
  min: -10,
  max: 110,
  R: [0, 199, 255],
  G: [0, 127, 255],
  B: [0, 127, 255],
  A: [0, 48, 128],
  I: [0, 124, 255]
}, nl = {
  min: -600,
  max: 100,
  R: [0, 134, 255],
  G: [0, 109, 250],
  B: [0, 101, 245],
  A: [0, 60, 148],
  I: [0, 128, 255]
}, al = {
  min: 114,
  max: 246,
  R: [0, 255, 255],
  G: [0, 128, 255],
  B: [0, 128, 255],
  A: [0, 64, 96],
  I: [0, 87, 255]
}, ol = {
  min: 50,
  max: 1e3,
  R: [98, 210, 169, 128, 255],
  G: [94, 26, 77, 128, 255],
  B: [45, 21, 74, 128, 255],
  A: [0, 25, 0, 4, 168],
  I: [0, 41, 87, 154, 255]
}, ll = {
  R: [
    0,
    13,
    21,
    26,
    27,
    25,
    22,
    21,
    22,
    28,
    39,
    54,
    75,
    98,
    124,
    148,
    171,
    189,
    202,
    210,
    213,
    211,
    206,
    200,
    195,
    193,
    195,
    201,
    211,
    225,
    240,
    255
  ],
  G: [
    0,
    5,
    11,
    20,
    31,
    44,
    58,
    72,
    86,
    99,
    109,
    116,
    120,
    122,
    122,
    122,
    121,
    121,
    124,
    129,
    137,
    147,
    161,
    175,
    190,
    205,
    218,
    229,
    238,
    245,
    251,
    255
  ],
  B: [
    0,
    14,
    30,
    46,
    61,
    71,
    77,
    78,
    75,
    68,
    60,
    52,
    48,
    47,
    53,
    65,
    83,
    105,
    131,
    157,
    183,
    205,
    222,
    235,
    241,
    243,
    242,
    240,
    239,
    240,
    245,
    255
  ],
  A: [
    0,
    4,
    8,
    12,
    17,
    21,
    25,
    29,
    33,
    37,
    41,
    45,
    50,
    54,
    58,
    62,
    66,
    70,
    74,
    78,
    83,
    87,
    91,
    95,
    99,
    103,
    107,
    111,
    116,
    120,
    124,
    128
  ],
  I: [
    0,
    8,
    16,
    25,
    33,
    41,
    49,
    58,
    66,
    74,
    82,
    90,
    99,
    107,
    115,
    123,
    132,
    140,
    148,
    156,
    165,
    173,
    181,
    189,
    197,
    206,
    214,
    222,
    230,
    239,
    247,
    255
  ]
}, cl = {
  R: [0, 10, 136, 255],
  G: [0, 39, 220, 255],
  B: [0, 223, 253, 255],
  A: [0, 48, 64, 70],
  I: [0, 92, 192, 255]
}, hl = {
  R: [
    0,
    245,
    205,
    120,
    196,
    220,
    230,
    0,
    122,
    236,
    12,
    204,
    42,
    119,
    220,
    103,
    60,
    255,
    165,
    160,
    0,
    245,
    205,
    120,
    196,
    220,
    230,
    0,
    122,
    236,
    13,
    220,
    103,
    255,
    165,
    160,
    0,
    120,
    200,
    255,
    255,
    164,
    164,
    164,
    234,
    0,
    0,
    0,
    0,
    0
  ],
  G: [
    0,
    245,
    62,
    18,
    58,
    248,
    148,
    118,
    186,
    13,
    48,
    182,
    204,
    159,
    216,
    255,
    60,
    165,
    42,
    32,
    200,
    245,
    62,
    18,
    58,
    248,
    148,
    118,
    186,
    13,
    48,
    216,
    255,
    165,
    42,
    32,
    200,
    190,
    70,
    148,
    148,
    108,
    108,
    108,
    169,
    0,
    0,
    0,
    0,
    0
  ],
  B: [
    0,
    245,
    78,
    134,
    250,
    164,
    34,
    14,
    220,
    176,
    255,
    142,
    164,
    176,
    20,
    255,
    60,
    0,
    42,
    240,
    200,
    245,
    78,
    134,
    250,
    164,
    34,
    14,
    220,
    176,
    255,
    20,
    255,
    0,
    42,
    240,
    221,
    150,
    255,
    10,
    10,
    226,
    226,
    226,
    30,
    64,
    112,
    160,
    208,
    255
  ],
  A: [
    0,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64
  ],
  I: [
    0,
    2,
    3,
    4,
    5,
    7,
    8,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    24,
    26,
    28,
    30,
    31,
    41,
    42,
    43,
    44,
    46,
    47,
    49,
    50,
    51,
    52,
    53,
    54,
    58,
    60,
    62,
    63,
    72,
    77,
    78,
    79,
    80,
    81,
    82,
    85,
    251,
    252,
    253,
    254,
    255
  ]
}, fl = {
  R: [0, 0, 128, 255, 255],
  G: [0, 128, 0, 128, 255],
  B: [0, 125, 255, 0, 255],
  A: [0, 32, 64, 96, 128],
  I: [0, 63, 128, 192, 255]
}, dl = {
  R: [0, 142, 227, 255],
  G: [0, 85, 170, 255],
  B: [0, 14, 76, 255],
  A: [0, 42, 84, 128],
  I: [0, 85, 170, 255]
}, ul = {
  R: [0, 255],
  G: [0, 255],
  B: [0, 255],
  A: [0, 128],
  I: [0, 255]
}, ml = {
  R: [0, 0, 0],
  G: [0, 128, 255],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 128, 255]
}, gl = {
  R: [0, 0, 0],
  G: [72, 72, 255],
  B: [0, 255, 255],
  A: [0, 64, 128],
  I: [0, 88, 255]
}, pl = {
  R: [0, 255, 255],
  G: [72, 88, 255],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 88, 255]
}, Al = {
  R: [0, 255, 255, 255],
  G: [0, 0, 126, 255],
  B: [0, 0, 0, 255],
  A: [0, 64, 96, 128],
  I: [0, 128, 191, 255]
}, xl = {
  R: [3, 255, 255, 255],
  G: [0, 0, 255, 255],
  B: [0, 0, 0, 255],
  A: [0, 48, 96, 128],
  I: [0, 95, 191, 255]
}, vl = {
  R: [255, 255, 0, 0, 0, 255, 255],
  G: [0, 255, 255, 255, 0, 0, 0],
  B: [0, 0, 0, 255, 255, 255, 0],
  A: [0, 14, 28, 43, 57, 71, 85],
  I: [0, 43, 85, 128, 170, 213, 255]
}, wl = {
  R: [0, 120, 237, 240],
  G: [0, 28, 105, 249],
  B: [4, 109, 37, 33],
  A: [0, 56, 80, 88],
  I: [0, 64, 192, 255]
}, bl = {
  R: [0, 0, 127, 255, 127],
  G: [0, 127, 255, 127, 0],
  B: [127, 255, 127, 0, 0],
  A: [0, 32, 64, 96, 128],
  I: [0, 63, 128, 192, 255]
}, yl = {
  R: [0, 255, 255],
  G: [0, 0, 255],
  B: [0, 0, 0],
  A: [0, 64, 64],
  I: [0, 86, 255]
}, Cl = {
  R: [94, 50, 90, 152, 215, 238, 249, 254, 252, 241, 209, 158],
  G: [79, 131, 186, 214, 240, 244, 237, 210, 157, 100, 57, 1],
  B: [162, 189, 167, 164, 155, 169, 168, 123, 86, 68, 79, 66],
  A: [0, 12, 23, 35, 47, 58, 70, 81, 93, 105, 116, 128],
  I: [0, 23, 46, 70, 93, 116, 139, 162, 185, 209, 232, 255]
}, Fl = {
  R: [3, 7, 13, 25, 45, 67, 84, 98, 110, 124, 138, 154, 173, 191, 210, 225, 233, 233, 231, 229, 230, 235, 243, 253],
  G: [19, 33, 48, 63, 77, 87, 92, 94, 95, 96, 96, 97, 99, 101, 106, 118, 133, 149, 163, 177, 192, 208, 225, 245],
  B: [38, 58, 79, 99, 114, 122, 122, 120, 117, 113, 110, 105, 101, 97, 94, 96, 103, 112, 122, 134, 149, 169, 192, 218],
  A: [0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64],
  I: [0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 133, 144, 155, 166, 177, 188, 199, 210, 221, 232, 243, 255]
}, Ml = {
  R: [0, 148, 183, 223, 247, 252],
  G: [0, 44, 55, 74, 112, 253],
  B: [4, 128, 121, 104, 92, 191],
  A: [0, 44, 53, 64, 75, 107],
  I: [0, 107, 128, 154, 179, 255]
}, El = {
  R: [11, 59, 55, 222],
  G: [4, 45, 165, 245],
  B: [5, 91, 172, 229],
  A: [0, 23, 70, 107],
  I: [0, 56, 167, 255]
}, Dl = {
  R: [3, 5, 6, 8, 12, 19, 28, 36, 42, 48, 54, 61, 68, 76, 86, 96, 110, 129, 154, 181, 205, 224, 239, 252],
  G: [19, 32, 44, 58, 72, 86, 98, 108, 116, 122, 128, 134, 141, 149, 157, 167, 178, 191, 204, 216, 225, 232, 239, 244],
  B: [39, 60, 82, 104, 123, 137, 144, 145, 142, 138, 134, 130, 126, 121, 116, 110, 105, 104, 112, 131, 155, 178, 198, 217],
  A: [0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64],
  I: [0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 133, 144, 155, 166, 177, 188, 199, 210, 221, 232, 243, 255]
}, Sl = {
  R: [0, 85, 0, 0, 0, 0, 0, 0, 85, 255, 255, 255, 172],
  G: [0, 0, 0, 0, 85, 170, 255, 255, 255, 255, 85, 0, 0],
  B: [0, 170, 85, 255, 255, 170, 170, 0, 85, 0, 0, 0, 0],
  A: [0, 5, 10, 21, 26, 32, 37, 42, 48, 53, 64, 72, 85],
  I: [0, 15, 31, 63, 79, 95, 111, 127, 143, 159, 191, 217, 255]
}, Il = {
  R: [13, 156, 237, 240],
  G: [8, 23, 121, 249],
  B: [135, 158, 83, 33],
  A: [0, 56, 80, 88],
  I: [0, 64, 192, 255]
}, Tl = {
  R: [
    208,
    71,
    33,
    192,
    32,
    195,
    208,
    173,
    233,
    202,
    25,
    210,
    145,
    89,
    87,
    245,
    246,
    38,
    3,
    25,
    57,
    167,
    245,
    86,
    227,
    208,
    81,
    64,
    90,
    199,
    140,
    48,
    212,
    180,
    70,
    120,
    9,
    192,
    245,
    177,
    65,
    157,
    9,
    193,
    100,
    181,
    125,
    145,
    62,
    8,
    108,
    36,
    140,
    237,
    242,
    248,
    161,
    189,
    41,
    114,
    65,
    121,
    97,
    50,
    238,
    149,
    44,
    214,
    124,
    167,
    40,
    167,
    127,
    178,
    231,
    30,
    173,
    244,
    193,
    203,
    204,
    238,
    139,
    135,
    71,
    234,
    234,
    217,
    66,
    14,
    129,
    19,
    97,
    165,
    112,
    244,
    35,
    73,
    192,
    12,
    149,
    71,
    33,
    192,
    32,
    195,
    208,
    173,
    233,
    202,
    25,
    210,
    145,
    89,
    87,
    245,
    246,
    38,
    3,
    25,
    57,
    167,
    245,
    86,
    227,
    208,
    81,
    64,
    90,
    199,
    140,
    48,
    212,
    180,
    70,
    120,
    9,
    192,
    245,
    177,
    65,
    157,
    9,
    193,
    100,
    181,
    125,
    145,
    62,
    8,
    108,
    36,
    140,
    237,
    242,
    248,
    161,
    189,
    41,
    114,
    65,
    121,
    97,
    50,
    238,
    149,
    44,
    214,
    124,
    167,
    40,
    167,
    127,
    178,
    231,
    30,
    173,
    244,
    193,
    203,
    204,
    238,
    139,
    135,
    71,
    234,
    234,
    217,
    66,
    14,
    129,
    19,
    97,
    165,
    112,
    244,
    35,
    73,
    192,
    12,
    149,
    71,
    33,
    192,
    32,
    195,
    208,
    173,
    233,
    202,
    25,
    210,
    145,
    89,
    87,
    245,
    246,
    38,
    3,
    25,
    57,
    167,
    245,
    86,
    227,
    208,
    81,
    64,
    90,
    199,
    140,
    48,
    212,
    180,
    70,
    120,
    9,
    192,
    245,
    177,
    65,
    157,
    9,
    193,
    100,
    181,
    125,
    145,
    62,
    8,
    108,
    36,
    140,
    237,
    242,
    248
  ],
  G: [
    182,
    46,
    78,
    199,
    79,
    89,
    41,
    208,
    135,
    20,
    154,
    35,
    21,
    43,
    230,
    113,
    191,
    147,
    208,
    37,
    28,
    27,
    86,
    203,
    25,
    209,
    148,
    187,
    139,
    111,
    48,
    102,
    76,
    110,
    106,
    130,
    37,
    160,
    34,
    222,
    90,
    165,
    245,
    222,
    102,
    47,
    19,
    130,
    4,
    232,
    137,
    211,
    240,
    11,
    140,
    21,
    42,
    22,
    241,
    61,
    99,
    115,
    199,
    166,
    114,
    190,
    204,
    60,
    233,
    66,
    115,
    230,
    125,
    103,
    203,
    125,
    13,
    176,
    94,
    131,
    39,
    198,
    167,
    124,
    67,
    175,
    254,
    1,
    15,
    198,
    62,
    237,
    159,
    31,
    218,
    58,
    244,
    47,
    61,
    67,
    94,
    46,
    78,
    199,
    79,
    89,
    41,
    208,
    135,
    20,
    154,
    35,
    21,
    43,
    230,
    113,
    191,
    147,
    208,
    37,
    28,
    27,
    86,
    203,
    25,
    209,
    148,
    187,
    139,
    111,
    48,
    102,
    76,
    110,
    106,
    130,
    37,
    160,
    34,
    222,
    90,
    165,
    245,
    222,
    102,
    47,
    19,
    130,
    4,
    232,
    137,
    211,
    240,
    11,
    140,
    21,
    42,
    22,
    241,
    61,
    99,
    115,
    199,
    166,
    114,
    190,
    204,
    60,
    233,
    66,
    115,
    230,
    125,
    103,
    203,
    125,
    13,
    176,
    94,
    131,
    39,
    198,
    167,
    124,
    67,
    175,
    254,
    1,
    15,
    198,
    62,
    237,
    159,
    31,
    218,
    58,
    244,
    47,
    61,
    67,
    94,
    46,
    78,
    199,
    79,
    89,
    41,
    208,
    135,
    20,
    154,
    35,
    21,
    43,
    230,
    113,
    191,
    147,
    208,
    37,
    28,
    27,
    86,
    203,
    25,
    209,
    148,
    187,
    139,
    111,
    48,
    102,
    76,
    110,
    106,
    130,
    37,
    160,
    34,
    222,
    90,
    165,
    245,
    222,
    102,
    47,
    19,
    130,
    4,
    232,
    137,
    211,
    240,
    11,
    140,
    21
  ],
  B: [
    191,
    154,
    43,
    10,
    207,
    204,
    164,
    231,
    136,
    58,
    239,
    30,
    147,
    230,
    101,
    111,
    150,
    35,
    128,
    57,
    252,
    79,
    173,
    120,
    25,
    126,
    81,
    85,
    8,
    7,
    122,
    237,
    190,
    152,
    246,
    182,
    130,
    219,
    67,
    76,
    167,
    178,
    235,
    250,
    28,
    61,
    186,
    250,
    199,
    67,
    58,
    50,
    86,
    182,
    108,
    77,
    89,
    112,
    59,
    125,
    226,
    50,
    205,
    227,
    125,
    128,
    104,
    27,
    59,
    66,
    53,
    133,
    159,
    203,
    97,
    125,
    139,
    159,
    158,
    7,
    215,
    47,
    140,
    226,
    223,
    231,
    44,
    110,
    184,
    61,
    233,
    47,
    67,
    148,
    22,
    120,
    173,
    156,
    117,
    181,
    94,
    154,
    43,
    10,
    207,
    204,
    164,
    231,
    136,
    58,
    239,
    30,
    147,
    230,
    101,
    111,
    150,
    35,
    128,
    57,
    252,
    79,
    173,
    120,
    25,
    126,
    81,
    85,
    8,
    7,
    122,
    237,
    190,
    152,
    246,
    182,
    130,
    219,
    67,
    76,
    167,
    178,
    235,
    250,
    28,
    61,
    186,
    250,
    199,
    67,
    58,
    50,
    86,
    182,
    108,
    77,
    89,
    112,
    59,
    125,
    226,
    50,
    205,
    227,
    125,
    128,
    104,
    27,
    59,
    66,
    53,
    133,
    159,
    203,
    97,
    125,
    139,
    159,
    158,
    7,
    215,
    47,
    140,
    226,
    223,
    231,
    44,
    110,
    184,
    61,
    233,
    47,
    67,
    148,
    22,
    120,
    173,
    156,
    117,
    181,
    94,
    154,
    43,
    10,
    207,
    204,
    164,
    231,
    136,
    58,
    239,
    30,
    147,
    230,
    101,
    111,
    150,
    35,
    128,
    57,
    252,
    79,
    173,
    120,
    25,
    126,
    81,
    85,
    8,
    7,
    122,
    237,
    190,
    152,
    246,
    182,
    130,
    219,
    67,
    76,
    167,
    178,
    235,
    250,
    28,
    61,
    186,
    250,
    199,
    67,
    58,
    50,
    86,
    182,
    108,
    77
  ],
  A: [
    0,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ]
}, Vl = {
  R: [0, 128, 255],
  G: [0, 0, 0],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 128, 255]
}, Bl = {
  R: [192, 224, 255],
  G: [1, 128, 255],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 128, 255]
}, Ul = {
  R: [3, 112, 144, 188, 236, 246, 255],
  G: [5, 31, 29, 22, 76, 158, 250],
  B: [26, 87, 91, 86, 62, 117, 235],
  A: [0, 30, 38, 49, 67, 85, 107],
  I: [0, 73, 92, 118, 160, 205, 255]
}, Rl = {
  R: [1, 240, 255],
  G: [1, 128, 255],
  B: [1, 128, 255],
  A: [0, 76, 128],
  I: [0, 153, 255]
}, Pl = {
  R: [0, 5, 18, 34, 53, 72, 90, 107, 126, 144, 161, 178, 194, 209, 222, 233, 242, 248, 251, 251, 249, 244, 241, 252],
  G: [0, 4, 10, 11, 9, 11, 17, 23, 30, 36, 43, 50, 59, 70, 83, 98, 117, 136, 157, 177, 199, 220, 240, 254],
  B: [3, 24, 50, 76, 96, 106, 109, 110, 108, 104, 97, 89, 79, 67, 55, 42, 26, 12, 6, 22, 47, 79, 121, 164],
  A: [0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64],
  I: [0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 133, 144, 155, 166, 177, 188, 199, 210, 221, 232, 243, 255]
}, Nl = {
  R: [48, 48, 64, 70, 65, 25, 132, 195, 244, 254, 218, 122],
  G: [18, 18, 64, 107, 150, 226, 255, 241, 199, 158, 57, 4],
  B: [59, 59, 162, 227, 255, 187, 81, 52, 58, 47, 7, 3],
  A: [0, 22, 26, 30, 34, 43, 52, 57, 63, 67, 77, 86],
  I: [0, 1, 16, 32, 49, 83, 118, 140, 164, 181, 219, 255]
}, Ll = {
  R: [0, 128, 255],
  G: [0, 0, 0],
  B: [0, 128, 255],
  A: [0, 64, 128],
  I: [0, 128, 255]
}, kl = {
  R: [68, 49, 53, 253],
  G: [1, 104, 183, 231],
  B: [84, 142, 121, 37],
  A: [0, 56, 80, 88],
  I: [0, 64, 192, 255]
}, Ol = {
  R: [255, 255, 255],
  G: [127, 196, 254],
  B: [0, 0, 0],
  A: [0, 64, 128],
  I: [0, 128, 255]
}, zl = {
  R: [0, 0, 0],
  G: [0, 128, 255],
  B: [255, 196, 128],
  A: [0, 64, 128],
  I: [0, 128, 255]
}, Gl = {
  R: [3, 64, 0, 0, 255, 255, 255],
  G: [0, 0, 0, 255, 255, 192, 3],
  B: [0, 32, 48, 56, 64, 96, 128],
  A: [0, 8, 16, 24, 32, 52, 80],
  I: [0, 32, 64, 96, 160, 192, 255]
}, Yl = {
  min: 0,
  max: 0,
  R: [0, 37],
  G: [242, 0],
  B: [255, 255],
  A: [0, 64],
  I: [0, 255]
}, Wl = {
  R: [255, 255],
  G: [255, 11],
  B: [0, 0],
  A: [0, 64],
  I: [0, 255]
}, Kl = {
  min: 0,
  max: 0,
  R: [
    65,
    10,
    223,
    120,
    216,
    207,
    251,
    93,
    252,
    217,
    21,
    253,
    131,
    165,
    173,
    143,
    144,
    217,
    86,
    89,
    63,
    254,
    172,
    1,
    142,
    107,
    42,
    78,
    221,
    8,
    222,
    71,
    127,
    126,
    167,
    33,
    104,
    2,
    208,
    216,
    0,
    251,
    7,
    105,
    2,
    101,
    248,
    190,
    253,
    62,
    255,
    224,
    166,
    37,
    110,
    138,
    45,
    34,
    6,
    37,
    69,
    201,
    43,
    122,
    199,
    37,
    173,
    194,
    103,
    211,
    75,
    159,
    96,
    4,
    239,
    98,
    110,
    193,
    253,
    166,
    40,
    255,
    48,
    130,
    140,
    243,
    101,
    9,
    177,
    220,
    133,
    32,
    4,
    81,
    48,
    48,
    210,
    109,
    60,
    132,
    1,
    119,
    1,
    159,
    247,
    33,
    212,
    187,
    253,
    144,
    196,
    254,
    168,
    79,
    64,
    196,
    39,
    97,
    73,
    173,
    104,
    216,
    217,
    43,
    101,
    119,
    254,
    5,
    237,
    103,
    203,
    122,
    57,
    87,
    251,
    164,
    19,
    75,
    200,
    2,
    252,
    150,
    66,
    0,
    255,
    157,
    23,
    254,
    55,
    16,
    240,
    161,
    69,
    253,
    207,
    195,
    5,
    60,
    255,
    251,
    200,
    217,
    134,
    123,
    253,
    180,
    27,
    246,
    130,
    136,
    250,
    232,
    4,
    125,
    140,
    22,
    253,
    255,
    13,
    180,
    123,
    61,
    254,
    111,
    10,
    185,
    76,
    192,
    255,
    223,
    186,
    61,
    198,
    5,
    172,
    13,
    83,
    172,
    171,
    6,
    23,
    73,
    134,
    133,
    109,
    61,
    213,
    55,
    57,
    132,
    36,
    209,
    2,
    144,
    1,
    253,
    68,
    155,
    3,
    160,
    2,
    77,
    121,
    70,
    67,
    176,
    223,
    131,
    4,
    162,
    232,
    255,
    150,
    94,
    235,
    191,
    207,
    10,
    246,
    0,
    225,
    4,
    209,
    116,
    57,
    112,
    172,
    253,
    1,
    6,
    92,
    227,
    73,
    62,
    135,
    223
  ],
  G: [
    162,
    50,
    112,
    245,
    4,
    124,
    176,
    243,
    56,
    125,
    183,
    139,
    182,
    68,
    189,
    4,
    225,
    10,
    20,
    223,
    7,
    46,
    31,
    193,
    225,
    250,
    219,
    41,
    2,
    100,
    83,
    181,
    34,
    150,
    72,
    223,
    168,
    248,
    80,
    253,
    7,
    117,
    214,
    2,
    248,
    10,
    3,
    59,
    179,
    160,
    90,
    244,
    146,
    4,
    207,
    4,
    125,
    255,
    96,
    100,
    1,
    208,
    130,
    51,
    116,
    181,
    236,
    53,
    244,
    5,
    165,
    28,
    181,
    86,
    96,
    42,
    254,
    1,
    134,
    194,
    214,
    92,
    41,
    204,
    137,
    86,
    207,
    3,
    143,
    3,
    100,
    239,
    164,
    94,
    65,
    251,
    131,
    244,
    173,
    57,
    143,
    107,
    217,
    53,
    210,
    0,
    148,
    250,
    45,
    198,
    81,
    40,
    61,
    218,
    252,
    88,
    171,
    0,
    248,
    24,
    248,
    4,
    41,
    100,
    187,
    46,
    208,
    145,
    43,
    168,
    121,
    46,
    175,
    250,
    125,
    107,
    233,
    112,
    207,
    231,
    174,
    215,
    53,
    9,
    43,
    153,
    52,
    124,
    128,
    65,
    210,
    147,
    255,
    147,
    63,
    200,
    148,
    254,
    0,
    179,
    241,
    42,
    239,
    2,
    230,
    8,
    82,
    135,
    87,
    16,
    3,
    87,
    86,
    151,
    254,
    8,
    255,
    86,
    53,
    19,
    7,
    192,
    171,
    201,
    253,
    247,
    197,
    103,
    251,
    126,
    0,
    149,
    54,
    183,
    61,
    126,
    79,
    113,
    10,
    103,
    184,
    75,
    11,
    195,
    222,
    136,
    149,
    131,
    8,
    99,
    240,
    177,
    252,
    255,
    198,
    16,
    7,
    68,
    178,
    66,
    191,
    150,
    73,
    26,
    211,
    109,
    78,
    209,
    240,
    254,
    1,
    166,
    247,
    131,
    2,
    0,
    167,
    127,
    133,
    10,
    43,
    99,
    235,
    3,
    214,
    142,
    176,
    82,
    132,
    38,
    10,
    249,
    255,
    215,
    44,
    81
  ],
  B: [
    176,
    182,
    248,
    37,
    117,
    35,
    96,
    69,
    32,
    152,
    108,
    20,
    237,
    250,
    2,
    89,
    141,
    216,
    111,
    251,
    211,
    149,
    10,
    44,
    214,
    103,
    31,
    251,
    3,
    32,
    252,
    246,
    97,
    1,
    219,
    167,
    197,
    4,
    36,
    116,
    206,
    118,
    106,
    43,
    205,
    204,
    114,
    69,
    127,
    205,
    87,
    80,
    41,
    251,
    145,
    204,
    253,
    161,
    247,
    1,
    149,
    9,
    43,
    253,
    97,
    72,
    136,
    161,
    171,
    181,
    26,
    255,
    108,
    80,
    218,
    214,
    231,
    255,
    84,
    31,
    109,
    4,
    218,
    3,
    217,
    36,
    68,
    85,
    241,
    39,
    221,
    2,
    240,
    2,
    173,
    42,
    206,
    5,
    110,
    46,
    103,
    27,
    212,
    184,
    2,
    207,
    246,
    45,
    116,
    72,
    110,
    253,
    38,
    105,
    248,
    159,
    243,
    81,
    192,
    93,
    141,
    145,
    24,
    157,
    234,
    131,
    57,
    178,
    62,
    75,
    65,
    176,
    148,
    40,
    253,
    66,
    76,
    240,
    51,
    154,
    17,
    251,
    139,
    253,
    207,
    9,
    114,
    49,
    200,
    254,
    96,
    73,
    138,
    118,
    204,
    102,
    137,
    89,
    145,
    161,
    4,
    112,
    66,
    234,
    147,
    178,
    212,
    205,
    185,
    11,
    203,
    131,
    2,
    250,
    118,
    169,
    1,
    185,
    154,
    53,
    171,
    197,
    61,
    175,
    249,
    96,
    15,
    254,
    95,
    5,
    222,
    75,
    246,
    194,
    2,
    61,
    180,
    25,
    133,
    165,
    15,
    233,
    59,
    35,
    221,
    140,
    109,
    7,
    114,
    255,
    198,
    0,
    115,
    168,
    252,
    23,
    242,
    80,
    75,
    142,
    137,
    255,
    12,
    182,
    68,
    201,
    4,
    111,
    37,
    228,
    83,
    248,
    24,
    192,
    249,
    5,
    54,
    223,
    160,
    122,
    160,
    114,
    145,
    119,
    252,
    31,
    253,
    250,
    10,
    214,
    8,
    47,
    0,
    142,
    222,
    70
  ],
  A: [
    0,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64,
    64
  ],
  I: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ]
}, Xl = class {
  /**
   * Sets cluts to alphabetically sorted cmaps
   */
  constructor() {
    I(this, "gamma", 1), I(this, "version", 0.1), I(this, "cluts", {});
    const t = Object.keys(xi).filter((i) => !i.startsWith("$")).sort(new Intl.Collator("en").compare);
    for (const i of t)
      this.cluts[i] = xi[i];
  }
  addColormap(e, t) {
    this.cluts[e] = t;
  }
  colormaps() {
    return Object.keys(this.cluts);
  }
  // for backward compatibility: prior to v0.34 "colormaps" used to be "colorMaps"
  colorMaps() {
    return this.colormaps();
  }
  // returns key name if it exists, otherwise returns default "gray"
  colormapFromKey(e) {
    let t = this.cluts[e];
    return t !== void 0 || (t = this.cluts[e.toLowerCase()], t !== void 0) ? t : (e.length > 0 && V.warn("No color map named " + e), {
      min: 0,
      max: 0,
      R: [0, 255],
      G: [0, 255],
      B: [0, 255],
      A: [0, 255],
      I: [0, 255]
    });
  }
  // not included in public docs
  colormap(e = "", t = !1) {
    const i = this.colormapFromKey(e);
    return this.makeLut(i.R, i.G, i.B, i.A, i.I, t);
  }
  makeLabelLut(e, t = 255, i = 1 / 0) {
    if (e.R === void 0 || e.G === void 0 || e.B === void 0)
      throw new Error(`Invalid colormap table: ${e}`);
    const s = e.R.length, r = e.I ?? [...Array(s).keys()];
    let a = !1;
    for (let d = 0; d < r.length; d++)
      r[d] > i && (a = !0, r[d] = i);
    if (a && V.warn("Some colormap indices clamped to match label range."), s !== e.G.length || s !== e.B.length || s !== r.length)
      throw new Error(
        `colormap does not make sense: ${e} Rs ${e.R.length} Gs ${e.G.length} Bs ${e.B.length} Is ${r.length}`
      );
    let n = new Uint8ClampedArray(s).fill(t);
    n[0] = 0, e.A !== void 0 && (n = Uint8ClampedArray.from(e.A));
    const o = Math.min(...r), l = Math.max(...r), c = l - o + 1, h = new Uint8ClampedArray(c * 4).fill(0);
    for (let d = 0; d < s; d++) {
      let u = (r[d] - o) * 4;
      h[u++] = e.R[d], h[u++] = e.G[d], h[u++] = e.B[d], h[u++] = n[d];
    }
    const f = {
      lut: h,
      min: o,
      max: l
    };
    if (e.labels) {
      const d = e.labels.length;
      if (d === c)
        f.labels = e.labels;
      else if (d === s) {
        f.labels = Array(c).fill("?");
        for (let u = 0; u < s; u++) {
          const m = r[u];
          f.labels[m] = e.labels[u];
        }
      }
    }
    return f;
  }
  async makeLabelLutFromUrl(e, t = 255, i = 1 / 0) {
    const r = await (await fetch(e)).json();
    return this.makeLabelLut(r, t, i);
  }
  // not included in public docs
  // The drawing colormap is a variant of the label colormap with precisely 256 colors
  makeDrawLut(e) {
    let t = typeof e == "object" ? e : xi[e];
    t === void 0 && (V.warn("colormap undefined ", e), t = this.colormapFromKey(""));
    const i = this.makeLabelLut(t, 255);
    if (i.labels === void 0 && (i.labels = []), i.labels.length < 256) {
      const n = i.labels.length;
      for (let o = n; o < 256; o++)
        i.labels.push(o.toString());
    }
    const s = new Uint8ClampedArray(256 * 4);
    let r = 0;
    for (let n = 0; n < 256; n++)
      s[r++] = 255, s[r++] = 0, s[r++] = 0, s[r++] = 255;
    s[3] = 0;
    const a = Math.min(i.lut.length, 256 * 4);
    if (a > 0)
      for (let n = 0; n < a; n++)
        s[n] = i.lut[n];
    return {
      lut: s,
      labels: i.labels
    };
  }
  // not included in public docs
  makeLut(e, t, i, s, r, a) {
    const n = e.length, o = [...e], l = [...t], c = [...i];
    if (!r) {
      r = new Array(n);
      for (let u = 0; u < n; u++)
        r[u] = u / (n - 1) * 255;
    }
    s || (s = new Array(n).fill(64), s[0] = 0);
    let h = Uint8ClampedArray.from(s), f = Uint8ClampedArray.from(r);
    if (a)
      for (let u = 0; u < n; u++)
        o[u] = e[n - 1 - u], l[u] = t[n - 1 - u], c[u] = i[n - 1 - u], h[u] = 255 - s[n - 1 - u], f[u] = 255 - r[n - 1 - u];
    const d = new Uint8ClampedArray(256 * 4);
    if (typeof f > "u") {
      f = new Uint8ClampedArray(n).fill(0);
      for (let u = 0; u < n; u++)
        f[u] = Math.round(u * 255 / (n - 1));
    }
    typeof h > "u" && (h = new Uint8ClampedArray(n).fill(64), h[0] = 0);
    for (let u = 0; u < n - 1; u++) {
      const m = f[u];
      let g = f[u + 1];
      u === 0 && m !== 0 && V.warn("colormap issue: indices expected to start with 0 not ", m), u === f.length - 2 && g !== 255 && (V.warn("padding colormap: indices expected end with 255 not ", g), g = 255);
      const p = g - m;
      let A = m * 4;
      for (let x = m; x <= g; x++) {
        const w = (x - m) / p;
        d[A++] = o[u] + w * (o[u + 1] - o[u]), d[A++] = l[u] + w * (l[u + 1] - l[u]), d[A++] = c[u] + w * (c[u + 1] - c[u]), d[A++] = h[u] + w * (h[u + 1] - h[u]);
      }
    }
    if (this.gamma === 1)
      return d;
    for (let u = 0; u < 255 * 4; u++)
      u % 4 !== 3 && (d[u] = Math.pow(d[u] / 255, 1 / this.gamma) * 255);
    return d;
  }
}, rt = new Xl(), ne = class {
  static getClusterBoundaryU8(e, t) {
    const i = new Array(e.length).fill(!1), s = new Array(e.length).fill(!1);
    for (let n = 0; n < e.length; n++)
      e[n] > 0 && (s[n] = !0);
    const r = t.length / 3;
    let a = 0;
    for (let n = 0; n < r; n++) {
      const o = t[a], l = t[a + 1], c = t[a + 2];
      a += 3, !(s[o] === s[l] && s[o] === s[c] && s[l] === s[c]) && (i[o] = !0, i[l] = !0, i[c] = !0);
    }
    return i;
  }
  static async gzip(e) {
    const t = new CompressionStream("gzip"), i = t.writable.getWriter();
    i.write(e).catch(console.error);
    const s = i.close().catch(console.error), r = new Response(t.readable), a = new Uint8Array(await r.arrayBuffer());
    return await s, a;
  }
  static createMZ3(e, t, i = !1, s = null) {
    const a = s instanceof Uint8Array && s.length === e.length / 3 * 4, n = a ? 7 : 3, o = t.length / 3, l = e.length / 3, c = 0, h = 16, f = o * 3 * 4, d = l * 3 * 4, u = a ? s.length : 0, m = h + f + d + u, g = new ArrayBuffer(m), p = new DataView(g);
    p.setUint16(0, 23117, !0), p.setUint16(2, n, !0), p.setUint32(4, o, !0), p.setUint32(8, l, !0), p.setUint32(12, c, !0);
    let A = h;
    if (new Uint32Array(g, A, t.length).set(t), A += f, new Float32Array(g, A, e.length).set(e), a && (A += d, new Uint8Array(g, A, s.length).set(s)), i)
      throw new Error("Call async createMZ3Async() for compression");
    return g;
  }
  static async createMZ3Async(e, t, i = !1, s = null) {
    const r = this.createMZ3(e, t, i, s);
    return i ? await this.gzip(new Uint8Array(r)) : r;
  }
  static createOBJ(e, t) {
    let i = "";
    for (let a = 0; a < e.length; a += 3)
      i += `v ${e[a]} ${e[a + 1]} ${e[a + 2]}
`;
    for (let a = 0; a < t.length; a += 3)
      i += `f ${t[a] + 1} ${t[a + 1] + 1} ${t[a + 2] + 1}
`;
    return new TextEncoder().encode(i).buffer;
  }
  static createSTL(e, t) {
    const i = t.length / 3, s = 84 + i * 50, r = new ArrayBuffer(s), a = new DataView(r);
    for (let o = 0; o < 80; o++)
      a.setUint8(o, 0);
    a.setUint32(80, i, !0);
    let n = 84;
    for (let o = 0; o < t.length; o += 3) {
      const l = t[o] * 3, c = t[o + 1] * 3, h = t[o + 2] * 3;
      a.setFloat32(n, 0, !0), a.setFloat32(n + 4, 0, !0), a.setFloat32(n + 8, 0, !0), n += 12, a.setFloat32(n, e[l], !0), a.setFloat32(n + 4, e[l + 1], !0), a.setFloat32(n + 8, e[l + 2], !0), n += 12, a.setFloat32(n, e[c], !0), a.setFloat32(n + 4, e[c + 1], !0), a.setFloat32(n + 8, e[c + 2], !0), n += 12, a.setFloat32(n, e[h], !0), a.setFloat32(n + 4, e[h + 1], !0), a.setFloat32(n + 8, e[h + 2], !0), n += 12, a.setUint16(n, 0, !0), n += 2;
    }
    return r;
  }
  static downloadArrayBuffer(e, t) {
    const i = new Blob([e], { type: "application/octet-stream" }), s = URL.createObjectURL(i), r = document.createElement("a");
    r.href = s, r.download = t, document.body.appendChild(r), r.style.display = "none", r.click(), setTimeout(() => {
      document.body.removeChild(r), URL.revokeObjectURL(s);
    }, 0);
  }
  static async saveMesh(e, t, i = ".mz3", s = !1) {
    let r = new ArrayBuffer(0);
    return /\.obj$/i.test(i) ? r = this.createOBJ(e, t) : /\.stl$/i.test(i) ? r = this.createSTL(e, t) : (/\.mz3$/i.test(i) || (i += ".mz3"), r = await this.createMZ3Async(e, t, s)), i.length > 4 && this.downloadArrayBuffer(r, i), r;
  }
  static getClusterBoundary(e, t) {
    const i = new Uint32Array(e.buffer), s = new Array(i.length).fill(!1), r = t.length / 3;
    let a = 0;
    for (let n = 0; n < r; n++) {
      const o = t[a], l = t[a + 1], c = t[a + 2];
      a += 3, !(i[o] === i[l] && i[o] === i[c] && i[l] === i[c]) && (s[o] = !0, s[l] = !0, s[c] = !0);
    }
    return s;
  }
  // return spatial extremes for vertices
  static getExtents(e) {
    if (!ArrayBuffer.isView(e) && !Array.isArray(e) || e.length < 3)
      return { mxDx: 0, extentsMin: 0, extentsMax: 0 };
    let t = 0;
    const i = O(e[0], e[1], e[2]), s = O(e[0], e[1], e[2]);
    for (let n = 0; n < e.length; n += 3) {
      const o = O(e[n], e[n + 1], e[n + 2]);
      t = Math.max(t, Le(o)), hs(i, i, o), fs(s, s, o);
    }
    const r = [i[0], i[1], i[2]], a = [s[0], s[1], s[2]];
    return { mxDx: t, extentsMin: r, extentsMax: a };
  }
  // determine vector orthogonal to plane defined by triangle
  // triangle winding determines front/back face
  static generateNormals(e, t) {
    const i = [];
    let s;
    const r = e.length;
    let a, n, o, l, c, h, f, d, u;
    const m = new Float32Array(r), g = t.length;
    for (s = 0; s < g; s += 3) {
      f = t[s] * 3, d = t[s + 1] * 3, u = t[s + 2] * 3;
      const p = [e[f], e[f + 1], e[f + 2]], A = [e[d], e[d + 1], e[d + 2]], x = [e[u], e[u + 1], e[u + 2]];
      a = A[0] - p[0], n = A[1] - p[1], o = A[2] - p[2], l = x[0] - p[0], c = x[1] - p[1], h = x[2] - p[2], i[0] = c * o - h * n, i[1] = h * a - l * o, i[2] = l * n - c * a, m[f] += i[0], m[f + 1] += i[1], m[f + 2] += i[2], m[d] += i[0], m[d + 1] += i[1], m[d + 2] += i[2], m[u] += i[0], m[u + 1] += i[1], m[u + 2] += i[2];
    }
    for (s = 0; s < r; s += 3) {
      i[0] = -1 * m[s], i[1] = -1 * m[s + 1], i[2] = -1 * m[s + 2];
      let p = i[0] * i[0] + i[1] * i[1] + i[2] * i[2];
      p > 0 && (p = 1 / Math.sqrt(p), i[0] *= p, i[1] *= p, i[2] *= p), m[s] = i[0], m[s + 1] = i[1], m[s + 2] = i[2];
    }
    return m;
  }
}, Q, It, vi, os, Ve, sn = class {
  constructor(e) {
    ge(this, Q), ge(this, It, 0), ge(this, vi, []), ge(this, os, []), ge(this, Ve), _t(this, Q, new DataView(e)), this.read();
  }
  async extract(e) {
    const t = new Uint8Array(X(this, Q).buffer.slice(e.startsAt, e.startsAt + e.compressedSize));
    if (e.compressionMethod === 0)
      return t;
    if (e.compressionMethod === 8) {
      const i = new DecompressionStream("deflate-raw"), s = i.writable.getWriter();
      s.write(t).catch(console.error);
      const r = s.close().catch(console.error), a = new Response(i.readable), n = new Uint8Array(await a.arrayBuffer());
      return await r, n;
    }
    throw new Error(`Unsupported compression method: ${e.compressionMethod}`);
  }
  read() {
    for (; !X(this, Ve) && X(this, It) < X(this, Q).byteLength; ) {
      const e = X(this, Q).getUint32(X(this, It), !0);
      if (e === 67324752) {
        const t = this.readLocalFile(X(this, It));
        t.extract = this.extract.bind(this, t), X(this, vi).push(t);
        const i = (t.generalPurpose & 8) !== 0;
        if (t.startsAt = X(this, It) + 30 + t.fileNameLength + t.extraLength, t.compressedSize === 0 && i) {
          let s = t.startsAt;
          for (; s + 20 <= X(this, Q).byteLength; ) {
            if (X(this, Q).getUint32(s, !0) === 134695760 && X(this, Q).getUint16(s + 16, !0) === 19280) {
              s += 4;
              break;
            }
            s++;
          }
          t.crc = X(this, Q).getUint32(s, !0), t.compressedSize = X(this, Q).getUint32(s + 4, !0), t.uncompressedSize = X(this, Q).getUint32(s + 8, !0), _t(this, It, s + 12);
        } else
          _t(this, It, t.startsAt + t.compressedSize);
      } else if (e === 33639248) {
        const t = this.readCentralDirectory(X(this, It));
        X(this, os).push(t), _t(this, It, X(this, It) + (46 + t.fileNameLength + t.extraLength + t.fileCommentLength));
      } else if (e === 101010256) {
        _t(this, Ve, this.readEndCentralDirectory(X(this, It)));
        break;
      } else if (e === 101075792) {
        _t(this, Ve, this.readEndCentralDirectory64(X(this, It)));
        break;
      } else {
        console.error(`Unexpected ZIP signature 0x${e.toString(16).padStart(8, "0")} at index ${X(this, It)}`);
        break;
      }
    }
  }
  readLocalFile(e) {
    let t = X(this, Q).getUint32(e + 18, !0), i = X(this, Q).getUint32(e + 22, !0);
    const s = X(this, Q).getUint16(e + 26, !0), r = X(this, Q).getUint16(e + 28, !0), a = e + 30 + s;
    if (this.readString(a, r), t === 4294967295 && i === 4294967295) {
      let n = a, o = !1;
      for (; n < a + r - 4; ) {
        const l = X(this, Q).getUint16(n, !0), c = X(this, Q).getUint16(n + 2, !0);
        if (n += 4, l === 1)
          if (c >= 16) {
            i = Number(X(this, Q).getBigUint64(n, !0)), n += 8, t = Number(X(this, Q).getBigUint64(n, !0)), o = !0;
            break;
          } else
            throw new Error(
              `ZIP64 extra field found but is too small (expected at least 16 bytes, got ${c}).`
            );
        n += c;
      }
      if (!o)
        throw new Error("ZIP64 format missing extra field with signature 0x0001.");
    }
    return {
      signature: this.readString(e, 4),
      version: X(this, Q).getUint16(e + 4, !0),
      generalPurpose: X(this, Q).getUint16(e + 6, !0),
      compressionMethod: X(this, Q).getUint16(e + 8, !0),
      lastModifiedTime: X(this, Q).getUint16(e + 10, !0),
      lastModifiedDate: X(this, Q).getUint16(e + 12, !0),
      crc: X(this, Q).getUint32(e + 14, !0),
      compressedSize: t,
      uncompressedSize: i,
      fileNameLength: s,
      extraLength: r,
      fileName: this.readString(e + 30, s),
      extra: this.readString(e + 30 + s, r)
    };
  }
  readCentralDirectory(e) {
    return {
      versionCreated: X(this, Q).getUint16(e + 4, !0),
      versionNeeded: X(this, Q).getUint16(e + 6, !0),
      fileNameLength: X(this, Q).getUint16(e + 28, !0),
      extraLength: X(this, Q).getUint16(e + 30, !0),
      fileCommentLength: X(this, Q).getUint16(e + 32, !0),
      diskNumber: X(this, Q).getUint16(e + 34, !0),
      internalAttributes: X(this, Q).getUint16(e + 36, !0),
      externalAttributes: X(this, Q).getUint32(e + 38, !0),
      offset: X(this, Q).getUint32(e + 42, !0),
      comments: this.readString(e + 46, X(this, Q).getUint16(e + 32, !0))
    };
  }
  readEndCentralDirectory(e) {
    const t = X(this, Q).getUint16(e + 20, !0);
    return {
      numberOfDisks: X(this, Q).getUint16(e + 4, !0),
      centralDirectoryStartDisk: X(this, Q).getUint16(e + 6, !0),
      numberCentralDirectoryRecordsOnThisDisk: X(this, Q).getUint16(e + 8, !0),
      numberCentralDirectoryRecords: X(this, Q).getUint16(e + 10, !0),
      centralDirectorySize: X(this, Q).getUint32(e + 12, !0),
      centralDirectoryOffset: X(this, Q).getUint32(e + 16, !0),
      commentLength: t,
      comment: this.readString(e + 22, t)
    };
  }
  readEndCentralDirectory64(e) {
    const t = Number(X(this, Q).getBigUint64(e + 0, !0));
    return {
      numberOfDisks: X(this, Q).getUint32(e + 16, !0),
      centralDirectoryStartDisk: X(this, Q).getUint32(e + 20, !0),
      numberCentralDirectoryRecordsOnThisDisk: Number(X(this, Q).getBigUint64(e + 24, !0)),
      numberCentralDirectoryRecords: Number(X(this, Q).getBigUint64(e + 32, !0)),
      centralDirectorySize: Number(X(this, Q).getBigUint64(e + 40, !0)),
      centralDirectoryOffset: Number(X(this, Q).getBigUint64(e + 48, !0)),
      commentLength: t,
      comment: ""
    };
  }
  readString(e, t) {
    return Array.from({ length: t }, (i, s) => String.fromCharCode(X(this, Q).getUint8(e + s))).join("");
  }
  get entries() {
    return X(this, vi);
  }
};
Q = /* @__PURE__ */ new WeakMap();
It = /* @__PURE__ */ new WeakMap();
vi = /* @__PURE__ */ new WeakMap();
os = /* @__PURE__ */ new WeakMap();
Ve = /* @__PURE__ */ new WeakMap();
var H = class pe {
  static arrayBufferToBase64(t) {
    const i = new Uint8Array(t);
    return pe.uint8tob64(i);
  }
  static async decompress(t) {
    const i = t[0] === 31 && t[1] === 139 && t[2] === 8 ? "gzip" : t[0] === 120 && (t[1] === 1 || t[1] === 94 || t[1] === 156 || t[1] === 218) ? "deflate" : "deflate-raw", s = new DecompressionStream(i), r = s.writable.getWriter();
    r.write(t).catch(console.error);
    const a = r.close().catch(console.error), n = new Response(s.readable), o = new Uint8Array(await n.arrayBuffer());
    return await a, o;
  }
  static async decompressToBuffer(t) {
    const i = await pe.decompress(t);
    return i.buffer.slice(i.byteOffset, i.byteOffset + i.byteLength);
  }
  static async readMatV4(t, i = !1) {
    let s = t.byteLength;
    if (s < 40)
      throw new Error("File too small to be MAT v4: bytes = " + t.byteLength);
    let r = new DataView(t), a = r.getUint16(0, !0), n = t;
    if (a === 35615 || a === 8075) {
      const m = await this.decompress(new Uint8Array(t));
      r = new DataView(m.buffer), a = r.getUint16(0, !0), n = m.buffer, s = n.byteLength;
    }
    const o = new TextDecoder("utf-8"), l = new Uint8Array(n);
    let c = 0;
    const h = {};
    function f(m) {
      return Math.floor(m / 10) % 10;
    }
    function d(m, g, p) {
      const A = new Uint8Array(l.subarray(g, p));
      return m === 1 ? new Float32Array(A.buffer) : m === 2 ? new Int32Array(A.buffer) : m === 3 ? new Int16Array(A.buffer) : m === 4 ? new Uint16Array(A.buffer) : m === 5 ? new Uint8Array(A.buffer) : new Float64Array(A.buffer);
    }
    function u() {
      const m = r.getUint32(c, !0), g = r.getUint32(c + 4, !0), p = r.getUint32(c + 8, !0), A = r.getUint32(c + 12, !0), x = r.getUint32(c + 16, !0);
      if (c += 20, A !== 0)
        throw new Error("Matlab V4 reader does not support imaginary numbers");
      const w = g * p;
      if (w < 1)
        throw new Error("mrows * ncols must be greater than one");
      const v = new Uint8Array(l.subarray(c, c + x));
      let F = o.decode(v).trim().replaceAll("\0", "");
      i && (F = F.replaceAll(".", "_"));
      const C = f(m);
      let b = 8;
      if (C >= 1 && C <= 2)
        b = 4;
      else if (C >= 3 && C <= 4)
        b = 2;
      else if (C === 5)
        b = 1;
      else if (C !== 0)
        throw new Error("impossible Matlab v4 datatype");
      if (c += x, m > 50)
        throw new Error("Does not appear to be little-endian V4 Matlab file");
      const y = c + w * b;
      h[F] = d(C, c, y), c = y;
    }
    for (; c + 20 < s; )
      u();
    return h;
  }
  // readMatV4()
  static b64toUint8(t) {
    const i = atob(t), s = i.length, r = new Uint8Array(s);
    for (let a = 0; a < s; a++)
      r[a] = i.charCodeAt(a);
    return r;
  }
  /*
  https://gist.github.com/jonleighton/958841
  MIT LICENSE
  Copyright 2011 Jon Leighton
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  static uint8tob64(t) {
    let i = "";
    const s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = t.byteLength, a = r % 3, n = r - a;
    let o, l, c, h, f;
    for (let d = 0; d < n; d = d + 3)
      f = t[d] << 16 | t[d + 1] << 8 | t[d + 2], o = (f & 16515072) >> 18, l = (f & 258048) >> 12, c = (f & 4032) >> 6, h = f & 63, i += s[o] + s[l] + s[c] + s[h];
    return a === 1 ? (f = t[n], o = (f & 252) >> 2, l = (f & 3) << 4, i += s[o] + s[l] + "==") : a === 2 && (f = t[n] << 8 | t[n + 1], o = (f & 64512) >> 10, l = (f & 1008) >> 4, c = (f & 15) << 2, i += s[o] + s[l] + s[c] + "="), i;
  }
  // https://stackoverflow.com/questions/34156282/how-do-i-save-json-to-local-text-file
  static download(t, i, s) {
    const r = document.createElement("a"), a = Array.isArray(t) ? t : [t], n = new Blob(a, { type: s });
    r.href = URL.createObjectURL(n), r.download = i, r.click();
  }
  static readFileAsync(t) {
    return new Promise((i, s) => {
      const r = new FileReader();
      r.onload = () => {
        i(r.result);
      }, r.onerror = s, r.readAsArrayBuffer(t);
    });
  }
  static blobToBase64(t) {
    return new Promise((i) => {
      const s = new FileReader();
      s.onloadend = () => i(s.result), s.readAsDataURL(t);
    });
  }
  static async decompressBase64String(t) {
    const i = atob(t), s = new ArrayBuffer(i.length), r = new Uint8Array(s);
    for (let a = 0; a < i.length; a++)
      r[a] = i.charCodeAt(a);
    return pe.decompressArrayBuffer(r);
  }
  static async compressToBase64String(t) {
    const i = await pe.compressStringToArrayBuffer(t);
    return pe.uint8tob64(new Uint8Array(i));
  }
  /**
   * Converts a string into a Uint8Array for use with compression/decompression methods (101arrowz/fflate: MIT License)
   * @param str The string to encode
   * @param latin1 Whether or not to interpret the data as Latin-1. This should
   *               not need to be true unless decoding a binary string.
   * @returns The string encoded in UTF-8/Latin-1 binary
   */
  static strToU8(t, i) {
    if (i) {
      const l = new Uint8Array(t.length);
      for (let c = 0; c < t.length; ++c)
        l[c] = t.charCodeAt(c);
      return l;
    }
    const s = t.length, r = (l, c, h) => ((h == null || h > l.length) && (h = l.length), new Uint8Array(l.subarray(c, h)));
    let a = new Uint8Array(t.length + (t.length >> 1)), n = 0;
    const o = (l) => {
      a[n++] = l;
    };
    for (let l = 0; l < s; ++l) {
      if (n + 5 > a.length) {
        const h = new Uint8Array(n + 8 + (s - l << 1));
        h.set(a), a = h;
      }
      let c = t.charCodeAt(l);
      c < 128 || i ? o(c) : c < 2048 ? (o(192 | c >> 6), o(128 | c & 63)) : (c > 55295 && c < 57344, c = 65536 + (c & 1047552) | t.charCodeAt(++l) & 1023, o(240 | c >> 18), o(128 | c >> 12 & 63), o(128 | c >> 6 & 63), o(128 | c & 63));
    }
    return r(a, 0, n);
  }
  static async compress(t, i = "gzip") {
    const s = new CompressionStream(i), r = s.writable.getWriter();
    r.write(t).catch(console.error);
    const a = r.close().catch(console.error), o = await new Response(s.readable).arrayBuffer();
    return await a, o;
  }
  static async compressStringToArrayBuffer(t) {
    const i = this.strToU8(t);
    return await this.compress(i);
  }
  static isArrayBufferCompressed(t) {
    if (t && t.byteLength) {
      const i = new Uint8Array(t);
      return (i[0] << 8 | i[1]) === 8075;
    } else
      return !1;
  }
  /**
   * Converts a Uint8Array to a string (101arrowz/fflate: MIT License)
   * @param dat The data to decode to string
   * @param latin1 Whether or not to interpret the data as Latin-1. This should
   *               not need to be true unless encoding to binary string.
   * @returns The original UTF-8/Latin-1 string
   */
  static strFromU8(t, i) {
    if (i) {
      let s = "";
      for (let r = 0; r < t.length; r += 16384)
        s += String.fromCharCode.apply(null, t.subarray(r, r + 16384));
      return s;
    } else {
      const s = (o, l, c) => ((l == null || l < 0) && (l = 0), (c == null || c > o.length) && (c = o.length), new Uint8Array(o.subarray(l, c))), r = (o) => {
        for (let l = "", c = 0; ; ) {
          let h = o[c++];
          const f = (h > 127) + (h > 223) + (h > 239);
          if (c + f > o.length)
            return { s: l, r: s(o, c - 1) };
          f ? f === 3 ? (h = ((h & 15) << 18 | (o[c++] & 63) << 12 | (o[c++] & 63) << 6 | o[c++] & 63) - 65536, l += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023)) : f & 1 ? l += String.fromCharCode((h & 31) << 6 | o[c++] & 63) : l += String.fromCharCode((h & 15) << 12 | (o[c++] & 63) << 6 | o[c++] & 63) : l += String.fromCharCode(h);
        }
      }, { s: a, r: n } = r(t);
      if (n.length)
        throw new Error("Unexpected trailing bytes in UTF-8 decoding");
      return a;
    }
  }
  static async decompressArrayBuffer(t) {
    const i = await this.decompress(new Uint8Array(t));
    return this.strFromU8(i);
  }
  static arraysAreEqual(t, i) {
    return ta(t, i);
  }
  /**
   * Generate a pre-filled number array.
   *
   * @param start - start value
   * @param stop - stop value
   * @param step - step value
   * @returns filled number array
   */
  static range(t, i, s) {
    return Array.from({ length: (i - t) / s + 1 }, (r, a) => t + a * s);
  }
  /**
   * convert spherical AZIMUTH, ELEVATION to Cartesian
   * @param azimuth - azimuth number
   * @param elevation - elevation number
   * @returns the converted [x, y, z] coordinates
   * @example
   * xyz = NVUtilities.sph2cartDeg(42, 42)
   */
  static sph2cartDeg(t, i) {
    const s = -i * (Math.PI / 180), r = (t - 90) % 360 * (Math.PI / 180), a = [Math.cos(s) * Math.cos(r), Math.cos(s) * Math.sin(r), Math.sin(s)], n = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    return n <= 0 || (a[0] /= n, a[1] /= n, a[2] /= n), a;
  }
  static vox2mm(t, i) {
    const s = mt(i);
    Ut(s, s);
    const r = ht(t[0], t[1], t[2], 1);
    return Ct(r, r, s), O(r[0], r[1], r[2]);
  }
}, Fe = V, ct = class pt {
  // read undocumented AFNI tract.niml format streamlines
  static readTRACT(t) {
    const i = t.byteLength;
    if (i < 20)
      throw new Error("File too small to be niml.tract: bytes = " + i);
    const s = new DataView(t), r = new Uint8Array(t);
    let a = 0;
    function n() {
      for (; a < i && r[a] !== 60; )
        a++;
      const g = a;
      for (; a < i && r[a] !== 62; )
        a++;
      return a++, a - g < 1 ? "" : new TextDecoder().decode(t.slice(g, a - 1)).trim();
    }
    let o = n();
    function l(g) {
      const p = o.indexOf(g);
      if (p < 0)
        return 0;
      const A = o.indexOf('"', p) + 1, x = o.indexOf('"', A), w = o.slice(A, x);
      return parseInt(w);
    }
    const c = l("N_tracts=");
    (!o.startsWith("<network") || c < 1) && V.warn("This is not a valid niml.tract file " + o);
    let h = 0;
    const f = [];
    f.push(h);
    const d = [], u = [];
    for (let g = 0; g < c; g++) {
      o = n();
      const p = l("ni_dimen="), A = l("Bundle_Tag="), x = o.includes("binary.lsbfirst");
      for (let w = 0; w < p; w++) {
        a += 4;
        const v = s.getUint32(a, x) / 3;
        a += 4;
        for (let F = 0; F < v; F++)
          d.push(s.getFloat32(a, x)), a += 4, d.push(-s.getFloat32(a, x)), a += 4, d.push(s.getFloat32(a, x)), a += 4;
        h += v, f.push(h), u.push(A);
      }
      o = n();
    }
    const m = [];
    return m.push({
      id: "tract",
      vals: Float32Array.from(u)
    }), {
      pts: new Float32Array(d),
      offsetPt0: new Uint32Array(f),
      dps: m
    };
  }
  // readTRACT()
  // https://dsi-studio.labsolver.org/doc/cli_data.html
  // https://brain.labsolver.org/hcp_trk_atlas.html
  static async readTT(t) {
    let i = new Uint32Array(0), s = new Float32Array(0);
    const r = await H.readMatV4(t);
    if (!("trans_to_mni" in r))
      throw new Error("TT format file must have 'trans_to_mni'");
    if (!("voxel_size" in r))
      throw new Error("TT format file must have 'voxel_size'");
    if (!("track" in r))
      throw new Error("TT format file must have 'track'");
    let a = it();
    const n = r.trans_to_mni;
    a = Pt(
      n[0],
      n[1],
      n[2],
      n[3],
      n[4],
      n[5],
      n[6],
      n[7],
      n[8],
      n[9],
      n[10],
      n[11],
      n[12],
      n[13],
      n[14],
      n[15]
    ), Ut(a, a);
    function o(l) {
      const c = new DataView(l.buffer), h = [];
      let f = 0, d = 0;
      for (; d < l.length; ) {
        h.push(d);
        const g = c.getUint32(d, !0);
        d = d + g + 13, f += g;
      }
      i = new Uint32Array(h.length + 1), s = new Float32Array(f);
      let u = 0;
      for (let g = 0; g < h.length; g++) {
        i[g] = u / 3;
        let p = h[g];
        const A = c.getUint32(p, !0) / 3;
        let x = c.getInt32(p + 4, !0), w = c.getInt32(p + 8, !0), v = c.getInt32(p + 12, !0);
        p += 16, s[u++] = x, s[u++] = w, s[u++] = v;
        for (let F = 2; F <= A; F++)
          x = x + c.getInt8(p++), w = w + c.getInt8(p++), v = v + c.getInt8(p++), s[u++] = x, s[u++] = w, s[u++] = v;
      }
      for (let g = 0; g < u; g++)
        s[g] = s[g] / 32;
      let m = 0;
      for (let g = 0; g < u / 3; g++) {
        const p = ht(s[m], s[m + 1], s[m + 2], 1);
        Ct(p, p, a), s[m++] = p[0], s[m++] = p[1], s[m++] = p[2];
      }
      i[h.length] = u / 3;
    }
    return o(r.track), {
      pts: s,
      offsetPt0: i
    };
  }
  // readTT
  /**
   * Assemble dpg from a map-of-groups into a ValuesArray ordered by groups[].
   *
   * @param dpgMap - map from groupId -> ValuesArray (entries for that group)
   * @param groups - ValuesArray describing groups; groups[i].id defines the ordering
   * @returns ValuesArray - one entry per tag where vals is the concatenation of each group's vals in groups[] order
   *
   * @throws Error when:
   *  - groups is empty or missing
   *  - any group in groups is missing from dpgMap
   *  - any group contains duplicate entries for a tag
   *  - tag coverage differs between groups (missing tag in any group)
   *  - any entry has invalid/unconvertible vals
   */
  static assembleDpgFromMap(t, i) {
    if (!Array.isArray(i) || i.length === 0)
      throw new Error('assembleDpgFromMap: "groups" is empty or missing; cannot assemble dpg.');
    for (let l = 0; l < i.length; l++) {
      const c = String(i[l].id);
      if (!t[c])
        throw new Error(`assembleDpgFromMap: missing dpgMap entry for group "${c}".`);
      if (!Array.isArray(t[c]))
        throw new Error(`assembleDpgFromMap: dpgMap["${c}"] is not an array.`);
    }
    const s = String(i[0].id), r = t[s], a = [], n = /* @__PURE__ */ new Set();
    for (const l of r) {
      if (!l || typeof l.id != "string")
        throw new Error(`assembleDpgFromMap: invalid entry in group "${s}".`);
      if (n.has(l.id))
        throw new Error(`assembleDpgFromMap: duplicate tag "${l.id}" in group "${s}".`);
      n.add(l.id), a.push(l.id);
    }
    if (n.size === 0)
      throw new Error(`assembleDpgFromMap: no tags found in group "${s}".`);
    for (let l = 1; l < i.length; l++) {
      const c = String(i[l].id), h = t[c], f = /* @__PURE__ */ new Map();
      for (const d of h) {
        if (!d || typeof d.id != "string")
          throw new Error(`assembleDpgFromMap: invalid entry in group "${c}".`);
        f.set(d.id, (f.get(d.id) || 0) + 1);
      }
      for (const [d, u] of f.entries())
        if (u > 1)
          throw new Error(`assembleDpgFromMap: multiple entries for tag "${d}" in group "${c}".`);
      if (f.size !== n.size)
        throw new Error(
          `assembleDpgFromMap: tag coverage mismatch for group "${c}". Expected ${n.size} tags but found ${f.size}.`
        );
      for (const d of n)
        if (!f.has(d))
          throw new Error(`assembleDpgFromMap: group "${c}" missing tag "${d}".`);
    }
    const o = [];
    for (const l of a) {
      const c = [];
      let h = 0;
      for (let u = 0; u < i.length; u++) {
        const m = String(i[u].id), p = t[m].filter((x) => x.id === l);
        if (p.length === 0)
          throw new Error(`assembleDpgFromMap: missing tag "${l}" for group "${m}".`);
        if (p.length > 1)
          throw new Error(`assembleDpgFromMap: multiple entries for tag "${l}" in group "${m}".`);
        const A = p[0];
        if (A.vals instanceof Float32Array)
          c.push(A.vals), h += A.vals.length;
        else
          try {
            const x = Float32Array.from(A.vals);
            c.push(x), h += x.length;
          } catch {
            throw new Error(`assembleDpgFromMap: invalid vals for tag "${l}" in group "${m}".`);
          }
      }
      const f = new Float32Array(h);
      let d = 0;
      for (const u of c)
        f.set(u, d), d += u.length;
      o.push({
        id: l,
        vals: f
        // Note: global_min/global_max/cal_min/cal_max are not computed here.
        // If you want to propagate or compute them, add logic to compute per-tag aggregated values.
      });
    }
    return o;
  }
  // read TRX format tractogram
  // https://github.com/tee-ar-ex/trx-spec/blob/master/specifications.md
  static async readTRX(t) {
    function i(g) {
      const p = (g & 31744) >> 10, A = g & 1023;
      return (g >> 15 ? -1 : 1) * (p ? p === 31 ? A ? NaN : 1 / 0 : Math.pow(2, p - 15) * (1 + A / 1024) : 6103515625e-14 * (A / 1024));
    }
    let s = 0, r = 0, a = new Float32Array([]);
    const n = [], o = {}, l = [], c = [], h = [];
    let f = [], d = !1;
    const u = new sn(t);
    for (let g = 0; g < u.entries.length; g++) {
      const p = u.entries[g];
      if (p.uncompressedSize === 0)
        continue;
      const A = p.fileName.split("/"), x = A.slice(-1)[0];
      if (x.startsWith("."))
        continue;
      const w = A.slice(-3)[0], v = A.slice(-2)[0], F = x.split(".")[0], C = await p.extract();
      if (x.includes("header.json")) {
        const E = new TextDecoder().decode(C);
        f = JSON.parse(E);
        continue;
      }
      let b = 0, y = [];
      if (x.endsWith(".uint64") || x.endsWith(".int64")) {
        b = C.length / 8, y = new Uint32Array(b);
        const E = new Uint32Array(C.buffer);
        let S = 0;
        for (let D = 0; D < b; D++)
          y[D] = E[S], E[S + 1] !== 0 && (d = !0), S += 2;
      } else if (x.endsWith(".uint32"))
        y = new Uint32Array(C.buffer);
      else if (x.endsWith(".uint16"))
        y = new Uint16Array(C.buffer);
      else if (x.endsWith(".uint8"))
        y = new Uint8Array(C.buffer);
      else if (x.endsWith(".int32"))
        y = new Int32Array(C.buffer);
      else if (x.endsWith(".int16"))
        y = new Int16Array(C.buffer);
      else if (x.endsWith(".int8"))
        y = new Int8Array(C.buffer);
      else if (x.endsWith(".float64"))
        y = new Float64Array(C.buffer);
      else if (x.endsWith(".float32"))
        y = new Float32Array(C.buffer);
      else if (x.endsWith(".float16")) {
        b = C.length / 2, y = new Float32Array(b);
        const E = new Uint16Array(C.buffer), S = new Float32Array(65536);
        for (let D = 0; D < 65536; D++)
          S[D] = i(D);
        for (let D = 0; D < b; D++)
          y[D] = S[E[D]];
      } else
        continue;
      if (b = y.length, v.includes("groups")) {
        l.push({
          id: F,
          vals: Float32Array.from(y.slice())
        });
        continue;
      }
      if (w.includes("dpg")) {
        const E = String(v);
        o[E] || (o[E] = []), o[E].push({
          id: F,
          vals: Float32Array.from(y.slice())
        });
        continue;
      }
      if (v.includes("dpv")) {
        h.push({
          id: F,
          vals: Float32Array.from(y.slice())
        });
        continue;
      }
      if (v.includes("dps")) {
        c.push({
          id: F,
          vals: Float32Array.from(y.slice())
        });
        continue;
      }
      if (x.startsWith("offsets.")) {
        s = b;
        for (let E = 0; E < b; E++)
          n[E] = y[E];
      }
      x.startsWith("positions.3.") && (r = b, a = new Float32Array(y));
    }
    if (s === 0 || r === 0)
      throw new Error("Failure reading TRX format (no offsets or points).");
    if (d)
      throw new Error("Too many vertices: JavaScript does not support 64 bit integers");
    let m = [];
    return l.length > 0 && o && Object.keys(o).length > 0 && (m = this.assembleDpgFromMap(o, l)), n[s] = r / 3, {
      pts: a,
      offsetPt0: new Uint32Array(n),
      dpg: m,
      dps: c,
      dpv: h,
      groups: l,
      header: f
    };
  }
  // readTRX()
  // issue1426 MRtrix data per streamline as ASCII text
  static readTXT(t, i = 0) {
    const r = new TextDecoder("utf-8").decode(t).split(/\r?\n|\r/).filter((n) => n.trim().length > 0);
    i <= 0 && (i = r.length);
    const a = new Float32Array(i);
    for (let n = 0; n < i && n < r.length; n++) {
      const o = parseFloat(r[n].trim());
      a[n] = Number.isFinite(o) ? o : 0;
    }
    return a;
  }
  // read mrtrix tsf format Track Scalar Files - these are are DPV
  // https://mrtrix.readthedocs.io/en/dev/getting_started/image_data.html#track-scalar-file-format-tsf
  static readTSF(t, i = 0) {
    const s = new Float32Array(i), r = t.byteLength;
    if (r < 20)
      throw new Error("File too small to be TSF: bytes = " + r);
    const a = new Uint8Array(t);
    let n = 0;
    function o() {
      for (; n < r && a[n] === 10; )
        n++;
      const d = n;
      for (; n < r && a[n] !== 10; )
        n++;
      return n++, n - d < 1 ? "" : new TextDecoder().decode(t.slice(d, n - 1));
    }
    let l = o();
    if (!l.includes("mrtrix track scalars"))
      throw new Error("Not a valid TSF file");
    let c = -1;
    for (; n < r && !l.includes("END"); )
      if (l = o(), l.toLowerCase().startsWith("file:") && (c = parseInt(l.split(" ").pop())), l.toLowerCase().startsWith("datatype:") && !l.endsWith("Float32LE"))
        throw new Error("Only supports TSF files with Float32LE");
    if (c < 20)
      throw new Error("Not a valid TSF file (missing file offset)");
    n = c;
    const h = new DataView(t);
    let f = 0;
    for (; n + 4 <= r && f < i; ) {
      const d = h.getFloat32(n, !0);
      if (n += 4, isFinite(d))
        s[f++] = d;
      else if (!isNaN(d))
        break;
    }
    return s;
  }
  // readTSF
  // read mrtrix tck format streamlines
  // https://mrtrix.readthedocs.io/en/latest/getting_started/image_data.html#tracks-file-format-tck
  static readTCK(t) {
    const i = t.byteLength;
    if (i < 20)
      throw new Error("File too small to be TCK: bytes = " + i);
    const s = new Uint8Array(t);
    let r = 0;
    function a() {
      for (; r < i && s[r] === 10; )
        r++;
      const m = r;
      for (; r < i && s[r] !== 10; )
        r++;
      return r++, r - m < 1 ? "" : new TextDecoder().decode(t.slice(m, r - 1));
    }
    let n = a();
    if (!n.includes("mrtrix tracks"))
      throw new Error("Not a valid TCK file");
    let o = -1;
    for (; r < i && !n.includes("END"); )
      n = a(), n.toLowerCase().startsWith("file:") && (o = parseInt(n.split(" ").pop()));
    if (o < 20)
      throw new Error("Not a valid TCK file (missing file offset)");
    r = o;
    const l = new DataView(t);
    let c = 0, h = new Uint32Array(i / (4 * 4)), f = 0, d = 0, u = new Float32Array(i / 4);
    for (h[0] = 0; r + 12 < i; ) {
      const m = l.getFloat32(r, !0);
      r += 4;
      const g = l.getFloat32(r, !0);
      r += 4;
      const p = l.getFloat32(r, !0);
      if (r += 4, isFinite(m))
        u[d++] = m, u[d++] = g, u[d++] = p, c++;
      else if (h[f++] = c, !isNaN(m))
        break;
    }
    return u = u.slice(0, d), h = h.slice(0, f), {
      pts: u,
      offsetPt0: h
    };
  }
  // readTCK()
  // not included in public docs
  // read trackvis trk format streamlines
  // http://trackvis.org/docs/?subsect=fileformat
  static async readTRK(t) {
    let i = new DataView(t), s = i.getUint32(0, !0);
    if (s !== 1128354388) {
      let D;
      if (s === 4247762216)
        throw new Error("zstd TRK decompression is not supported");
      D = await H.decompress(new Uint8Array(t)), t = D.buffer, i = new DataView(t), s = i.getUint32(0, !0);
    }
    const r = i.getUint32(992, !0), a = i.getUint32(996, !0);
    if (r > 2 || a !== 1e3 || s !== 1128354388)
      throw new Error("Not a valid TRK file");
    const n = i.getInt16(36, !0), o = [];
    for (let D = 0; D < n; D++) {
      const M = new Uint8Array(t.slice(38 + D * 20, 58 + D * 20)), B = new TextDecoder().decode(M).split("\0").shift();
      o.push({
        id: B.trim(),
        // TODO can we guarantee this?
        vals: []
      });
    }
    const l = i.getFloat32(12, !0), c = i.getFloat32(16, !0), h = i.getFloat32(20, !0), f = Pt(
      1 / l,
      0,
      0,
      -0.5,
      0,
      1 / c,
      0,
      -0.5,
      0,
      0,
      1 / h,
      -0.5,
      0,
      0,
      0,
      1
    ), d = i.getInt16(238, !0), u = [];
    for (let D = 0; D < d; D++) {
      const M = new Uint8Array(t.slice(240 + D * 20, 260 + D * 20)), B = new TextDecoder().decode(M).split("\0").shift();
      u.push({
        id: B.trim(),
        // TODO can we guarantee this?
        vals: []
      });
    }
    const m = it();
    for (let D = 0; D < 16; D++)
      m[D] = i.getFloat32(440 + D * 4, !0);
    m[15] === 0 && (V.warn("TRK vox_to_ras not set"), Vr(m));
    const g = it();
    Br(g, f, m);
    let p = null, A = null;
    p = new Int32Array(t.slice(a)), A = new Float32Array(p.buffer);
    const x = p.length;
    if (x < 1)
      throw new Error("Empty TRK file.");
    let w = 0, v = 0, F = new Uint32Array(p.length / 4), C = 0, b = new Float32Array(p.length), y = 0;
    for (; w < x; ) {
      const D = p[w];
      w = w + 1, F[C++] = v;
      for (let M = 0; M < D; M++) {
        const B = A[w + 0], T = A[w + 1], U = A[w + 2];
        if (w += 3, b[y++] = B * g[0] + T * g[1] + U * g[2] + g[3], b[y++] = B * g[4] + T * g[5] + U * g[6] + g[7], b[y++] = B * g[8] + T * g[9] + U * g[10] + g[11], n > 0)
          for (let R = 0; R < n; R++)
            o[R].vals.push(A[w]), w++;
        v++;
      }
      if (d > 0)
        for (let M = 0; M < d; M++)
          u[M].vals.push(A[w]), w++;
    }
    const E = [];
    for (let D = 0; D < u.length; D++)
      E.push({
        id: u[D].id,
        vals: Float32Array.from(u[D].vals)
      });
    const S = [];
    for (let D = 0; D < o.length; D++)
      S.push({
        id: o[D].id,
        vals: Float32Array.from(o[D].vals)
      });
    return F[C++] = v, b = b.slice(0, y), F = F.slice(0, C), {
      pts: b,
      offsetPt0: F,
      dps: E,
      dpv: S
    };
  }
  // readTRK()
  // read legacy VTK text format file
  static readTxtVTK(t) {
    const r = new TextDecoder("utf-8").decode(t).split(`
`);
    if (r.length < 7 || !r[0].startsWith("# vtk DataFile"))
      throw new Error("Invalid VTK image");
    if (!r[2].startsWith("ASCII"))
      throw new Error("Not ASCII VTK mesh");
    let n = 3;
    for (; r[n].length < 1; )
      n++;
    if (!r[n].includes("POLYDATA"))
      throw new Error("Not ASCII VTK polydata");
    for (n++; r[n].length < 1; )
      n++;
    if (!r[n].startsWith("POINTS"))
      throw new Error("Not VTK POINTS");
    let o = r[n].trim().split(/\s+/);
    const l = parseInt(o[1]), c = l * 3, h = new Float32Array(l * 3);
    let f = 0;
    for (; f < l * 3; ) {
      n++;
      const g = r[n].trim().trim().split(/\s+/);
      for (let p = 0; p < g.length && !(f >= c); p++)
        h[f] = parseFloat(g[p]), f++;
    }
    const d = [];
    for (n++; r[n].length < 1; )
      n++;
    if (r[n].startsWith("METADATA")) {
      for (; r[n].length > 1; )
        n++;
      n++;
    }
    if (o = r[n].trim().split(/\s+/), n++, o[0].includes("LINES")) {
      const m = parseInt(o[1]);
      if (m < 1)
        throw new Error("Corrupted VTK ASCII");
      let g = r[n].trim();
      const p = [];
      let A = [];
      if (g.startsWith("OFFSETS")) {
        n++;
        let x = 0;
        for (; x < m; ) {
          g = r[n].trim(), n++;
          const w = g.trim().split(/\s+/);
          for (let v = 0; v < w.length && (p[x] = parseInt(w[v]), x++, !(x >= m)); v++)
            ;
        }
        A = Array.from(h);
      } else {
        let x = function() {
          g = r[n].trim();
          const C = g.trim().split(/\s+/);
          v = [];
          for (let b = 0; b < C.length; b++)
            v.push(parseInt(C[b]));
          F = 0, n++;
        }, w = 0;
        p[0] = 0;
        let v = [], F = 0;
        x();
        for (let C = 0; C < m; C++) {
          F >= v.length && x();
          const b = v[F++];
          w += b, p[C + 1] = w;
          for (let y = 0; y < b; y++) {
            F >= v.length && x();
            const E = v[F++] * 3;
            A.push(h[E + 0]), A.push(h[E + 1]), A.push(h[E + 2]);
          }
        }
      }
      return {
        pts: Float32Array.from(A),
        offsetPt0: Uint32Array.from(p)
      };
    } else if (o[0].includes("TRIANGLE_STRIPS")) {
      const m = parseInt(o[1]);
      for (let g = 0; g < m; g++) {
        const p = r[n].trim();
        n++;
        const A = p.trim().split(/\s+/), x = parseInt(A[0]) - 2;
        let w = 1;
        for (let v = 0; v < x; v++)
          v % 2 ? (d.push(parseInt(A[w + 2])), d.push(parseInt(A[w + 1])), d.push(parseInt(A[w]))) : (d.push(parseInt(A[w])), d.push(parseInt(A[w + 1])), d.push(parseInt(A[w + 2]))), w += 1;
      }
    } else if (o[0].includes("POLYGONS")) {
      const m = parseInt(o[1]);
      for (let g = 0; g < m; g++) {
        const p = r[n].trim();
        n++;
        const A = p.trim().split(/\s+/), x = parseInt(A[0]) - 2, w = parseInt(A[1]);
        let v = parseInt(A[2]);
        for (let F = 0; F < x; F++) {
          const C = parseInt(A[3 + F]);
          d.push(w), d.push(v), d.push(C), v = C;
        }
      }
    } else
      throw new Error("Unsupported ASCII VTK datatype " + o[0]);
    const u = new Uint32Array(d);
    return {
      positions: h,
      indices: u
    };
  }
  // readTxtVTK()
  // read mesh overlay to influence vertex colors
  static async readLayer(t = "", i, s, r = 0.5, a = "warm", n = "winter", o = !1, l = null, c = null, h = 0) {
    const f = {
      ...ic,
      colormapInvert: !1,
      colormapType: 0,
      // COLORMAP_TYPE.MIN_TO_MAX
      isTransparentBelowCalMin: !0,
      isAdditiveBlend: !1,
      colorbarVisible: !0,
      colormapLabel: null
    }, d = /(?:\.([^.]+))?$/;
    let u = d.exec(t)[1];
    u = u.toUpperCase(), u === "GZ" && (u = d.exec(t.slice(0, -3))[1], u = u.toUpperCase());
    const m = s.vertexCount / 3;
    if (s.offsetPt0) {
      const A = t.split("/");
      let x = "Unknown";
      if (A.length > 1 && A.pop() && (x = x.split(".").slice(0, -1).join(".")), u === "TXT") {
        const b = s.offsetPt0.length - 1, y = pt.readTXT(i, b);
        if (y.length !== b)
          throw new Error(`TXT file has ${y.length} items, expected one per streamline (${b}).`);
        s.dps || (s.dps = []);
        const E = y.reduce((D, M) => Math.min(D, M)), S = y.reduce((D, M) => Math.max(D, M));
        return s.dps.push({
          id: x,
          vals: Float32Array.from(y.slice()),
          global_min: E,
          global_max: S,
          cal_min: E,
          cal_max: S
        }), f;
      }
      if (u !== "TSF")
        throw new Error("readLayer for streamlines only supports TSF and TXT files.");
      const w = s.pts.length / 3, v = pt.readTSF(i, w);
      s.dpv || (s.dpv = []);
      const F = v.reduce((b, y) => Math.min(b, y)), C = v.reduce((b, y) => Math.max(b, y));
      return s.dpv.push({
        id: x,
        vals: Float32Array.from(v.slice()),
        global_min: F,
        global_max: C,
        cal_min: F,
        cal_max: C
      }), f;
    }
    if (m < 3) {
      V.error("n_vert < 3 in layer");
      return;
    }
    if (u === "MZ3") {
      const A = await pt.readMZ3(i, m);
      f.values = A.scalars, "colormapLabel" in A && (f.colormapLabel = A.colormapLabel);
    } else if (u === "ANNOT") {
      const A = pt.readANNOT(i, m, !0);
      A instanceof Uint32Array ? f.values = A : (f.values = A.scalars, f.colormapLabel = A.colormapLabel);
    } else if (u === "CRV" || u === "CURV" || u === "THICKNESS" || u === "AREA")
      f.values = pt.readCURV(i, m), f.isTransparentBelowCalMin = !1;
    else if (u === "GII") {
      const A = await pt.readGII(i, m);
      f.values = A.scalars, f.colormapLabel = A.colormapLabel;
    } else if (u === "MGH" || u === "MGZ") {
      const A = await pt.readMGH(i, m, !0);
      "scalars" in A ? (f.values = A.scalars, f.colormapLabel = A.colormapLabel) : f.values = A;
    } else if (u === "NII")
      f.values = await pt.readNII(
        i,
        s.pts,
        s.anatomicalStructurePrimary
      );
    else if (u === "SMP")
      f.values = await pt.readSMP(i, m);
    else if (u === "STC")
      f.values = pt.readSTC(i, m);
    else if (pt.isCurv(i))
      f.values = pt.readCURV(i, m), f.isTransparentBelowCalMin = !1;
    else
      return V.warn("Unknown layer overlay format " + t), f;
    if (!f.values) {
      V.error("no values in layer");
      return;
    }
    f.nFrame4D = f.values.length / m, f.frame4D = 0, f.outlineBorder = h;
    let g = f.values[0], p = f.values[0];
    for (let A = 0; A < f.values.length; A++)
      g = Math.min(g, f.values[A]), p = Math.max(p, f.values[A]);
    return f.global_min = g, f.global_max = p, f.cal_min = l || 0, l || (f.cal_min = g), f.cal_max = c || 0, c || (f.cal_max = p), f.cal_minNeg = NaN, f.cal_maxNeg = NaN, f.opacity = r, f.colormap = a, f.colormapNegative = n, f.useNegativeCmap = o, f;
  }
  // readLayer()
  // read brainvoyager smp format file
  // https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/40-the-format-of-smp-files
  static async readSMP(t, i) {
    const s = t.byteLength;
    let r = new DataView(t), a = r.getUint16(0, !0);
    if (a > 5) {
      const f = await H.decompress(new Uint8Array(t));
      r = new DataView(f.buffer), a = r.getUint16(0, !0), t = f.buffer;
    }
    a > 5 && V.error("Unsupported or invalid BrainVoyager SMP version " + a);
    const n = r.getUint32(2, !0);
    n !== i && V.error("SMP file has " + n + " vertices, background mesh has " + i);
    const o = r.getUint16(6, !0), l = new Float32Array(n * o);
    let c = 9;
    function h() {
      const f = c;
      for (; c < s && r.getUint8(c) !== 0; )
        c++;
      return c++, new TextDecoder().decode(t.slice(f, c - 1));
    }
    h();
    for (let f = 0; f < o; f++) {
      const d = {};
      d.mapType = r.getUint32(c, !0), c += 4, a >= 3 && d.mapType === 3 && (d.nLags = r.getUint32(c, !0), c += 4, d.mnLag = r.getUint32(c, !0), c += 4, d.mxLag = r.getUint32(c, !0), c += 4, d.ccOverlay = r.getUint32(c, !0), c += 4), d.clusterSize = r.getUint32(c, !0), c += 4, d.clusterCheck = r.getUint8(c), c += 1, d.critThresh = r.getFloat32(c, !0), c += 4, d.maxThresh = r.getFloat32(c, !0), c += 4, a >= 4 && (d.includeValuesGreaterThreshMax = r.getUint32(c, !0), c += 4), d.df1 = r.getUint32(c, !0), c += 4, d.df2 = r.getUint32(c, !0), c += 4, a >= 5 ? (d.posNegFlag = r.getUint32(c, !0), c += 4) : d.posNegFlag = 3, d.cortexBonferroni = r.getUint32(c, !0), c += 4, d.posMinRGB = [0, 0, 0], d.posMaxRGB = [0, 0, 0], d.negMinRGB = [0, 0, 0], d.negMaxRGB = [0, 0, 0], a >= 2 && (d.posMinRGB[0] = r.getUint8(c), c++, d.posMinRGB[1] = r.getUint8(c), c++, d.posMinRGB[2] = r.getUint8(c), c++, d.posMaxRGB[0] = r.getUint8(c), c++, d.posMaxRGB[1] = r.getUint8(c), c++, d.posMaxRGB[2] = r.getUint8(c), c++, a >= 4 && (d.negMinRGB[0] = r.getUint8(c), c++, d.negMinRGB[1] = r.getUint8(c), c++, d.negMinRGB[2] = r.getUint8(c), c++, d.negMaxRGB[0] = r.getUint8(c), c++, d.negMaxRGB[1] = r.getUint8(c), c++, d.negMaxRGB[2] = r.getUint8(c), c++), d.enableSMPColor = r.getUint8(c), c++, a >= 4 && (d.lut = h()), d.colorAlpha = r.getFloat32(c, !0), c += 4), d.name = h();
      const u = new Float32Array(t, c, n);
      l.set(u, f * n), c += n * 4;
    }
    return l;
  }
  // readSMP()
  // read mne stc format file, not to be confused with brainvoyager stc format
  // https://github.com/mne-tools/mne-python/blob/main/mne/source_estimate.py#L211-L365
  static readSTC(t, i) {
    const s = new DataView(t), r = s.getInt32(8, !1);
    if (r !== i)
      throw new Error("Overlay has " + r + " vertices, expected " + i);
    let a = 12 + r * 4;
    const n = s.getUint32(a, !1);
    a += 4;
    const o = new Float32Array(n * r);
    for (let l = 0; l < n * r; l++)
      o[l] = s.getFloat32(a, !1), a += 4;
    return o;
  }
  // readSTC()
  static isCurv(t) {
    const i = new DataView(t), s = i.getUint8(0), r = i.getUint8(1), a = i.getUint8(2);
    return s !== 255 || r !== 255 || a !== 255 ? (Fe.debug("Unable to recognize file type: does not appear to be FreeSurfer format."), !1) : !0;
  }
  // read freesurfer curv big-endian format
  // https://github.com/bonilhamusclab/MRIcroS/blob/master/%2BfileUtils/%2Bpial/readPial.m
  // http://www.grahamwideman.com/gw/brain/fs/surfacefileformats.htm
  static readCURV(t, i) {
    const s = new DataView(t), r = s.getUint8(0), a = s.getUint8(1), n = s.getUint8(2), o = s.getUint32(3, !1), l = s.getUint32(11, !1);
    if ((r !== 255 || a !== 255 || n !== 255) && Fe.debug("Unable to recognize file type: does not appear to be FreeSurfer format."), i !== o)
      throw new Error("CURV file has different number of vertices ( " + o + ")than mesh (" + i + ")");
    if (t.byteLength < 15 + 4 * o * l)
      throw new Error("CURV file smaller than specified");
    const c = new Float32Array(l * o);
    let h = 15;
    for (let m = 0; m < l * o; m++)
      c[m] = s.getFloat32(h, !1), h += 4;
    let f = c[0], d = c[0];
    for (let m = 0; m < c.length; m++)
      f = Math.min(f, c[m]), d = Math.max(d, c[m]);
    const u = 1 / (d - f);
    for (let m = 0; m < c.length; m++)
      c[m] = 1 - (c[m] - f) * u;
    return c;
  }
  // readCURV()
  // read freesurfer Annotation file provides vertex colors
  // https://surfer.nmr.mgh.harvard.edu/fswiki/LabelsClutsAnnotationFiles
  static readANNOT(t, i, s = !1) {
    const r = new DataView(t), a = r.getUint32(0, !1), n = this.decimateLayerVertices(a, i);
    if (i !== n)
      throw new Error("ANNOT file has different number of vertices than mesh");
    if (t.byteLength < 4 + 8 * a)
      throw new Error("ANNOT file smaller than specified");
    let o = 0;
    const l = new Uint32Array(a);
    for (let w = 0; w < a; w++) {
      const v = r.getUint32(o += 4, !1);
      l[v] = r.getUint32(o += 4, !1);
    }
    if (!s)
      return l;
    let c = 0;
    try {
      c = r.getInt32(o += 4, !1);
    } catch {
      return l;
    }
    if (c !== 1 || r.getInt32(o += 4, !1) > 0)
      return l;
    const d = r.getInt32(o += 4, !1), u = r.getInt32(o += 4, !1);
    o += u;
    const m = r.getInt32(o += 4, !1);
    if (m < 1)
      return l;
    const g = {
      R: Array(d).fill(0),
      G: Array(d).fill(0),
      B: Array(d).fill(0),
      A: Array(d).fill(0),
      I: Array(d).fill(0),
      labels: Array(d).fill("")
    };
    for (let w = 0; w < m; w++) {
      const v = r.getInt32(o += 4, !1), F = r.getInt32(o += 4, !1);
      o += 4;
      let C = "";
      for (let D = 0; D < F; D++) {
        const M = r.getUint8(o++);
        if (M === 0)
          break;
        C += String.fromCharCode(M);
      }
      o -= 4;
      const b = r.getInt32(o += 4, !1), y = r.getInt32(o += 4, !1), E = r.getInt32(o += 4, !1), S = r.getInt32(o += 4, !1);
      if (v < 0 || v >= d) {
        V.warn("annot entry out of range");
        continue;
      }
      g.R[v] = b, g.G[v] = y, g.B[v] = E, g.A[v] = S, g.I[v] = (S << 24) + (E << 16) + (y << 8) + b, g.labels[v] = C;
    }
    const p = new Float32Array(a);
    p.fill(-1);
    let A = 0;
    for (let w = 0; w < i; w++) {
      const v = l[w];
      for (let F = 0; F < d; F++)
        if (g.I[F] === v) {
          p[w] = F;
          break;
        }
      p[w] < 0 && (A++, p[w] = 0);
    }
    A > 0 && V.error(`annot vertex colors do not match ${A} of ${a} vertices.`);
    for (let w = 0; w < d; w++)
      g.I[w] = w;
    const x = rt.makeLabelLut(g);
    return {
      scalars: p,
      colormapLabel: x
    };
  }
  // readANNOT()
  // read BrainNet viewer format
  // https://www.nitrc.org/projects/bnv/
  static readNV(t) {
    const i = t.byteLength, s = new Uint8Array(t);
    let r = 0;
    function a() {
      for (; r < i && s[r] === 10; )
        r++;
      const d = r;
      for (; r < i && s[r] !== 10; )
        r++;
      return r++, r - d < 1 ? "" : new TextDecoder().decode(t.slice(d, r - 1));
    }
    let n = 0, o = 0, l = 0, c = 0, h, f;
    for (; r < i; ) {
      const d = a();
      if (d.startsWith("#"))
        continue;
      const u = d.trim().split(/\s+/);
      if (n < 1) {
        n = parseInt(u[0]), h = new Float32Array(n * 3);
        continue;
      }
      if (l < n * 3) {
        h[l] = parseFloat(u[0]), h[l + 1] = parseFloat(u[1]), h[l + 2] = parseFloat(u[2]), l += 3;
        continue;
      }
      if (o < 1) {
        o = parseInt(u[0]), f = new Uint32Array(o * 3);
        continue;
      }
      if (c >= o * 3)
        break;
      f[c + 2] = parseInt(u[0]) - 1, f[c + 1] = parseInt(u[1]) - 1, f[c + 0] = parseInt(u[2]) - 1, c += 3;
    }
    return {
      positions: h,
      indices: f
    };
  }
  // readNV()
  // read ASCII Patch File format
  // https://afni.nimh.nih.gov/pub/dist/doc/htmldoc/demos/Bootcamp/CD.html#cd
  // http://www.grahamwideman.com/gw/brain/fs/surfacefileformats.htm
  static readASC(t) {
    const i = t.byteLength, s = new Uint8Array(t);
    let r = 0;
    function a() {
      for (; r < i && s[r] === 10; )
        r++;
      const u = r;
      for (; r < i && s[r] !== 10; )
        r++;
      return r++, r - u < 1 ? "" : new TextDecoder().decode(t.slice(u, r - 1));
    }
    let n = a();
    n.startsWith("#!ascii") || V.warn("Invalid ASC mesh"), n = a();
    let o = n.trim().split(/\s+/);
    const l = parseInt(o[0]), c = parseInt(o[1]), h = new Float32Array(l * 3);
    let f = 0;
    for (let u = 0; u < l; u++)
      n = a(), o = n.trim().split(/\s+/), h[f] = parseFloat(o[0]), h[f + 1] = parseFloat(o[1]), h[f + 2] = parseFloat(o[2]), f += 3;
    const d = new Uint32Array(c * 3);
    f = 0;
    for (let u = 0; u < c; u++)
      n = a(), o = n.trim().split(/\s+/), d[f] = parseInt(o[0]), d[f + 1] = parseInt(o[1]), d[f + 2] = parseInt(o[2]), f += 3;
    return {
      positions: h,
      indices: d
    };
  }
  // readASC()
  // read legacy VTK format
  static readVTK(t) {
    const i = t.byteLength;
    if (i < 20)
      throw new Error("File too small to be VTK: bytes = " + t.byteLength);
    const s = new Uint8Array(t);
    let r = 0;
    function a(g = !0) {
      if (g)
        for (; r < i && s[r] === 10; )
          r++;
      const p = r;
      for (; r < i && s[r] !== 10; )
        r++;
      return r++, r - p < 1 ? "" : new TextDecoder().decode(t.slice(p, r - 1));
    }
    let n = a();
    if (!n.startsWith("# vtk DataFile"))
      throw new Error("Invalid VTK mesh");
    if (n = a(!1), n = a(), n.startsWith("ASCII"))
      return pt.readTxtVTK(t);
    if (!n.startsWith("BINARY"))
      throw new Error("Invalid VTK image, expected ASCII or BINARY " + n);
    if (n = a(), !n.includes("POLYDATA"))
      throw new Error("Only able to read VTK POLYDATA " + n);
    n = a(), (!n.includes("POINTS") || !n.includes("double") && !n.includes("float")) && V.warn("Only able to read VTK float or double POINTS" + n);
    const o = n.includes("double");
    let l = n.trim().split(/\s+/);
    const h = parseInt(l[1]) * 3, f = new Float32Array(h), d = new DataView(t);
    if (o)
      for (let g = 0; g < h; g++)
        f[g] = d.getFloat64(r, !1), r += 8;
    else
      for (let g = 0; g < h; g++)
        f[g] = d.getFloat32(r, !1), r += 4;
    n = a(), l = n.trim().split(/\s+/);
    const u = [];
    if (l[0].includes("LINES")) {
      const g = parseInt(l[1]), p = r;
      if (n = a(), n.startsWith("OFFSETS")) {
        let v = !1;
        n.includes("int64") && (v = !0);
        const F = new Uint32Array(g);
        if (v) {
          let b = !1;
          for (let y = 0; y < g; y++) {
            let E = d.getInt32(r, !1);
            E !== 0 && (b = !0), r += 4, E = d.getInt32(r, !1), r += 4, F[y] = E;
          }
          b && V.warn("int32 overflow: JavaScript does not support int64");
        } else
          for (let b = 0; b < g; b++) {
            const y = d.getInt32(r, !1);
            r += 4, F[b] = y;
          }
        return {
          pts: f,
          offsetPt0: F
        };
      }
      r = p;
      let A = 0;
      const x = [], w = [];
      x.push(A);
      for (let v = 0; v < g; v++) {
        const F = d.getInt32(r, !1);
        r += 4, A += F, x.push(A);
        for (let C = 0; C < F; C++) {
          const b = d.getInt32(r, !1) * 3;
          r += 4, w.push(f[b + 0]), w.push(f[b + 1]), w.push(f[b + 2]);
        }
      }
      return {
        pts: Float32Array.from(w),
        offsetPt0: Uint32Array.from(x)
      };
    } else if (l[0].includes("TRIANGLE_STRIPS")) {
      const g = parseInt(l[1]);
      for (let p = 0; p < g; p++) {
        const A = d.getInt32(r, !1) - 2;
        r += 4;
        for (let x = 0; x < A; x++)
          x % 2 ? (u.push(d.getInt32(r + 8, !1)), u.push(d.getInt32(r + 4, !1)), u.push(d.getInt32(r, !1))) : (u.push(d.getInt32(r, !1)), u.push(d.getInt32(r + 4, !1)), u.push(d.getInt32(r + 8, !1))), r += 4;
        r += 8;
      }
    } else if (l[0].includes("POLYGONS")) {
      const g = parseInt(l[1]), p = r, A = a();
      if (A.startsWith("OFFSETS")) {
        let x = A.includes("int64");
        const w = new Uint32Array(g);
        let v = !1;
        for (let y = 0; y < g; y++)
          x && (d.getInt32(r, !1) !== 0 && (v = !0), r += 4), w[y] = d.getInt32(r, !1), r += 4;
        if (!Number.isSafeInteger(g) || g >= 2147483648 || v)
          throw new Error("values exceed 2GB limit");
        const F = a();
        if (!F.startsWith("CONNECTIVITY"))
          throw new Error("Expected CONNECTIVITY after OFFSETS");
        x = F.includes("int64");
        const C = w[g - 1], b = new Uint32Array(C);
        for (let y = 0; y < C; y++)
          x && (r += 4), b[y] = d.getInt32(r, !1), r += 4;
        for (let y = 0; y < g; y++) {
          const E = y === 0 ? 0 : w[y - 1], S = w[y];
          for (let D = 1; D < S - E - 1; D++)
            u.push(b[E]), u.push(b[E + D]), u.push(b[E + D + 1]);
        }
      } else {
        r = p;
        for (let x = 0; x < g; x++) {
          const w = d.getInt32(r, !1) - 2;
          if (x === 0 && w > 65535)
            throw new Error("Invalid VTK binary polygons using little-endian data (MRtrix)");
          r += 4;
          const v = d.getInt32(r, !1);
          r += 4;
          let F = d.getInt32(r, !1);
          r += 4;
          for (let C = 0; C < w; C++) {
            const b = d.getInt32(r, !1);
            r += 4, u.push(v, F, b), F = b;
          }
        }
      }
    } else
      throw new Error("Unsupported binary VTK datatype " + l[0]);
    const m = new Uint32Array(u);
    return {
      positions: f,
      indices: m
    };
  }
  // readVTK()
  static readWRL(t) {
    const i = new TextDecoder("utf-8").decode(t), s = /coord\s+Coordinate\s*\{\s*point\s*\[([\s\S]*?)\]/, r = /coordIndex\s*\[([\s\S]*?)\]/, a = /color\s+Color\s*\{\s*color\s*\[([\s\S]*?)\]/, n = s.exec(i), o = r.exec(i), l = a.exec(i);
    if (!n || !o)
      throw new Error("Invalid WRL file: Could not find vertices or indices.");
    const c = new Float32Array(
      n[1].trim().split(/[\s,]+/).map(Number)
    );
    let h = null;
    if (l) {
      h = new Float32Array(
        l[1].trim().split(/[\s,]+/).map(Number)
      );
      const d = c.length / 3;
      h.length !== d * 3 && (console.warn(`Unexpected color count: expected ${d * 3}, got ${h.length}`), h = null);
    }
    const f = new Uint32Array(
      o[1].trim().split(/[\s,]+/).map(Number).filter((d) => d !== -1)
    );
    return { positions: c, indices: f, colors: h };
  }
  // readWRL()
  // read brainsuite DFS format
  // http://brainsuite.org/formats/dfs/
  static readDFS(t) {
    const i = new DataView(t), s = i.getUint32(0, !0), r = i.getUint16(4, !0);
    (s !== 1599292996 || r !== 17740) && V.warn("Not a little-endian brainsuite DFS mesh");
    const a = i.getUint32(12, !0), n = i.getUint32(24, !0), o = i.getUint32(28, !0), l = i.getUint32(48, !0);
    let c = a;
    const h = new Uint32Array(t, c, n * 3);
    c += n * 3 * 4;
    const f = new Float32Array(t, c, o * 3);
    for (let u = 0; u < o * 3; u += 3) {
      const m = f[u];
      f[u] = f[u + 1], f[u + 1] = m;
    }
    let d;
    return l >= 0 && (d = new Float32Array(t, l, o * 3)), {
      positions: f,
      indices: h,
      colors: d
    };
  }
  // read surfice MZ3 format
  // https://github.com/neurolabusc/surf-ice/tree/master/mz3
  static async readMZ3(t, i = 0) {
    if (t.byteLength < 20)
      throw new Error("File too small to be mz3: bytes = " + t.byteLength);
    let s = new DataView(t), r = t, a = s.getUint16(0, !0);
    if (a === 35615 || a === 8075) {
      const E = await H.decompress(new Uint8Array(t));
      s = new DataView(E.buffer), a = s.getUint16(0, !0), r = E.buffer;
    }
    const n = s.getUint16(2, !0), o = s.getUint32(4, !0);
    let l = s.getUint32(8, !0);
    const c = s.getUint32(12, !0);
    if (Fe.debug("MZ3 magic %d attr %d face %d vert %d skip %d", a, n, o, l, c), a !== 23117)
      throw new Error("Invalid MZ3 file");
    const h = (n & 1) !== 0, f = (n & 2) !== 0, d = (n & 4) !== 0;
    let u = (n & 8) !== 0;
    const m = (n & 16) !== 0, g = (n & 32) !== 0, p = (n & 64) !== 0;
    if (Fe.debug(
      `isFace=${h} isVert=${f} isRGBA=${d} isSCALAR=${u} isDOUBLE=${m} isAOMAP=${g} isLOOKUP=${p}`
    ), n > 127)
      throw new Error("Unsupported future version of MZ3 file");
    let A = 4;
    m && (A = 8);
    let x = 0;
    if (i > 0 && !h && o < 1 && !d && (u = !0), u) {
      const E = i || l, S = 16 + c + (h ? o * 12 : 0) + (f ? E * 12 : 0) + (d ? E * 4 : 0), D = Math.floor((r.byteLength - S) / A);
      l !== i && D % i === 0 && (l = i), x = Math.floor(D / l), x < 1 && (V.warn("Corrupt MZ3: file reports NSCALAR but not enough bytes"), u = !1);
    }
    if (l < 3 && i < 3)
      throw new Error("Not a mesh MZ3 file (maybe scalar)");
    i > 0 && i !== l && V.warn("Layer has " + l + "vertices, but background mesh has " + i);
    let w = 16 + c;
    const v = new DataView(r);
    let F = null;
    if (h) {
      F = new Uint32Array(o * 3);
      for (let E = 0; E < o * 3; E++)
        F[E] = v.getUint32(w, !0), w += 4;
    }
    let C = null;
    if (f) {
      C = new Float32Array(l * 3);
      for (let E = 0; E < l * 3; E++)
        C[E] = v.getFloat32(w, !0), w += 4;
    }
    let b = null;
    if (d) {
      b = new Float32Array(l * 3);
      for (let E = 0; E < l; E++) {
        for (let S = 0; S < 3; S++)
          b[E * 3 + S] = v.getUint8(w++) / 255;
        w++;
      }
    }
    let y = new Float32Array();
    if (u && x > 0)
      if (m) {
        const E = new Float64Array(x * l);
        for (let S = 0; S < x * l; S++)
          E[S] = v.getFloat64(w, !0), w += 8;
        y = Float32Array.from(E);
      } else {
        y = new Float32Array(x * l);
        for (let E = 0; E < x * l; E++)
          y[E] = v.getFloat32(w, !0), w += 4;
      }
    if (i > 0 && p && u) {
      const E = new TextDecoder("utf-8"), S = new Uint8Array(r, 16, c), D = E.decode(S), M = JSON.parse(D), B = rt.makeLabelLut(M);
      return { scalars: y, colormapLabel: B };
    }
    if (i > 0 && d && u) {
      let E = y[0];
      for (let M = 0; M < l; M++)
        E = Math.max(E, y[M]);
      const S = { R: [], G: [], B: [], A: [], I: [], labels: [] };
      for (let M = 0; M <= E; M++)
        for (let B = 0; B < l; B++)
          if (M === y[B]) {
            const T = B * 3;
            S.I.push(M), S.R.push(b[T] * 255), S.G.push(b[T + 1] * 255), S.B.push(b[T + 2] * 255), S.A.push(255), S.labels.push(`${M}`);
            break;
          }
      const D = rt.makeLabelLut(S);
      return { scalars: y, colormapLabel: D };
    }
    return i > 0 ? { scalars: y } : { positions: C, indices: F, scalars: y, colors: b };
  }
  // read PLY format
  // https://en.wikipedia.org/wiki/PLY_(file_format)
  static readPLY(t) {
    const i = t.byteLength, s = new Uint8Array(t);
    let r = 0;
    function a() {
      for (; r < i && s[r] === 10; )
        r++;
      const y = r;
      for (; r < i && s[r] !== 10; )
        r++;
      return r++, r - y < 1 ? "" : new TextDecoder().decode(t.slice(y, r - 1));
    }
    let n = a();
    if (!n.startsWith("ply"))
      throw new Error("Not a valid PLY file");
    n = a();
    const o = n.includes("ascii");
    function l(y) {
      if (y === "char" || y === "uchar" || y === "int8" || y === "uint8")
        return 1;
      if (y === "short" || y === "ushort" || y === "int16" || y === "uint16")
        return 2;
      if (y === "int" || y === "uint" || y === "int32" || y === "uint32" || y === "float" || y === "float32")
        return 4;
      if (y === "double")
        return 8;
      throw new Error("Unknown data type: " + y);
    }
    const c = n.includes("binary_little_endian");
    let h = 0, f = !1, d = 0, u = 0, m = 0, g = 0, p = 0, A = 0, x = 0;
    for (; r < i && !n.startsWith("end_header"); ) {
      if (n = a(), n.startsWith("comment"))
        continue;
      let y = n.split(/\s/);
      if (n.startsWith("element vertex"))
        for (h = parseInt(y[y.length - 1]), n = a(), y = n.split(/\s/); n.startsWith("property"); ) {
          const E = y[1];
          y[2] === "x" && E.startsWith("double") ? f = !0 : y[2] === "x" && !E.startsWith("float") && V.error("Error: expect ply xyz to be float or double: " + n), d += l(E), n = a(), y = n.split(/\s/);
        }
      if (n.startsWith("element face"))
        for (x = parseInt(y[y.length - 1]), n = a(), y = n.split(/\s/); n.startsWith("property"); ) {
          if (y[1] === "list")
            m = l(y[2]), g = l(y[3]), u += m + 3 * g;
          else {
            const E = l(y[1]);
            u += E, g === 0 && (p += E, A++);
          }
          n = a(), y = n.split(/\s/);
        }
    }
    if (o) {
      x < 1 && V.error(`Malformed ply format: faces ${x} `);
      const y = new Float32Array(h * 3);
      let E = 0;
      for (let M = 0; M < h; M++) {
        n = a();
        const B = n.split(/\s/);
        y[E] = parseFloat(B[0]), y[E + 1] = parseFloat(B[1]), y[E + 2] = parseFloat(B[2]), E += 3;
      }
      let S = new Uint32Array(x * 3), D = 0;
      for (let M = 0; M < x; M++) {
        n = a();
        const B = n.split(/\s/), T = parseInt(B[A]) - 2;
        if (T < 1)
          break;
        if (D + T * 3 > S.length) {
          const N = new Uint32Array(S.length + S.length);
          N.set(S), S = N.slice();
        }
        const U = parseInt(B[A + 1]);
        let R = parseInt(B[A + 2]);
        for (let N = 0; N < T; N++) {
          const k = parseInt(B[A + 3 + N]);
          S[D + 0] = U, S[D + 1] = R, S[D + 2] = k, R = k, D += 3;
        }
      }
      return S.length !== D && (S = S.slice(0, D)), {
        positions: y,
        indices: S
      };
    }
    (d < 12 || m < 1 || g < 1 || x < 1) && V.warn(
      `Malformed ply format: stride ${d} count ${m} iBytes ${g} iStrideBytes ${u} iPadBytes ${p} faces ${x}`
    );
    const w = new DataView(t);
    let v;
    if (r % 4 === 0 && d === 12 && c)
      v = new Float32Array(t, r, h * 3), r += h * d;
    else {
      v = new Float32Array(h * 3);
      let y = 0;
      for (let E = 0; E < h; E++)
        f ? (v[y] = w.getFloat64(r, c), v[y + 1] = w.getFloat64(r + 8, c), v[y + 2] = w.getFloat64(r + 16, c)) : (v[y] = w.getFloat32(r, c), v[y + 1] = w.getFloat32(r + 4, c), v[y + 2] = w.getFloat32(r + 8, c)), y += 3, r += d;
    }
    const F = new Uint32Array(x * 3);
    let C = !0, b = 0;
    if (m === 1 && g === 4 && u === 13)
      for (let y = 0; y < x; y++) {
        const E = w.getUint8(r);
        r += m, E !== 3 && (C = !1), F[b] = w.getUint32(r, c), r += 4, F[b + 1] = w.getUint32(r, c), r += 4, F[b + 2] = w.getUint32(r, c), r += 4, b += 3;
      }
    else {
      let y = r;
      for (let E = 0; E < x; E++) {
        r = y + p;
        let S = 0;
        m === 1 ? S = w.getUint8(r) : m === 2 ? S = w.getUint16(r, c) : m === 4 && (S = w.getUint32(r, c)), r += m, S !== 3 && (C = !1);
        for (let D = 0; D < 3; D++)
          g === 1 ? F[b] = w.getUint8(r) : g === 2 ? F[b] = w.getUint16(r, c) : g === 4 && (F[b] = w.getUint32(r, c)), b++, r += g;
        y += u;
      }
    }
    return C || V.warn("Only able to read PLY meshes limited to triangles."), {
      positions: v,
      indices: F
    };
  }
  // readPLY()
  // FreeSurfer can convert meshes to ICO/TRI format text files
  // https://github.com/dfsp-spirit/freesurferformats/blob/434962608108c75d4337d5e7a5096e3bd4ee6ee6/R/read_fs_surface.R#L1090
  // detect TRI format that uses same extension
  // http://paulbourke.net/dataformats/tri/
  static readICO(t) {
    const r = new TextDecoder("utf-8").decode(t).split(`
`);
    let a = r[0].trim().split(/\s+/);
    a.length > 1 && V.warn("This is not a valid FreeSurfer ICO/TRI mesh.");
    const n = parseInt(a[0]), o = new Float32Array(n * 3);
    let l = 1;
    for (let f = 0; f < n; f++) {
      const d = r[l].trim().split(/\s+/);
      l++;
      let u = parseInt(d[0]) - 1;
      const m = parseFloat(d[1]), g = parseFloat(d[2]), p = parseFloat(d[3]);
      if (u < 0 || u >= n) {
        V.error("ICO vertices corrupted");
        break;
      }
      u *= 3, o[u] = m, o[u + 1] = g, o[u + 2] = p;
    }
    a = r[l].trim().split(/\s+/), l++;
    const c = parseInt(a[0]), h = new Uint32Array(c * 3);
    for (let f = 0; f < c; f++) {
      const d = r[l].trim().split(/\s+/);
      l++;
      let u = parseInt(d[0]) - 1;
      const m = parseInt(d[1]) - 1, g = parseInt(d[2]) - 1, p = parseInt(d[3]) - 1;
      if (u < 0 || u >= c) {
        V.error("ICO indices corrupted");
        break;
      }
      u *= 3, h[u] = m, h[u + 1] = g, h[u + 2] = p;
    }
    for (let f = 0; f < h.length; f += 3) {
      const d = h[f];
      h[f] = h[f + 1], h[f + 1] = d;
    }
    return {
      positions: o,
      indices: h
    };
  }
  // readICO()
  // While BYU and FreeSurfer GEO are related
  // - BYU can have multiple parts
  // - BYU faces not always triangular
  // http://www.grahamwideman.com/gw/brain/fs/surfacefileformats.htm#GeoFile
  // http://www.eg-models.de/formats/Format_Byu.html
  // https://github.com/dfsp-spirit/freesurferformats/blob/dafaf88a601dac90fa3c9aae4432f003f5344546/R/read_fs_surface.R#L924
  // https://github.com/dfsp-spirit/freesurferformats/blob/434962608108c75d4337d5e7a5096e3bd4ee6ee6/R/read_fs_surface.R#L1144
  // n.b. AFNI uses the '.g' extension for this format 'ConvertSurface  -i_gii L.surf.gii -o_byu L'
  static readGEO(t, i = !1) {
    const a = new TextDecoder("utf-8").decode(t).split(`
`), n = a[0].trim().split(/\s+/), o = parseInt(n[0]);
    let l = parseInt(n[1]), c = parseInt(n[2]);
    const h = parseInt(n[3]);
    (o > 1 || h !== c * 3) && V.warn("Multi-part BYU/GEO header or not a triangular mesh.");
    const f = [];
    l *= 3;
    let d = 0, u = 2;
    for (; d < l; ) {
      const x = a[u].trim().split(/\s+/);
      u++;
      for (let w = 0; w < x.length && (f.push(parseFloat(x[w])), d++, !(d >= l)); w++)
        ;
    }
    const m = [];
    c *= 3;
    let g = 0;
    for (; g < c; ) {
      const x = a[u].trim().split(/\s+/);
      u++;
      for (let w = 0; w < x.length && (m.push(Math.abs(parseInt(x[w])) - 1), g++, !(g >= c)); w++)
        ;
    }
    if (i)
      for (let x = 0; x < m.length; x += 3) {
        const w = m[x];
        m[x] = m[x + 1], m[x + 1] = w;
      }
    const p = new Float32Array(f), A = new Uint32Array(m);
    return {
      positions: p,
      indices: A
    };
  }
  // readGEO()
  // read OFF format
  // https://en.wikipedia.org/wiki/OFF_(file_format)
  static readOFF(t) {
    const r = new TextDecoder("utf-8").decode(t).split(`
`), a = [], n = [];
    let o = 0;
    r[o].includes("OFF") ? o++ : V.warn("File does not start with OFF");
    let l = r[o].trim().split(/\s+/);
    const c = parseInt(l[0]), h = parseInt(l[1]);
    o++;
    for (let u = 0; u < c; u++)
      l = r[o].trim().split(/\s+/), a.push(parseFloat(l[0])), a.push(parseFloat(l[1])), a.push(parseFloat(l[2])), o++;
    for (let u = 0; u < h; u++)
      l = r[o].trim().split(/\s+/), parseInt(l[0]) !== 3 && V.warn("Only able to read OFF files with triangular meshes"), n.push(parseInt(l[1])), n.push(parseInt(l[2])), n.push(parseInt(l[3])), o++;
    const f = new Float32Array(a), d = new Uint32Array(n);
    return {
      positions: f,
      indices: d
    };
  }
  // readOFF()
  static readOBJMNI(t) {
    const r = new TextDecoder("utf-8").decode(t).trim().split(/\s*,\s*|\s+/);
    (r.length < 1 || r[0] !== "P") && V.warn("This is not a valid MNI OBJ mesh.");
    let a = 6;
    const n = parseInt(r[a++]), o = n * 3, l = new Float32Array(o);
    for (let m = 0; m < o; m++)
      l[m] = parseFloat(r[a++]);
    a += o;
    const c = parseInt(r[a++]), h = parseInt(r[a++]);
    (c < 1 || h < 0 || h > 2) && V.warn("This is not a valid MNI OBJ mesh.");
    let f = 1;
    h === 1 ? f = c : h === 1 && (f = n), a += f * 4, a += c;
    const d = c * 3, u = new Uint32Array(d);
    for (let m = 0; m < d; m++)
      u[m] = parseInt(r[a++]);
    return {
      positions: l,
      indices: u
    };
  }
  // readOBJMNI()
  static async readOBJ(t) {
    const i = new Uint8Array(t, 0, 2);
    i[0] === 31 && i[1] === 139 && (t = await H.decompressToBuffer(new Uint8Array(t)));
    const r = new TextDecoder("utf-8").decode(t);
    if (r[0] === "P")
      return this.readOBJMNI(t);
    const a = r.split(`
`), n = a.length, o = [], l = [];
    for (let u = 0; u < n; u++) {
      const m = a[u];
      if (m[0] === "v" && m[1] === " ") {
        const g = m.trim().split(/\s+/);
        o.push(parseFloat(g[1])), o.push(parseFloat(g[2])), o.push(parseFloat(g[3]));
      }
      if (m[0] === "f") {
        const g = m.trim().split(/\s+/), p = g.length - 3;
        if (p < 1)
          break;
        let A = g[1].split("/");
        const x = parseInt(A[0]) - 1;
        A = g[2].split("/");
        let w = parseInt(A[0]) - 1;
        for (let v = 0; v < p; v++) {
          A = g[3 + v].split("/");
          const F = parseInt(A[0]) - 1;
          l.push(x), l.push(w), l.push(F), w = F;
        }
      }
    }
    const c = new Float32Array(o), h = new Uint32Array(l);
    let f = h[0], d = h[0];
    for (let u = 1; u < h.length; u++)
      h[u] < f && (f = h[u]), h[u] > d && (d = h[u]);
    if (d - f + 1 > c.length / 3)
      throw new Error("Not a valid OBJ file");
    for (let u = 0; u < h.length; u++)
      h[u] -= f;
    return {
      positions: c,
      indices: h
    };
  }
  // readOBJ()
  // read FreeSurfer big endian format
  static readFreeSurfer(t) {
    const i = new Uint8Array(t);
    if (i[0] === 35 && i[1] === 33 && i[2] === 97)
      return pt.readASC(t);
    const s = new DataView(t), r = s.getUint32(0, !1), a = s.getUint32(4, !1);
    (r !== 4294966883 || a !== 1919246708) && Fe.debug("Unable to recognize file type: does not appear to be FreeSurfer format.");
    let n = 0;
    for (; s.getUint8(n) !== 10; )
      n++;
    n += 2;
    let o = s.getUint32(n, !1);
    n += 4;
    let l = s.getUint32(n, !1);
    n += 4, o *= 3;
    const c = new Float32Array(o);
    for (let u = 0; u < o; u++)
      c[u] = s.getFloat32(n, !1), n += 4;
    l *= 3;
    const h = new Uint32Array(l);
    for (let u = 0; u < l; u++)
      h[u] = s.getUint32(n, !1), n += 4;
    const f = s.getUint32(n, !1);
    n += 4;
    let d = f === 20;
    if (!d) {
      const u = s.getUint32(n, !1);
      n += 4;
      const m = s.getUint32(n, !1);
      n += 4, d = f === 2 && u === 0 && m === 20;
    }
    if (!d)
      V.warn("Unknown FreeSurfer Mesh extension code.");
    else {
      const m = new TextDecoder().decode(t.slice(n)).trim().split(`
`);
      for (let g = 0; g < m.length; g++) {
        if (!m[g].startsWith("cras"))
          continue;
        const A = m[g].split("=")[1].trim().split(" ").map(Number), x = Math.floor(c.length / 3);
        let w = 0;
        for (let v = 0; v < x; v++)
          c[w] += A[0], w++, c[w] += A[1], w++, c[w] += A[2], w++;
      }
    }
    return {
      positions: c,
      indices: h
    };
  }
  // readFreeSurfer()
  // read brainvoyager SRF format
  // https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/344-users-guide-2-3-the-format-of-srf-files
  static async readSRF(t) {
    const i = new Uint8Array(t);
    if (i[0] === 35 && i[1] === 33 && i[2] === 97)
      return pt.readASC(t);
    i[0] === 31 && i[1] === 139 && (t = (await H.decompress(new Uint8Array(t))).buffer);
    const s = new DataView(t), r = s.getFloat32(0, !0), a = s.getUint32(8, !0), n = s.getUint32(12, !0), o = s.getFloat32(16, !0), l = s.getFloat32(20, !0), c = s.getFloat32(24, !0), h = new Float32Array(a * 3);
    let f = 28, d = 1;
    for (let C = 0; C < a; C++)
      h[d] = -s.getFloat32(f, !0) + o, d += 3, f += 4;
    d = 2;
    for (let C = 0; C < a; C++)
      h[d] = -s.getFloat32(f, !0) + l, d += 3, f += 4;
    d = 0;
    for (let C = 0; C < a; C++)
      h[d] = -s.getFloat32(f, !0) + c, d += 3, f += 4;
    f = 28 + 4 * 6 * a;
    const u = s.getFloat32(f, !0), m = s.getFloat32(f + 4, !0), g = s.getFloat32(f + 8, !0), p = s.getFloat32(f + 16, !0), A = s.getFloat32(f + 20, !0), x = s.getFloat32(f + 24, !0);
    f += 8 * 4;
    const w = new Float32Array(a * 3), v = new Uint32Array(t, f, a);
    d = 0;
    for (let C = 0; C < a; C++) {
      const b = v[C];
      b > 1056964608 && (w[d + 0] = (b >> 16 & 255) / 255, w[d + 1] = (b >> 8 & 255) / 255, w[d + 2] = (b & 255) / 255), b === 0 && (w[d + 0] = u, w[d + 1] = m, w[d + 2] = g), b === 1 && (w[d + 0] = p, w[d + 1] = A, w[d + 2] = x), d += 3;
    }
    f += a * 4;
    for (let C = 0; C < a; C++) {
      const b = s.getUint32(f, !0);
      f += 4 + 4 * b;
    }
    const F = new Uint32Array(n * 3);
    for (let C = 0; C < n * 3; C++)
      F[C] = s.getInt32(f, !0), f += 4;
    return r !== 4 && V.warn("Not valid SRF"), {
      positions: h,
      indices: F,
      colors: w
    };
  }
  // readSRF()
  // read STL ASCII format file
  // http://paulbourke.net/dataformats/stl/
  static readTxtSTL(t) {
    const r = new TextDecoder("utf-8").decode(t).split(`
`);
    if (!r[0].startsWith("solid"))
      throw new Error("Not a valid STL file");
    const a = [];
    for (let c = 1; c < r.length; c++) {
      if (!r[c].includes("vertex"))
        continue;
      const h = r[c].trim().split(/\s+/);
      for (let f = 1; f < h.length; f++)
        a.push(parseFloat(h[f]));
    }
    const n = Math.floor(a.length / 3);
    if (n * 3 !== a.length)
      throw new Error("Unable to parse ASCII STL file.");
    const o = new Float32Array(a), l = new Uint32Array(n);
    for (let c = 0; c < n; c++)
      l[c] = c;
    return {
      positions: o,
      indices: l
    };
  }
  // readTxtSTL()
  // read STL format, nb this format does not reuse vertices
  // https://en.wikipedia.org/wiki/STL_(file_format)
  static readSTL(t) {
    if (t.byteLength < 134)
      throw new Error("File too small to be STL: bytes = " + t.byteLength);
    const i = new DataView(t);
    if (i.getUint32(0, !0) === 1768714099)
      return pt.readTxtSTL(t);
    const r = i.getUint32(80, !0), a = 3 * r;
    if (t.byteLength < 84 + r * 50)
      throw new Error("STL file too small to store triangles = " + r);
    const n = new Uint32Array(a), o = new Float32Array(a * 3);
    let l = 96, c = 0;
    for (let h = 0; h < r; h++) {
      for (let f = 0; f < 9; f++)
        o[c] = i.getFloat32(l, !0), c += 1, l += 4;
      l += 14;
    }
    for (let h = 0; h < a; h++)
      n[h] = h;
    return {
      positions: o,
      indices: n
    };
  }
  // readSTL()
  static decimateLayerVertices(t, i) {
    if (t % i === 0)
      return t;
    const s = 12, r = Math.round(Math.log((t - 2) / (s - 2)) / Math.log(4)), a = Math.round(Math.log((i - 2) / (s - 2)) / Math.log(4)), n = Math.pow(4, r) * (s - 2) + 2, o = Math.pow(4, a) * (s - 2) + 2;
    return n !== t || o !== i ? t : i;
  }
  // read NIfTI2 format with embedded CIfTI
  // this variation very specific to connectome workbench
  // https://brainder.org/2015/04/03/the-nifti-2-file-format/
  static async readNII2(t, i = 0, s = "") {
    let r = new Float32Array();
    const a = t.byteLength;
    let n = !0;
    const o = new DataView(t);
    let l = o.getUint16(0, n);
    if (l === 469893120 && (n = !1, l = o.getUint16(0, n)), l !== 540)
      throw new Error("Not a valid NIfTI-2 dataset");
    const c = Number(o.getBigInt64(168, n)), h = o.getFloat64(176, n), f = o.getFloat64(184, n);
    (h !== 1 || f !== 0) && V.warn("ignoring scale slope and intercept");
    const d = o.getUint32(504, n), u = o.getUint16(12, n);
    if (u !== 2 && u !== 4 && u !== 8 && u !== 16)
      throw new Error("Unsupported NIfTI datatype " + u);
    let m = 1;
    const g = [1, 1, 1, 1, 1, 1, 1, 1];
    for (let p = 1; p < 8; p++)
      g[p] = Math.max(Number(o.getBigInt64(16 + p * 8, n)), 1), m *= g[p];
    if (d >= 3e3 && d <= 3099 && c > 580) {
      let p = function() {
        for (; E < a && y[E] === 10; )
          E++;
        const R = E;
        for (; E < a && y[E] !== 10; )
          E++;
        return E++, E - R < 1 ? "" : new TextDecoder().decode(t.slice(R, E - 1)).trim();
      }, A = function() {
        let R = p();
        if (!R.startsWith("<") || R.endsWith(">"))
          return R;
        for (; E < a && !R.endsWith(">"); )
          R += p();
        return R;
      }, x = function(R, N = !1) {
        const k = S.indexOf(R);
        if (k < 0)
          return 1;
        const L = S.indexOf('"', k) + 1, q = S.indexOf('"', L), _ = S.slice(L, q);
        return N ? _ : parseInt(_);
      }, w = 0, v = 0, F = 0, C = "", b = new Uint32Array();
      const y = new Uint8Array(t);
      let E = 552, S;
      const D = g[5], M = new Float32Array(i * D);
      for (; E < a && (S = A(), !S.includes("</CIFTI>")); )
        if (S.includes("<BrainModel")) {
          const R = x("SurfaceNumberOfVertices="), N = x("BrainStructure=", !0).toUpperCase();
          if (R % i !== 0)
            continue;
          let k = !1;
          if (s.includes("CORTEX") && N.includes("CORTEX") && (k = !0), !k || (k = !1, s.includes("LEFT") && N.includes("LEFT") && (k = !0), s.includes("RIGHT") && N.includes("RIGHT") && (k = !0), !k))
            continue;
          if (F = R, w = x("IndexOffset="), v = x("IndexCount="), C = N, S.includes("<VertexIndices>") || (S = A()), !S.startsWith("<VertexIndices>") || !S.endsWith("</VertexIndices>"))
            return V.warn("Unable to find CIfTI <VertexIndices>"), M;
          S = S.slice(15, -16);
          const L = S.trim().split(/\s+/);
          L.length < v && V.error("Error parsing VertexIndices"), b = new Uint32Array(v);
          for (let q = 0; q < v; q++)
            b[q] = parseInt(L[q]);
        }
      if (F === 0 || b.length === 0)
        return V.warn("Unable to find CIfTI structure that matches the mesh."), M;
      if (u !== 16)
        return V.warn("Only able to read float32 CIfTI (only known datatype)."), M;
      const B = new Float32Array(v * D), T = c + D * w * 4;
      for (let R = 0; R < v * D; R++)
        B[R] = o.getFloat32(T + R * 4, n);
      let U = 0;
      for (let R = 0; R < v; R++)
        for (let N = 0; N < D; N++)
          M[b[R] + N * i] = B[U], U++;
      return V.debug(
        "CIfTI diagnostics",
        F,
        C,
        w,
        v,
        w,
        s
      ), M;
    }
    if (m = this.decimateLayerVertices(m, i), m % i !== 0)
      throw new Error("Vertices in layer (" + m + ") is not a multiple of number of vertices (" + i + ")");
    if (n)
      u === 16 ? r = new Float32Array(t, c, m) : u === 8 ? r = new Int32Array(t, c, m) : u === 4 && (r = new Int16Array(t, c, m));
    else if (u === 16) {
      r = new Float32Array(m);
      for (let p = 0; p < m; p++)
        r[p] = o.getFloat32(c + p * 4, n);
    } else if (u === 8) {
      r = new Int32Array(m);
      for (let p = 0; p < m; p++)
        r[p] = o.getInt32(c + p * 4, n);
    } else if (u === 4) {
      r = new Int16Array(m);
      for (let p = 0; p < m; p++)
        r[p] = o.getInt16(c + p * 2, n);
    }
    return u === 2 && (r = new Uint8Array(t, c, m)), r;
  }
  // readNII2()
  // read NIfTI1/2 as vertex colors
  // https://brainder.org/2012/09/23/the-nifti-file-format/#:~:text=In%20the%20nifti%20format%2C%20the,seventh%2C%20are%20for%20other%20uses.
  static async readNII(t, i, s = "") {
    const r = i.length / 3;
    let a = new Float32Array(), n = !0, o = new DataView(t), l = o.getUint16(0, n);
    if (l === 540 || l === 469893120)
      return pt.readNII2(t, r, s);
    if (l === 23553 && (n = !1, l = o.getUint16(0, n)), l !== 348) {
      const v = await H.decompress(new Uint8Array(t));
      if (o = new DataView(v.buffer), t = v.buffer, l = o.getUint16(0, n), l === 540 || l === 469893120)
        return pt.readNII2(t, r, s);
      l === 23553 && (n = !1, l = o.getUint16(0, n));
    }
    l !== 348 && V.error("Not a valid NIfTI image.");
    const c = o.getFloat32(108, n), h = o.getFloat32(112, n), f = o.getFloat32(116, n), d = o.getUint16(252, n), u = o.getUint16(254, n), m = o.getUint16(70, n);
    if (m !== 2 && m !== 4 && m !== 8 && m !== 16)
      throw new Error("Unsupported NIfTI datatype " + m);
    const g = it();
    for (let v = 0; v < 12; v++)
      g[v] = o.getFloat32(280 + v * 4, n);
    let p = 1;
    const A = new Array(8);
    for (let v = 0; v < 8; v++)
      A[v] = o.getUint16(40 + v * 2, n), !(v < 1) && (p *= A[v] || 1);
    let x = !1, w = this.decimateLayerVertices(p, r);
    if (w % r !== 0)
      if (A[0] >= 3 && A[1] > 1 && A[2] > 1 && A[3] > 1)
        x = !0, w = A[1] * A[2] * A[3];
      else
        throw new Error("Voxels in layer (" + p + ") is not a multiple of number of vertices (" + r + ")");
    if (p = w, n)
      m === 16 ? a = new Float32Array(t, c, p) : m === 8 ? a = new Int32Array(t, c, p) : m === 4 && (a = new Int16Array(t, c, p));
    else if (m === 16) {
      a = new Float32Array(p);
      for (let v = 0; v < p; v++)
        a[v] = o.getFloat32(c + v * 4, n);
    } else if (m === 8) {
      a = new Int32Array(p);
      for (let v = 0; v < p; v++)
        a[v] = o.getInt32(c + v * 4, n);
    } else if (m === 4) {
      a = new Int16Array(p);
      for (let v = 0; v < p; v++)
        a[v] = o.getInt16(c + v * 2, n);
    }
    if (m === 2 && (a = new Uint8Array(t, c, p)), h !== 1 || f !== 0) {
      const v = new Float32Array(p);
      for (let F = 0; F < p; F++)
        v[F] = a[F] * h + f;
      a = v;
    }
    for (let v = 0; v < p; v++)
      isNaN(a[v]) && (a[v] = 0);
    if (x) {
      let v = function(U, R) {
        const N = [0, 0, 0];
        return N[0] = R[0] * U[0] + R[1] * U[1] + R[2] * U[2] + R[3], N[1] = R[4] * U[0] + R[5] * U[1] + R[6] * U[2] + R[7], N[2] = R[8] * U[0] + R[9] * U[1] + R[10] * U[2] + R[11], N;
      };
      const F = new Float32Array(p);
      V.warn("Sampling voxel intensities at mesh vertices (assumes precise alignment)."), (d > u || u <= 0) && V.warn(`Requires valid sform (sform_code = ${u})`);
      const C = it();
      Vt(C, g);
      const b = A[1], y = A[2], E = A[3], S = b * y;
      let D = 0, M = 0, B = 0;
      for (; M < r; ) {
        const U = [i[D], i[D + 1], i[D + 2]], R = v(U, C);
        D += 3, M += 1;
        const N = Math.floor(R[0]), k = Math.floor(R[1]), L = Math.floor(R[2]), q = Math.ceil(R[0]), _ = Math.ceil(R[1]), z = Math.ceil(R[2]);
        if (N < 0 || q >= b || k < 0 || _ >= y || L < 0 || z >= E)
          continue;
        const K = N + k * b + L * S, W = new Float32Array(8);
        W[0] = a[K], W[1] = a[K + 1], W[2] = a[K + b], W[3] = a[K + b + 1], W[4] = a[K + S], W[5] = a[K + S + 1], W[6] = a[K + S + b], W[7] = a[K + S + b + 1];
        let $ = W[0], tt = $;
        for (let at = 1; at < 8; at++)
          $ = Math.max($, W[at]), tt = Math.min(tt, W[at]);
        Math.abs(tt) > $ && ($ = tt), F[M - 1] = $, B++;
      }
      const T = B / r;
      T < 0.1 && V.warn(`${B} of ${r} vertices in range (${(T * 100).toFixed(1)}%)`), a = F;
    }
    return a;
  }
  // readNII();
  // read MGH format as vertex colors (not voxel-based image)
  // https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/MghFormat
  static async readMGH(t, i = 0, s = !1) {
    let r = new DataView(t), a = t;
    if (r.getUint8(0) === 31 && r.getUint8(1) === 139) {
      const b = await H.decompress(new Uint8Array(t));
      a = new ArrayBuffer(b.byteLength), new Uint8Array(a).set(new Uint8Array(b)), r = new DataView(b.buffer);
    }
    const n = r.getInt32(0, !1), o = Math.max(1, r.getInt32(4, !1)), l = Math.max(1, r.getInt32(8, !1)), c = Math.max(1, r.getInt32(12, !1)), h = Math.max(1, r.getInt32(16, !1)), f = r.getInt32(20, !1);
    let d = 284;
    const u = !1;
    (n !== 1 || f < 0 || f > 4) && V.warn("Not a valid MGH file");
    let m = o * l * c * h, g = [];
    if (m = this.decimateLayerVertices(m, i), m % i !== 0)
      return V.warn("Vertices in layer (" + m + ") is not a multiple of number of vertices (" + i + ")"), g;
    if (f === 3) {
      g = new Float32Array(m);
      for (let b = 0; b < m; b++)
        g[b] = r.getFloat32(d + b * 4, u);
    } else if (f === 1) {
      g = new Int32Array(m);
      for (let b = 0; b < m; b++)
        g[b] = r.getInt32(d + b * 4, u);
    } else if (f === 4) {
      g = new Int16Array(m);
      for (let b = 0; b < m; b++)
        g[b] = r.getInt16(d + b * 2, u);
    } else f === 0 && (g = new Uint8Array(t, d, m));
    if (!s)
      return g;
    let p = 4;
    f === 4 && (p = 2), f === 0 && (p = 1), d += p * m, d += 4 * 4;
    const A = 1, x = 2, w = 20, v = 30, F = a.byteLength;
    let C;
    for (; d < F - 8; ) {
      const b = r.getInt32(d += 4, u);
      let y = 0;
      switch (b) {
        case v:
          y = r.getInt32(d += 4, u) - 1;
          break;
        case w:
        case x:
          y = 0;
          break;
        case A:
          y = 0;
          {
            let E = r.getInt32(d += 4, u);
            if (E > 0)
              return V.warn("unsupported CTABreadFromBinaryV1"), g;
            if (E = -E, E !== 2)
              return V.warn("CTABreadFromBinary: unknown version"), g;
            const S = r.getInt32(d += 4, u);
            if (S < 0)
              return V.warn("CTABreadFromBinaryV2: nentries was ", S), g;
            const D = r.getInt32(d += 4, u);
            d += D;
            const M = r.getInt32(d += 4, u);
            if (M < 0)
              return g;
            const B = { R: [], G: [], B: [], A: [], I: [], labels: [] };
            for (let T = 0; T < M; T++) {
              const U = r.getInt32(d += 4, u), R = r.getInt32(d += 4, u);
              let N = d + 4, k = "";
              for (let K = 0; K < R; K++) {
                const W = r.getUint8(N++);
                if (W === 0)
                  break;
                k += String.fromCharCode(W);
              }
              d += R;
              const L = r.getInt32(d += 4, u), q = r.getInt32(d += 4, u), _ = r.getInt32(d += 4, u), z = 255 - r.getInt32(d += 4, u);
              B.I.push(U), B.R.push(L), B.G.push(q), B.B.push(_), B.A.push(z), B.labels.push(k);
            }
            C = rt.makeLabelLut(B);
          }
          break;
        default:
          y = r.getInt32(d += 8, u);
      }
      d += y;
    }
    return {
      scalars: g,
      colormapLabel: C
      // TODO can we guarantee this?
    };
  }
  // readMGH()
  // read X3D format mesh
  // https://en.wikipedia.org/wiki/X3D
  static readX3D(t) {
    const i = t.byteLength;
    if (i < 20)
      throw new Error("File too small to be X3D: bytes = " + i);
    const s = new Uint8Array(t);
    let r = 0;
    function a() {
      for (; r < i && s[r] !== 60; )
        r++;
      const w = r;
      for (; r < i && s[r] !== 62; )
        r++;
      const v = r;
      return new TextDecoder().decode(t.slice(w, v + 1)).trim();
    }
    let n = a();
    function o(w) {
      const v = n.indexOf(w + "=");
      if (v < 0)
        return "";
      const F = n[v + w.length + 1], C = n.indexOf(F, v) + 1, b = n.indexOf(F, C);
      return n.slice(C, b);
    }
    function l(w) {
      const v = n.indexOf(w + "=");
      if (v < 0)
        return 1;
      const F = n[v + w.length + 1], C = n.indexOf(F, v) + 1, b = n.indexOf(F, C);
      let y = n.slice(C, b).trim();
      y = y.replace(/,\s*$/, "");
      const E = y.trim().split(/\s*,\s*|\s+/);
      if (E.length < 2)
        return parseFloat(y);
      let S = new Array(E.length), D = 0;
      for (let M = 0; M < E.length; M++) {
        const B = parseFloat(E[M]);
        isFinite(B) && (S[D] = B, D++);
      }
      return S = S.slice(0, D), S;
    }
    n.includes("xml version") || V.warn("Not a X3D image");
    let c = [], h = [], f = [], d = [], u = [0, 0, 0, 0], m = [0, 0, 0, 0], g = [255, 255, 255, 255], p = [255, 255, 255, 255];
    const A = {};
    function x() {
      if (!n.endsWith("/>"))
        if (n.startsWith("<Appearance>"))
          for (; r < i && !n.endsWith("</Appearance>"); )
            n += a();
        else
          for (; r < i && !n.endsWith("/>"); )
            n += a();
      const w = o("USE");
      if (w.length > 1) {
        w in A ? g = A[w] : V.warn("Unable to find DEF for " + w);
        return;
      }
      const v = l("diffuseColor");
      if (v.length < 3)
        return;
      g[0] = Math.round(v[0] * 255), g[1] = Math.round(v[1] * 255), g[2] = Math.round(v[2] * 255);
      const F = o("DEF");
      F.length < 1 || (A[F] = g);
    }
    for (; r < i; )
      if (n = a(), g = p.slice(), n.startsWith("<Transform") && (u = l("translation"), m = l("rotation")), n.startsWith("<Appearance") && (x(), p = g.slice()), n.startsWith("<Shape")) {
        let w = 1, v = 1, F = [], C = [];
        for (; r < i && (n = a(), n.startsWith("<Appearance") && x(), !n.startsWith("</Shape")); ) {
          if (n.startsWith("<Sphere") && (w = l("radius"), v = -1), n.startsWith("<Cylinder") && (w = l("radius"), v = l("height")), n.startsWith("<IndexedFaceSet") && (v = -2, F = l("coordIndex")), n.startsWith("<IndexedTriangleSet") && (v = -7, F = l("index")), n.startsWith("<IndexedTriangleStripSet") && (v = -3, F = l("index")), n.startsWith("<Coordinate")) {
            C = l("point");
            const b = C.length % 3;
            b !== 0 && (C = C.slice(0, -b));
          }
          n.startsWith("<Color") && (d = l("color")), n.startsWith("<Box") && (v = -4, V.warn("Unsupported x3d shape: Box")), n.startsWith("<Cone") && (v = -5, V.warn("Unsupported x3d shape: Cone")), n.startsWith("<ElevationGrid") && (v = -6, V.warn("Unsupported x3d shape: ElevationGrid"));
        }
        if (!(v < -3 && v !== -7)) if (v < -1) {
          if (F.length < 1 || C.length < 3 || C.length === void 0) {
            V.warn("Indexed mesh must specify indices and points");
            break;
          }
          const b = Math.floor(c.length / 3);
          let y = 2;
          if (v === -7)
            h = [...h, ...F];
          else if (v === -2) {
            let D = 0;
            for (; y < F.length; )
              F[y] >= 0 ? (h.push(F[D] + b), h.push(F[y - 1] + b), h.push(F[y - 0] + b), y += 1) : (y += 3, D = y - 2);
          } else
            for (; y < F.length; )
              F[y] >= 0 ? (h.push(F[y - 2] + b), h.push(F[y - 1] + b), h.push(F[y - 0] + b), y += 1) : y += 3;
          c = [...c, ...C];
          const E = Math.floor(C.length / 3), S = Array(E).fill(g).flat();
          if (d.length === E * 3) {
            let D = 0, M = 0;
            for (let B = 0; B < E; B++) {
              for (let T = 0; T < 3; T++)
                S[M] = Math.round(d[D] * 255), D++, M++;
              M++;
            }
          }
          f = [...f, ...S];
        } else if (v < 0)
          he.makeColoredSphere(c, h, f, w, u, g);
        else {
          const b = it();
          kn(b, m[3], [m[0], m[1], m[2]]);
          const y = ht(0, -v * 0.5, 0, 1), E = ht(0, +v * 0.5, 0, 1);
          Ct(y, y, b), Ct(E, E, b), zs(y, y, u), zs(E, E, u);
          const S = O(y[0], y[1], y[2]), D = O(E[0], E[1], E[2]);
          he.makeColoredCylinder(c, h, f, S, D, w, g);
        }
      }
    return {
      positions: Float32Array.from(c),
      indices: Uint32Array.from(h),
      rgba255: Uint8Array.from(f)
    };
  }
  // readX3D()
  // read GIfTI format mesh
  // https://www.nitrc.org/projects/gifti/
  static async readGII(t, i = 0) {
    let s = t.byteLength;
    if (s < 20)
      throw new Error("File too small to be GII: bytes = " + s);
    let r = new TextDecoder("ascii").decode(t);
    if (r[0].charCodeAt(0) === 31) {
      const M = await H.decompress(new Uint8Array(t));
      t = M.buffer, r = new TextDecoder("ascii").decode(M.buffer);
    }
    let a = 0;
    function n() {
      let M = !0, B = a;
      for (; M; ) {
        for (; a < s && r[a] !== "<"; )
          a++;
        for (B = a; a < s && r[a] !== ">"; )
          a++;
        if (M = r[a - 1] === "/", B + 1 < s && r[B + 1] === "/" && (a += 1, M = !0), a >= s)
          break;
      }
      const T = new TextDecoder().decode(t.slice(B + 1, a)).trim(), U = T.split(" ")[0].trim(), R = a;
      let N = a, k = a;
      if (r[B + 1] !== "?" && r[B + 1] !== "!") {
        const L = "</" + U + ">";
        N = r.indexOf(L, R), k = N + L.length - 1;
      }
      return {
        name: T,
        startPos: B,
        contentStartPos: R,
        contentEndPos: N,
        endPos: k
      };
    }
    let o = n();
    if (!o.name.startsWith("?xml"))
      throw new Error("readGII: Invalid XML file");
    for (; !o.name.startsWith("GIFTI") && o.endPos < s; )
      o = n();
    if (!o.name.startsWith("GIFTI") || o.contentStartPos === o.contentEndPos)
      throw new Error("readGII: XML file does not include GIFTI tag");
    s = o.contentEndPos;
    let l = new Float32Array(), c = new Uint32Array(), h = new Float32Array(), f = "", d = !1, u = !1, m = !1, g = !1, p = [1, 1, 1];
    const A = [0, 0, 0];
    let x = 0, w = !1, v = !1, F = 0, C = !1;
    o.endPos = o.contentStartPos;
    let b = "";
    function y(M, B = !1) {
      const T = b.indexOf(M);
      if (T < 0)
        return 1;
      const U = b.indexOf('"', T) + 1, R = b.indexOf('"', U), N = b.slice(U, R);
      return B ? parseFloat(N) : parseInt(N);
    }
    function E(M) {
      const B = b.indexOf(M);
      if (B < 0)
        return "";
      const T = B + M.length, U = b.indexOf("]", T);
      return b.slice(T, U);
    }
    const S = { R: [], G: [], B: [], A: [], I: [], labels: [] };
    for (; o.endPos < s && o.name.length > 1; ) {
      if (o = n(), o.name.startsWith("Label Key") && (b = o.name, S.I.push(y("Key=")), S.R.push(Math.round(255 * y("Red=", !0))), S.G.push(Math.round(255 * y("Green=", !0))), S.B.push(Math.round(255 * y("Blue=", !0))), S.A.push(Math.round(255 * y("Alpha", !0))), b = new TextDecoder().decode(t.slice(o.contentStartPos + 1, o.contentEndPos)).trim(), S.labels.push(E("<![CDATA["))), o.name.trim() === "Data") {
        if (m)
          continue;
        b = new TextDecoder().decode(t.slice(o.contentStartPos + 1, o.contentEndPos)).trim();
        let M;
        if (v) {
          const B = p[0] * p[1] * p[2], T = b.split(/\s+/);
          if (B !== T.length)
            throw new Error("Unable to parse ASCII GIfTI");
          if (x === 2 && (x = 8), x === 32 && (x = 16), x === 8) {
            M = new Int32Array(B);
            for (let U = 0; U < B; U++)
              M[U] = parseInt(T[U]);
          }
          if (x === 16) {
            M = new Float32Array(B);
            for (let U = 0; U < B; U++)
              M[U] = parseFloat(T[U]);
          }
        } else if (typeof Buffer > "u") {
          let B = function(T) {
            const U = atob(T), R = U.length, N = new Uint8Array(R);
            for (let k = 0; k < R; k++)
              N[k] = U.charCodeAt(k);
            return N;
          };
          if (w) {
            const T = B(b.slice());
            M = await H.decompress(new Uint8Array(T));
          } else
            M = B(b.slice());
        } else if (w) {
          const B = Buffer.from(b.slice(), "base64");
          M = await H.decompress(new Uint8Array(B));
        } else
          M = Buffer.from(b.slice(), "base64");
        if (u) {
          if (x !== 16 && V.warn("expect positions as FLOAT32"), l = new Float32Array(M.buffer), g) {
            const B = l.slice(), T = B.length / 3;
            let U = 0;
            for (let R = 0; R < T; R++)
              for (let N = 0; N < 3; N++)
                l[U] = B[N * T + R], U++;
          }
        } else if (d) {
          if (x !== 8 && V.warn("expect indices as INT32"), c = new Uint32Array(M.buffer), g) {
            const B = c.slice(), T = B.length / 3;
            let U = 0;
            for (let R = 0; R < T; R++)
              for (let N = 0; N < 3; N++)
                c[U] = B[N * T + R], U++;
          }
        } else {
          let B = function(U, R) {
            const N = U.length, k = new Float32Array(N + R.length);
            return k.set(U), k.set(R, N), k;
          };
          F = p[0] * p[1] * p[2], i !== 0 && F % i !== 0 && V.warn("Number of vertices in scalar overlay (" + F + ") does not match mesh (" + i + ")");
          let T;
          if (x === 2) {
            const U = new Uint8Array(M.buffer);
            T = Float32Array.from(U);
          } else if (x === 8) {
            const U = new Int32Array(M.buffer);
            T = Float32Array.from(U);
          } else if (x === 16)
            T = new Float32Array(M.buffer);
          else if (x === 32) {
            const U = new Float64Array(M.buffer);
            T = Float32Array.from(U);
          } else
            throw new Error(`Invalid dataType: ${x}`);
          h = B(h, T);
        }
        continue;
      }
      if (o.name.trim() === "DataSpace" && (b = new TextDecoder().decode(t.slice(o.contentStartPos + 1, o.contentEndPos)).trim(), b.includes("NIFTI_XFORM_SCANNER_ANAT") && (C = !0)), o.name.trim() === "MD" && (b = new TextDecoder().decode(t.slice(o.contentStartPos + 1, o.contentEndPos)).trim(), b.includes("AnatomicalStructurePrimary") && b.includes("CDATA[") && (f = E("<Value><![CDATA[").toUpperCase()), b.includes("VolGeom") && b.includes("CDATA["))) {
        let M = -1;
        if (b.includes("VolGeomC_R") && (M = 0), b.includes("VolGeomC_A") && (M = 1), b.includes("VolGeomC_S") && (M = 2), M < 0)
          continue;
        A[M] = parseFloat(E("<Value><![CDATA["));
      }
      o.name.startsWith("DataArray") && (b = o.name, p = [1, 1, 1], w = b.includes('Encoding="GZipBase64Binary"'), v = b.includes('Encoding="ASCII"'), d = b.includes('Intent="NIFTI_INTENT_TRIANGLE"'), u = b.includes('Intent="NIFTI_INTENT_POINTSET"'), m = b.includes('Intent="NIFTI_INTENT_VECTOR"'), g = b.includes('ArrayIndexingOrder="ColumnMajorOrder"'), b.includes('DataType="NIFTI_TYPE_UINT8"') && (x = 2), b.includes('DataType="NIFTI_TYPE_INT32"') && (x = 8), b.includes('DataType="NIFTI_TYPE_FLOAT32"') && (x = 16), b.includes('DataType="NIFTI_TYPE_FLOAT64"') && (x = 32), p[0] = y("Dim0="), p[1] = y("Dim1="), p[2] = y("Dim2="));
    }
    let D;
    if (S.I.length > 1 && (S.A.some((B) => B > 0) || S.A.fill(255), D = rt.makeLabelLut(S)), i > 0)
      return { scalars: h, colormapLabel: D, anatomicalStructurePrimary: f };
    if (l.length > 2 && !C && (A[0] !== 0 || A[1] !== 0 || A[2] !== 0)) {
      F = Math.floor(l.length / 3);
      let M = 0;
      for (let B = 0; B < F; B++)
        l[M] += A[0], M++, l[M] += A[1], M++, l[M] += A[2], M++;
    }
    return {
      positions: l,
      indices: c,
      scalars: h,
      colormapLabel: D,
      anatomicalStructurePrimary: f
    };
  }
  // readGII()
}, Es = class {
  /**
   * @param text - The text of the label
   * @param style - The style of the label
   * @param points - An array of points label for label lines
   */
  constructor(e, t, i, s, r) {
    I(this, "text"), I(this, "style"), I(this, "points"), I(this, "anchor"), I(this, "onClick"), this.text = e, this.style = t, this.points = i, this.anchor = s || 0, this.onClick = r;
  }
}, ls = () => {
  const e = new ArrayBuffer(2);
  return new DataView(e).setInt16(0, 256, !0), new Int16Array(e)[0] === 256;
}, rn = /* @__PURE__ */ ((e) => (e[e.UNKNOWN = 0] = "UNKNOWN", e[e.NII = 1] = "NII", e[e.DCM = 2] = "DCM", e[e.DCM_MANIFEST = 3] = "DCM_MANIFEST", e[e.MIH = 4] = "MIH", e[e.MIF = 5] = "MIF", e[e.NHDR = 6] = "NHDR", e[e.NRRD = 7] = "NRRD", e[e.MHD = 8] = "MHD", e[e.MHA = 9] = "MHA", e[e.MGH = 10] = "MGH", e[e.MGZ = 11] = "MGZ", e[e.V = 12] = "V", e[e.V16 = 13] = "V16", e[e.VMR = 14] = "VMR", e[e.HEAD = 15] = "HEAD", e[e.DCM_FOLDER = 16] = "DCM_FOLDER", e[e.SRC = 17] = "SRC", e[e.FIB = 18] = "FIB", e[e.BMP = 19] = "BMP", e[e.ZARR = 20] = "ZARR", e[e.NPY = 21] = "NPY", e[e.NPZ = 22] = "NPZ", e[e.HDR = 23] = "HDR", e))(rn || {}), j = Object.freeze({
  ...rn,
  parse: (e) => {
    let t = 0;
    switch (e.toUpperCase()) {
      case "":
      case "DCM":
        t = 2;
        break;
      case "TXT":
        t = 3;
        break;
      case "FZ":
      case "GQI":
      case "QSDR":
      case "FIB":
        t = 18;
        break;
      case "HDR":
      case "NII":
        t = 1;
        break;
      case "MIH":
        t = 4;
        break;
      case "MIF":
        t = 5;
        break;
      case "NHDR":
        t = 6;
        break;
      case "NRRD":
        t = 7;
        break;
      case "MHD":
        t = 8;
        break;
      case "MHA":
        t = 9;
        break;
      case "MGH":
        t = 10;
        break;
      case "MGZ":
        t = 11;
        break;
      case "NPY":
        t = 21;
        break;
      case "NPZ":
        t = 22;
        break;
      case "SRC":
        t = 17;
        break;
      case "V":
        t = 12;
        break;
      case "V16":
        t = 13;
        break;
      case "VMR":
        t = 14;
        break;
      case "HEAD":
        t = 15;
        break;
      case "PNG":
      case "BMP":
      case "GIF":
      case "JPG":
      case "JPEG":
        t = 19;
        break;
      case "ZARR":
        t = 20;
        break;
    }
    return t;
  }
}), wi = (e, t = "", i = "", s = "gray", r = 1, a = NaN, n = NaN, o = !0, l = 0.02, c = !1, h = !1, f = "", d = 0, u = j.UNKNOWN, m = NaN, g = NaN, p = !0, A = !1, x = null) => ({
  url: e,
  urlImageData: t,
  name: i,
  colormap: s,
  colorMap: s,
  opacity: r,
  cal_min: a,
  cal_max: n,
  trustCalMinMax: o,
  percentileFrac: l,
  ignoreZeroVoxels: c,
  useQFormNotSForm: h,
  colormapNegative: f,
  imageType: u,
  cal_minNeg: m,
  cal_maxNeg: g,
  colorbarVisible: p,
  frame4D: d,
  alphaThreshold: A,
  colormapLabel: x
});
function nr(e, t = 80) {
  e = e.replace(/[`$]/g, "");
  const i = [], s = Math.min(t, e.length);
  for (let r = 0; r < s; r++) {
    const a = e.charCodeAt(r);
    i.push(a & 255);
  }
  return i;
}
function Mi(e, t = !1, i = !1) {
  let a = !0;
  i && (a = e.littleEndian);
  const n = new Uint8Array(348), o = new DataView(n.buffer);
  o.setInt32(0, 348, a), o.setUint8(38, 114), o.setUint8(39, e.dim_info);
  for (let c = 0; c < 8; c++)
    o.setUint16(40 + 2 * c, e.dims[c], a);
  o.setFloat32(56, e.intent_p1, a), o.setFloat32(60, e.intent_p2, a), o.setFloat32(64, e.intent_p3, a), o.setInt16(68, e.intent_code, a), t ? (o.setInt16(70, 2, a), o.setInt16(72, 8, a)) : (o.setInt16(70, e.datatypeCode, a), o.setInt16(72, e.numBitsPerVoxel, a)), o.setInt16(74, e.slice_start, a);
  for (let c = 0; c < 8; c++)
    o.setFloat32(76 + 4 * c, e.pixDims[c], a);
  t ? (o.setFloat32(108, 352, a), o.setFloat32(112, 1, a), o.setFloat32(116, 0, a)) : (o.setFloat32(108, e.vox_offset, a), o.setFloat32(112, e.scl_slope, a), o.setFloat32(116, e.scl_inter, a)), o.setInt16(120, e.slice_end, a), o.setUint8(122, e.slice_code), e.xyzt_units === 0 ? o.setUint8(123, 10) : o.setUint8(123, e.xyzt_units), t ? (o.setFloat32(124, 0, a), o.setFloat32(128, 0, a)) : (o.setFloat32(124, e.cal_max, a), o.setFloat32(128, e.cal_min, a)), o.setFloat32(132, e.slice_duration, a), o.setFloat32(136, e.toffset, a), n.set(nr(e.description), 148), n.set(nr(e.aux_file), 228), o.setInt16(252, e.qform_code, a), e.sform_code < 1 || e.sform_code < 1 ? o.setInt16(254, 1, a) : o.setInt16(254, e.sform_code, a), o.setFloat32(256, e.quatern_b, a), o.setFloat32(260, e.quatern_c, a), o.setFloat32(264, e.quatern_d, a), o.setFloat32(268, e.qoffset_x, a), o.setFloat32(272, e.qoffset_y, a), o.setFloat32(276, e.qoffset_z, a);
  const l = e.affine.flat();
  for (let c = 0; c < 12; c++)
    o.setFloat32(280 + 4 * c, l[c], a);
  return o.setInt32(344, 3222382, !0), n;
}
function ql(e, t = !0) {
  const i = Math.round(e.length / 3), s = O(0, 0, 0), r = nt(), a = nt();
  let n = 0, o = 1;
  t && (o = 2);
  for (let f = 0; f < o; f++) {
    n = 0;
    for (let u = 0; u < i; u++) {
      const m = O(e[u * 3], e[u * 3 + 1], e[u * 3 + 2]);
      u === 0 && (Ls(r, m), Ls(a, m)), hs(r, r, m), fs(a, a, m), ot(m, m, s);
      const g = Le(m);
      n = Math.max(n, g);
    }
    if (f + 1 >= o)
      break;
    let d = !0;
    for (let u = 0; u < 3; ++u)
      r[u] > s[u] && (d = !1), a[u] < s[u] && (d = !1);
    if (d)
      break;
    Xn(s, r, a, 0.5), V.debug("origin moved inside volume: ", s);
  }
  const l = [r[0], r[1], r[2]], c = [a[0], a[1], a[2]];
  return { min: l, max: c, furthestVertexFromOrigin: n, origin: s };
}
function ar(e) {
  const t = [!1, !1, !1, !1], i = [!1, !1, !1, !1];
  for (let s = 0; s < 4; s++)
    for (let r = 0; r < 4; r++)
      if (isNaN(e[s][r]))
        return !1;
  for (let s = 0; s < 3; s++)
    for (let r = 0; r < 3; r++)
      e[s][r] !== 0 && (t[s] = !0, i[r] = !0);
  for (let s = 0; s < 3; s++)
    if (!t[s] || !i[s])
      return !1;
  return !0;
}
async function Oi(e) {
  const t = e.getReader(), { done: i, value: s } = await t.read();
  if (i)
    return t.releaseLock(), new ReadableStream({
      start(n) {
        n.close();
      }
    });
  if (!s || s.length < 2)
    return t.releaseLock(), new ReadableStream({
      start(n) {
        s && n.enqueue(s), n.close();
      }
    });
  const r = s[0] === 31 && s[1] === 139, a = new ReadableStream({
    async start(n) {
      try {
        for (n.enqueue(s); ; ) {
          const { done: o, value: l } = await t.read();
          if (o) {
            n.close(), t.releaseLock();
            break;
          }
          n.enqueue(l);
        }
      } catch (o) {
        n.error(o), t.releaseLock();
      }
    }
  });
  return r ? a.pipeThrough(new DecompressionStream("gzip")) : a;
}
function nn(e = [256, 256, 256], t = [1, 1, 1], i = [1, 0, 0, -128, 0, 1, 0, -128, 0, 0, 1, -128, 0, 0, 0, 1], s = 2) {
  const r = new Z();
  r.littleEndian = !0, r.dims = [3, 1, 1, 1, 0, 0, 0, 0], r.dims[0] = Math.max(3, e.length);
  for (let n = 0; n < e.length; n++)
    r.dims[n + 1] = e[n];
  r.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  for (let n = 0; n < e.length; n++)
    r.pixDims[n + 1] = t[n];
  if (i.length === 16) {
    let n = 0;
    for (let o = 0; o < 4; o++)
      for (let l = 0; l < 4; l++)
        r.affine[o][l] = i[n], n++;
  }
  let a = 8;
  return s === 256 || s === 2 ? a = 8 : s === 512 || s === 4 ? a = 16 : s === 16 || s === 768 || s === 8 || s === 2304 ? a = 32 : s === 64 ? a = 64 : V.warn("Unsupported NIfTI datatypeCode for header creation: " + s), r.datatypeCode = s, r.numBitsPerVoxel = a, r.scl_inter = 0, r.scl_slope = 1, r.sform_code = 2, r.magic = "n+1", r.vox_offset = 352, r;
}
function Hl(e = [256, 256, 256], t = [1, 1, 1], i = [1, 0, 0, -128, 0, 1, 0, -128, 0, 0, 1, -128, 0, 0, 0, 1], s = 2, r = new Uint8Array()) {
  const a = nn(e, t, i, s), n = Mi(a, !1);
  a.vox_offset = Math.max(352, n.length);
  const o = Mi(a, !1);
  if (r.length < 1)
    return o;
  const l = Math.max(0, a.vox_offset - o.length), c = new Uint8Array(l), h = new Uint8Array(r.buffer, r.byteOffset, r.byteLength), f = a.vox_offset + h.length, d = new Uint8Array(f);
  return d.set(o, 0), d.set(c, o.length), d.set(h, a.vox_offset), d;
}
function an(e, t = null) {
  if (!e.hdr)
    throw new Error("NVImage header is not defined for toUint8Array");
  if (!e.img && t === null)
    throw new Error("NVImage image data is not defined for toUint8Array");
  const i = t !== null, s = JSON.parse(JSON.stringify(e.hdr)), r = e.extensions && e.extensions.length > 0, a = new Uint8Array(4);
  a[0] = r ? 1 : 0;
  let n = new Uint8Array(0);
  if (r) {
    const p = [];
    let A = 0;
    for (const w of e.extensions) {
      const v = new Uint8Array(w.edata), F = new Uint8Array(8 + v.length), C = new DataView(F.buffer);
      C.setInt32(0, w.esize, !0), C.setInt32(4, w.ecode, !0), F.set(v, 8), p.push(F), A += F.length;
    }
    n = new Uint8Array(A);
    let x = 0;
    for (const w of p)
      n.set(w, x), x += w.length;
  }
  const o = 348;
  s.vox_offset = Math.max(352, o + a.length + n.length), i && (s.datatypeCode = 2, s.numBitsPerVoxel = 8, s.scl_slope = 1, s.scl_inter = 0);
  const l = Mi(s, i);
  let c;
  if (i) {
    const p = t, A = e.permRAS;
    if (A && (A[0] !== 1 || A[1] !== 2 || A[2] !== 3)) {
      V.debug("Reorienting drawing bytes back to native space for saving...");
      const x = e.hdr.dims, w = x[1] * x[2] * x[3], v = e.dimsRAS ? e.dimsRAS[1] * e.dimsRAS[2] * e.dimsRAS[3] : w;
      if (p.length !== v)
        console.warn(
          `Drawing length (${p.length}) does not match expected RAS voxel count (${v}). Cannot reorient drawing reliably.`
        ), c = p;
      else if (!e.img2RASstep || !e.img2RASstart || !e.dimsRAS)
        console.warn(
          "Missing RAS transformation info (img2RASstep, img2RASstart, dimsRAS). Cannot reorient drawing reliably."
        ), c = p;
      else {
        const F = e.img2RASstep, C = e.img2RASstart, b = e.dimsRAS, y = new Uint8Array(w);
        y.fill(0);
        const E = p;
        let S = 0;
        for (let D = 0; D < b[3]; D++) {
          const M = C[2] + D * F[2];
          for (let B = 0; B < b[2]; B++) {
            const T = C[1] + B * F[1];
            for (let U = 0; U < b[1]; U++) {
              const N = C[0] + U * F[0] + T + M;
              N >= 0 && N < w ? y[N] = E[S] : S < E.length && console.warn(
                `Calculated native index ${N} is out of bounds [0..${w - 1}] during drawing reorientation.`
              ), S++;
            }
          }
        }
        c = y;
      }
    } else
      c = p;
  } else {
    if (!e.img)
      throw new Error("NVImage image data is null when trying to save non-drawing.");
    c = new Uint8Array(e.img.buffer, e.img.byteOffset, e.img.byteLength);
  }
  const h = l.length + a.length + n.length, f = Math.max(0, s.vox_offset - h), d = new Uint8Array(f), u = s.vox_offset + c.length, m = new Uint8Array(u);
  let g = 0;
  return m.set(l, g), g += l.length, m.set(a, g), g += a.length, m.set(n, g), g += n.length, m.set(d, g), g += d.length, m.set(c, s.vox_offset), m;
}
async function on(e, t, i = null) {
  const s = an(e, i);
  if (t.toLowerCase().endsWith(".gz"))
    try {
      const a = await H.compress(s, "gzip");
      return new Uint8Array(a);
    } catch (a) {
      return V.error("Compression failed:", a), V.warn("Returning uncompressed data due to compression error."), s;
    }
  else
    return s;
}
async function _l(e, t = "", i = null) {
  const s = await on(e, t, i);
  if (!t)
    return V.debug("saveToDisk: empty file name, returning data as Uint8Array rather than triggering download"), s;
  try {
    const r = new Blob([s.buffer], {
      type: "application/octet-stream"
      // Standard type for binary download
    }), a = URL.createObjectURL(r), n = document.createElement("a");
    n.setAttribute("href", a), n.setAttribute("download", t), n.style.visibility = "hidden", document.body.appendChild(n), n.click(), document.body.removeChild(n), setTimeout(() => URL.revokeObjectURL(a), 100);
  } catch (r) {
    V.error("Failed to trigger download:", r);
  }
  return s;
}
function ln(e, t, i, s, r = 0, a = !1) {
  if (!e.hdr)
    throw new Error("getValue: NVImage header is not defined.");
  if (!a && !e.img)
    throw new Error("getValue: NVImage image data is not defined.");
  if (a && !e.imaginary)
    return V.warn("getValue: Attempted to read imaginary data, but none exists."), [0];
  const n = e.hdr.dims[1], o = e.hdr.dims[2], l = e.hdr.dims[3], c = e.permRAS.slice();
  if (c[0] !== 1 || c[1] !== 2 || c[2] !== 3) {
    const x = ht(t, i, s, 1);
    Ct(x, x, e.toRASvox), t = x[0], i = x[1], s = x[2];
  }
  t = Math.max(0, Math.min(Math.round(t), n - 1)), i = Math.max(0, Math.min(Math.round(i), o - 1)), s = Math.max(0, Math.min(Math.round(s), l - 1)), r = Math.max(0, r);
  let h = t + i * n + s * n * o;
  if (e.hdr.datatypeCode === 2304)
    return e.img ? (h *= 4, h + 3 >= e.img.length ? (V.warn(`getValue: Calculated index ${h} out of bounds for RGBA data.`), [0]) : [e.img[h], e.img[h + 1], e.img[h + 2], e.img[h + 3]]) : [0];
  if (e.hdr.datatypeCode === 128)
    return e.img ? (h *= 3, h + 2 >= e.img.length ? (V.warn(`getValue: Calculated index ${h} out of bounds for RGB data.`), [0]) : [e.img[h], e.img[h + 1], e.img[h + 2]]) : [0];
  const f = n * o * l, d = r * f, u = h + d, m = a ? e.imaginary : e.img;
  if (u < 0 || u >= m.length)
    return [0];
  const g = m[u], p = isNaN(e.hdr.scl_slope) || e.hdr.scl_slope === 0 ? 1 : e.hdr.scl_slope, A = isNaN(e.hdr.scl_inter) ? 0 : e.hdr.scl_inter;
  return [p * g + A];
}
function Ql(e, t, i, s, r = 0, a = !1) {
  const n = ln(e, t, i, s, r, a);
  return n.length < 3 ? n[0] : n[0] * 0.2126 + n[1] * 0.7152 + n[2] * 0.0722;
}
function jl(e, t = [-1, 0, 0], i = [0, 0, 0], s = "same") {
  const r = [new Uint8Array(), [0, 0, 0]];
  if (!e.hdr || !e.img || !e.dimsRAS || !e.img2RASstep || !e.img2RASstart)
    return V.error("getVolumeData: Missing required NVImage properties (hdr, img, dimsRAS, img2RASstep/start)."), r;
  if (t = t.slice(0, 3), i = i.slice(0, 3), Math.min(...t) < 0 || Math.min(...i) < 0)
    return V.warn("getVolumeData: Invalid start or end coordinates provided."), r;
  const a = e.dimsRAS.slice(1, 4);
  for (let p = 0; p < 3; p++)
    if (t[p] = Math.max(0, Math.min(Math.round(t[p]), a[p] - 1)), i[p] = Math.max(0, Math.min(Math.round(i[p]), a[p] - 1)), i[p] < t[p]) {
      const A = i[p];
      i[p] = t[p], t[p] = A;
    }
  const n = [
    i[0] - t[0] + 1,
    i[1] - t[1] + 1,
    i[2] - t[2] + 1
  ], o = n[0] * n[1] * n[2];
  if (o <= 0)
    return V.warn("getVolumeData: Calculated slab size is zero or negative."), r;
  let l = e.img.constructor;
  s === "uint8" ? l = Uint8Array : s === "int16" ? l = Int16Array : s === "uint16" ? l = Uint16Array : s === "float32" || s === "scaled" || s === "normalized" || s === "windowed" ? l = Float32Array : s === "float64" ? l = Float64Array : s !== "same" && V.warn(`getVolumeData: Unsupported dataType '${s}'. Using 'same'.`);
  let c;
  try {
    c = new l(o);
  } catch (p) {
    return V.error(`getVolumeData: Failed to create output array for dataType '${s}'.`, p), r;
  }
  const h = e.img2RASstep, f = e.img2RASstart, d = e.img;
  let u = 0;
  for (let p = t[2]; p <= i[2]; p++) {
    const A = f[2] + p * h[2];
    for (let x = t[1]; x <= i[1]; x++) {
      const w = f[1] + x * h[1];
      for (let v = t[0]; v <= i[0]; v++) {
        const C = f[0] + v * h[0] + w + A;
        let b = 0;
        C >= 0 && C < d.length && (b = d[C]), c[u++] = b;
      }
    }
  }
  const m = isNaN(e.hdr.scl_slope) || e.hdr.scl_slope === 0 ? 1 : e.hdr.scl_slope, g = isNaN(e.hdr.scl_inter) ? 0 : e.hdr.scl_inter;
  if (s === "scaled" || s === "normalized" || s === "windowed") {
    c instanceof Float32Array || (V.warn(`getVolumeData: Converting output to Float32 for scaling type '${s}'.`), c = Float32Array.from(c));
    for (let p = 0; p < c.length; p++)
      c[p] = c[p] * m + g;
  }
  if (s === "normalized" || s === "windowed") {
    let p = e.cal_min, A = e.cal_max;
    s === "normalized" && (p = e.global_min, A = e.global_max);
    const x = A - p, w = x === 0 ? 0 : 1 / x;
    for (let v = 0; v < c.length; v++)
      c[v] = (c[v] - p) * w, c[v] = Math.max(0, Math.min(c[v], 1));
  }
  return [c, n];
}
function Zl(e, t = [-1, 0, 0], i = [0, 0, 0], s = new Uint8Array()) {
  if (!e.hdr || !e.img || !e.dimsRAS || !e.img2RASstep || !e.img2RASstart) {
    V.error("setVolumeData: Missing required NVImage properties (hdr, img, dimsRAS, img2RASstep/start).");
    return;
  }
  if (s.length < 1) {
    V.warn("setVolumeData: Input slabData is empty.");
    return;
  }
  if (t = t.slice(0, 3), i = i.slice(0, 3), Math.min(...t) < 0 || Math.min(...i) < 0) {
    V.warn("setVolumeData: Invalid start or end coordinates provided.");
    return;
  }
  const r = e.dimsRAS.slice(1, 4);
  for (let f = 0; f < 3; f++)
    if (t[f] = Math.max(0, Math.min(Math.round(t[f]), r[f] - 1)), i[f] = Math.max(0, Math.min(Math.round(i[f]), r[f] - 1)), i[f] < t[f]) {
      const d = i[f];
      i[f] = t[f], t[f] = d;
    }
  const a = [
    i[0] - t[0] + 1,
    i[1] - t[1] + 1,
    i[2] - t[2] + 1
  ], n = a[0] * a[1] * a[2];
  if (n <= 0) {
    V.warn("setVolumeData: Calculated slab size is zero or negative.");
    return;
  }
  if (s.length < n) {
    V.error(
      `setVolumeData: Input slabData length (${s.length}) is less than the calculated slab size (${n}).`
    );
    return;
  }
  const o = e.img2RASstep, l = e.img2RASstart, c = e.img;
  let h = 0;
  for (let f = t[2]; f <= i[2]; f++) {
    const d = l[2] + f * o[2];
    for (let u = t[1]; u <= i[1]; u++) {
      const m = l[1] + u * o[1];
      for (let g = t[0]; g <= i[0]; g++) {
        const A = l[0] + g * o[0] + m + d;
        A >= 0 && A < c.length && (c[A] = s[h]), h++;
      }
    }
  }
}
var cn = {};
Ii(cn, {
  isFreeSurferLabelImage: () => fn,
  optimizeFreeSurferLabels: () => hn,
  readMgh: () => Jl
});
function or(e, t, i, s = 1) {
  const r = t + i;
  let a = t;
  const n = [];
  for (; a + 12 <= r; ) {
    const o = e.getInt32(a, !1), l = e.getInt32(a + 8, !1);
    if (a += 12, l <= 0 || a + l > r)
      break;
    if (o !== s) {
      a += l;
      continue;
    }
    let c = l, h = a;
    if (s === 1) {
      if (a + 4 > r)
        break;
      c = e.getInt32(a, !1), h += 4;
    }
    if (c > 1 && h + c <= r) {
      const f = new Uint8Array(e.buffer, h, c), d = new TextDecoder("utf-8").decode(f.slice(0, -1));
      n.push(d);
    }
    a += l;
  }
  return n.join(`

`);
}
function hn(e, t) {
  if (e.intent_code = 1002, e.datatypeCode !== 16 && e.datatypeCode !== 8)
    return t;
  let i = new Float32Array(t);
  if (e.datatypeCode === 8 && (i = new Int32Array(t)), ls()) {
    const n = new Uint32Array(t);
    for (let o = 0; o < n.length; o++) {
      const l = n[o];
      n[o] = (l & 255) << 24 | (l & 65280) << 8 | (l & 16711680) >>> 8 | (l & 4278190080) >>> 24;
    }
  }
  e.littleEndian = ls();
  let s = !0, r = 1 / 0, a = -1 / 0;
  for (let n = 0; n < i.length; n++) {
    const o = i[n];
    Number.isFinite(o) && (Number.isInteger(o) || (s = !1), o < r && (r = o), o > a && (a = o));
  }
  if (!s || r < 0 || a > 2147483647)
    return V.warn(`FreeSurfer Labels must be integers in INT32 range. range ${r}..${a}`), t;
  if (a > 32767) {
    e.datatypeCode = 8;
    const n = new Int32Array(i.length);
    for (let o = 0; o < i.length; o++)
      n[o] = Math.trunc(i[o]);
    return n.buffer;
  } else if (a > 255) {
    e.datatypeCode = 4, e.numBitsPerVoxel = 16;
    const n = new Int16Array(i.length);
    for (let o = 0; o < i.length; o++)
      n[o] = Math.trunc(i[o]);
    return n.buffer;
  } else {
    e.datatypeCode = 2, e.numBitsPerVoxel = 8;
    const n = new Uint8Array(i.length);
    for (let o = 0; o < i.length; o++)
      n[o] = Math.trunc(i[o]);
    return n.buffer;
  }
}
function fn(e, t, i) {
  const s = e.byteLength - t.vox_offset;
  if (s < i)
    return V.error(`MGH image data size mismatch: expected ${i}, found ${s}`), !1;
  if (s === i)
    return !1;
  const r = t.vox_offset + i + 20, a = e.byteLength - r;
  return a <= 12 ? !1 : or(new DataView(e), r, a).toLowerCase().endsWith("lut.txt") ? !0 : or(new DataView(e), r, a, 3).includes("mri_label2vol");
}
async function Jl(e, t) {
  e.hdr || (V.debug("readMgh called before nvImage.hdr was initialized. Creating default."), e.hdr = new Z());
  const i = e.hdr;
  i.littleEndian = !1;
  let s = t, r = new DataView(s);
  if (s.byteLength >= 2 && r.getUint8(0) === 31 && r.getUint8(1) === 139)
    try {
      s = await H.decompressToBuffer(new Uint8Array(t)), r = new DataView(s);
    } catch (N) {
      return V.error("Failed to decompress MGZ file.", N), null;
    }
  if (s.byteLength < 284)
    return V.error("File too small to be a valid MGH/MGZ header."), null;
  const a = r.getInt32(0, !1), n = r.getInt32(4, !1), o = r.getInt32(8, !1), l = r.getInt32(12, !1), c = r.getInt32(16, !1), h = r.getInt32(20, !1), f = r.getFloat32(30, !1), d = r.getFloat32(34, !1), u = r.getFloat32(38, !1), m = r.getFloat32(42, !1), g = r.getFloat32(46, !1), p = r.getFloat32(50, !1), A = r.getFloat32(54, !1), x = r.getFloat32(58, !1), w = r.getFloat32(62, !1), v = r.getFloat32(66, !1), F = r.getFloat32(70, !1), C = r.getFloat32(74, !1), b = r.getFloat32(78, !1), y = r.getFloat32(82, !1), E = r.getFloat32(86, !1);
  if (a !== 1 && V.warn(`Unexpected MGH version: ${a}.`), n <= 0 || o <= 0 || l <= 0)
    return V.error(`Invalid MGH dimensions: ${n}x${o}x${l}`), null;
  switch (h) {
    case 0:
      i.numBitsPerVoxel = 8, i.datatypeCode = 2;
      break;
    case 4:
      i.numBitsPerVoxel = 16, i.datatypeCode = 4;
      break;
    case 1:
      i.numBitsPerVoxel = 32, i.datatypeCode = 8;
      break;
    case 3:
      i.numBitsPerVoxel = 32, i.datatypeCode = 16;
      break;
    default:
      return V.error(`Unsupported MGH data type: ${h}`), null;
  }
  i.dims[1] = n, i.dims[2] = o, i.dims[3] = l, i.dims[4] = Math.max(1, c), i.dims[0] = i.dims[4] > 1 ? 4 : 3, i.pixDims[1] = Math.abs(f), i.pixDims[2] = Math.abs(d), i.pixDims[3] = Math.abs(u), i.pixDims[4] = 0, i.sform_code = 1, i.qform_code = 0, i.sform_code = 1;
  const S = Pt(
    m * i.pixDims[1],
    A * i.pixDims[2],
    v * i.pixDims[3],
    0,
    g * i.pixDims[1],
    x * i.pixDims[2],
    F * i.pixDims[3],
    0,
    p * i.pixDims[1],
    w * i.pixDims[2],
    C * i.pixDims[3],
    0,
    0,
    0,
    0,
    1
  ), D = [i.dims[1] / 2, i.dims[2] / 2, i.dims[3] / 2, 1], M = [0, 0, 0, 0];
  for (let N = 0; N < 3; N++) {
    M[N] = 0;
    for (let k = 0; k < 3; k++)
      M[N] = M[N] + S[k + N * 4] * D[k];
  }
  i.affine = [
    [S[0], S[1], S[2], b - M[0]],
    [S[4], S[5], S[6], y - M[1]],
    [S[8], S[9], S[10], E - M[2]],
    [0, 0, 0, 1]
  ], i.vox_offset = 284, i.magic = "n+1";
  const B = i.numBitsPerVoxel / 8, U = n * o * l * i.dims[4] * B, R = s.slice(i.vox_offset, i.vox_offset + U);
  return fn(s, i, U) ? hn(i, R) : R;
}
var dn = {};
Ii(dn, {
  readNifti: () => $l
});
async function $l(e, t, i) {
  let s = t, r = null;
  try {
    if (ps(s) && (V.debug(`Decompressing NIfTI file: ${e.name}`), s = await Sa(s), V.debug(`Decompression complete for: ${e.name}`)), !s || s.byteLength === 0)
      throw new Error("Buffer became invalid after decompression attempt.");
    if (e.hdr = await Ie(s, i != null), Ta(e.hdr) && (e.extensions = e.hdr.extensions), e.hdr === null)
      throw new Error(`Failed to read NIfTI header: ${e.name}`);
    if (e.hdr.cal_min === 0 && e.hdr.cal_max === 255 && e.hdr.datatypeCode !== 2 && (V.debug(`Resetting suspicious cal_min/max (0/255) for non-uint8 NIfTI: ${e.name}`), e.hdr.cal_min = 0, e.hdr.cal_max = 0), r = i ? Xs(e.hdr, i) : Xs(e.hdr, s), r === null)
      throw new Error(`nifti-reader-js readImage returned null for ${e.name}`);
    return r;
  } catch (a) {
    return V.error(`Error processing NIfTI file ${e.name}:`, a), e.hdr = null, null;
  }
}
var un = {};
Ii(un, {
  readNrrd: () => tc
});
async function tc(e, t, i = null) {
  e.hdr || (V.warn("readNrrd called before nvImage.hdr was initialized. Creating default."), e.hdr = new Z());
  const s = e.hdr;
  s.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  const r = t.byteLength;
  let a = null;
  const n = new Uint8Array(t);
  for (let C = 1; C < r; C++)
    if (n[C - 1] === 10 && n[C] === 10) {
      const b = t.slice(0, C - 1);
      a = new TextDecoder().decode(b), s.vox_offset = C + 1;
      break;
    }
  if (a === null)
    return V.error("readNrrd: could not extract txt"), null;
  const o = a.split(`
`);
  if (!o[0].startsWith("NRRD"))
    return V.error("Invalid NRRD image (magic signature missing)"), null;
  const l = o.length;
  let c = !1, h = !1, f = !1;
  const d = jt(NaN, 0, 0, 0, 1, 0, 0, 0, 1), u = O(0, 0, 0);
  let m = Ji();
  for (let C = 1; C < l; C++) {
    let b = o[C];
    if ((b.length === 0 || b[0] === "#") && (b.startsWith("#") || b.trim().length === 0))
      continue;
    b = b.toLowerCase();
    const y = b.split(":");
    if (y.length < 2)
      continue;
    const E = y[0].trim();
    let S = y[1].trim();
    switch (S = S.replaceAll(")", " "), S = S.replaceAll("(", " "), S = S.trim(), E) {
      case "data file":
        f = !0;
        break;
      case "encoding":
        if (S.includes("raw"))
          c = !1;
        else if (S.includes("gz"))
          c = !0;
        else
          return V.error("Unsupported NRRD encoding"), null;
        break;
      case "type":
        switch (S) {
          case "uchar":
          case "unsigned char":
          case "uint8":
          case "uint8_t":
            s.numBitsPerVoxel = 8, s.datatypeCode = 2;
            break;
          case "signed char":
          case "int8":
          case "int8_t":
            s.numBitsPerVoxel = 8, s.datatypeCode = 256;
            break;
          case "short":
          case "short int":
          case "signed short":
          case "signed short int":
          case "int16":
          case "int16_t":
            s.numBitsPerVoxel = 16, s.datatypeCode = 4;
            break;
          case "ushort":
          case "unsigned short":
          case "unsigned short int":
          case "uint16":
          case "uint16_t":
            s.numBitsPerVoxel = 16, s.datatypeCode = 512;
            break;
          case "int":
          case "signed int":
          case "int32":
          case "int32_t":
            s.numBitsPerVoxel = 32, s.datatypeCode = 8;
            break;
          case "uint":
          case "unsigned int":
          case "uint32":
          case "uint32_t":
            s.numBitsPerVoxel = 32, s.datatypeCode = 768;
            break;
          case "float":
            s.numBitsPerVoxel = 32, s.datatypeCode = 16;
            break;
          case "double":
            s.numBitsPerVoxel = 64, s.datatypeCode = 64;
            break;
          default:
            return V.error("Unsupported NRRD data type: " + S), null;
        }
        break;
      case "spacings":
        {
          const D = S.split(/[ ,]+/);
          for (let M = 0; M < D.length; M++)
            s.pixDims[M + 1] = parseFloat(D[M]);
        }
        break;
      case "sizes":
        {
          const D = S.split(/[ ,]+/);
          s.dims[0] = D.length;
          for (let M = 0; M < D.length; M++)
            s.dims[M + 1] = parseInt(D[M]);
        }
        break;
      case "endian":
        S.includes("little") ? s.littleEndian = !0 : S.includes("big") && (s.littleEndian = !1);
        break;
      case "space directions":
        {
          const D = S.split(/[ ,]+/);
          if (D.length === 9)
            for (let M = 0; M < 9; M++)
              d[M] = parseFloat(D[M]);
        }
        break;
      case "space origin":
        {
          const D = S.split(/[ ,]+/);
          D.length === 3 && (u[0] = parseFloat(D[0]), u[1] = parseFloat(D[1]), u[2] = parseFloat(D[2]));
        }
        break;
      case "space units":
        S.includes("microns") && (h = !0);
        break;
      case "space":
        S.includes("right-anterior-superior") || S.includes("ras") ? m = jt(1, 0, 0, 0, 1, 0, 0, 0, 1) : S.includes("left-anterior-superior") || S.includes("las") ? m = jt(-1, 0, 0, 0, 1, 0, 0, 0, 1) : S.includes("left-posterior-superior") || S.includes("lps") ? m = jt(-1, 0, 0, 0, -1, 0, 0, 0, 1) : V.warn("Unsupported NRRD space value:", S);
        break;
      default:
        V.warn("Unknown:", E);
        break;
    }
  }
  if (!isNaN(d[0])) {
    s.sform_code = 2, h && (zn(d, d, 1e-3), u[0] *= 1e-3, u[1] *= 1e-3, u[2] *= 1e-3), m[0] < 0 && (u[0] = -u[0]), m[4] < 0 && (u[1] = -u[1]), m[8] < 0 && (u[2] = -u[2]), Tr(d, m, d);
    const C = Pt(
      d[0],
      d[3],
      d[6],
      u[0],
      d[1],
      d[4],
      d[7],
      u[1],
      d[2],
      d[5],
      d[8],
      u[2],
      0,
      0,
      0,
      1
    );
    if (!e.vox2mm)
      return null;
    const b = e.vox2mm([0, 0, 0], C), y = e.vox2mm([1, 0, 0], C);
    ot(y, y, b);
    const E = e.vox2mm([0, 1, 0], C);
    ot(E, E, b);
    const S = e.vox2mm([0, 0, 1], C);
    ot(S, S, b), s.pixDims[1] = $t(y), s.pixDims[2] = $t(E), s.pixDims[3] = $t(S), s.affine = [
      [C[0], C[1], C[2], C[3]],
      [C[4], C[5], C[6], C[7]],
      [C[8], C[9], C[10], C[11]],
      [0, 0, 0, 1]
    ];
  }
  let g = null;
  const p = f ? i : t, A = f ? 0 : s.vox_offset;
  if (f && !p)
    return V.warn("Missing data: NRRD header describes detached data file but only one URL provided"), null;
  if (!p || A >= p.byteLength)
    return V.error(`NRRD data offset (${A}) invalid for buffer length (${(p == null ? void 0 : p.byteLength) ?? 0})`), null;
  let x = p.slice(A);
  if (c)
    try {
      V.debug("Decompressing NRRD data..."), x = await H.decompressToBuffer(new Uint8Array(x)), V.debug("Decompression complete.");
    } catch (C) {
      return V.error("Failed to decompress NRRD data.", C), null;
    }
  const w = s.numBitsPerVoxel / 8, F = s.dims.slice(1, s.dims[0] + 1).reduce((C, b) => C * Math.max(1, b), 1) * w;
  return x.byteLength < F ? (V.error(`NRRD image data size mismatch: expected ${F}, found ${x.byteLength}`), null) : (x.byteLength > F && (V.warn(`NRRD has extra ${x.byteLength - F} bytes after expected image data. Truncating.`), x = x.slice(0, F)), g = x, s.datatypeCode ? s.numBitsPerVoxel ? g : (V.error("NRRD parsing failed to set numBitsPerVoxel."), null) : (V.error("NRRD parsing failed to set datatypeCode."), null));
}
var Mt = class bi {
  constructor(t = null, i = "", s = "gray", r = 1, a = null, n = NaN, o = NaN, l = !0, c = 0.02, h = !1, f = !1, d = "", u = 0, m = j.UNKNOWN, g = NaN, p = NaN, A = !0, x = null, w = 0) {
    I(this, "name"), I(this, "id"), I(this, "url"), I(this, "headers"), I(this, "_colormap"), I(this, "_opacity"), I(this, "percentileFrac"), I(this, "ignoreZeroVoxels"), I(this, "trustCalMinMax"), I(this, "colormapNegative"), I(this, "colormapLabel"), I(this, "colormapInvert"), I(this, "nFrame4D"), I(this, "frame4D"), I(this, "nTotalFrame4D"), I(this, "cal_minNeg"), I(this, "cal_maxNeg"), I(this, "colorbarVisible", !0), I(this, "modulationImage", null), I(this, "modulateAlpha", 0), I(this, "series", []), I(this, "nVox3D"), I(this, "oblique_angle"), I(this, "maxShearDeg"), I(this, "useQFormNotSForm"), I(this, "colormapType"), I(this, "pixDims"), I(this, "matRAS"), I(this, "pixDimsRAS"), I(this, "obliqueRAS"), I(this, "dimsRAS"), I(this, "permRAS"), I(this, "img2RASstep"), I(this, "img2RASstart"), I(this, "toRAS"), I(this, "toRASvox"), I(this, "frac2mm"), I(this, "frac2mmOrtho"), I(this, "extentsMinOrtho"), I(this, "extentsMaxOrtho"), I(this, "mm2ortho"), I(this, "hdr", null), I(this, "extensions"), I(this, "imageType"), I(this, "img"), I(this, "imaginary"), I(this, "v1"), I(this, "fileObject"), I(this, "dims"), I(this, "onColormapChange", () => {
    }), I(this, "onOpacityChange", () => {
    }), I(this, "mm000"), I(this, "mm100"), I(this, "mm010"), I(this, "mm001"), I(this, "cal_min"), I(this, "cal_max"), I(this, "robust_min"), I(this, "robust_max"), I(this, "global_min"), I(this, "global_max"), I(this, "urlImgData"), I(this, "isManifest"), I(this, "limitFrames4D"), this.init(
      t,
      i,
      s,
      r,
      a,
      n,
      o,
      l,
      c,
      h,
      f,
      d,
      u,
      m,
      g,
      p,
      A,
      x,
      w
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  init(t = null, i = "", s = "", r = 1, a = null, n = NaN, o = NaN, l = !0, c = 0.02, h = !1, f = !1, d = "", u = 0, m = j.UNKNOWN, g = NaN, p = NaN, A = !0, x = null, w = 0, v = null) {
    const F = s === "";
    if (F && (s = "gray"), this.name = i, this.imageType = m, this.id = $i(), this._colormap = s, this._opacity = r > 1 ? 1 : r, this.percentileFrac = c, this.ignoreZeroVoxels = h, this.trustCalMinMax = l, this.colormapNegative = d, this.colormapLabel = x, this.frame4D = u, this.cal_minNeg = g, this.cal_maxNeg = p, this.colorbarVisible = A, this.colormapType = w, this.useQFormNotSForm = f, !t)
      return;
    if (F && this.hdr && this.hdr.intent_code === 1002 && (s = "random", this._colormap = s), this.hdr && typeof this.hdr.magic == "number" && (this.hdr.magic = "n+1"), this.nFrame4D = 1, this.hdr)
      for (let E = 4; E < 7; E++)
        this.hdr.dims[E] > 1 && (this.nFrame4D *= this.hdr.dims[E]);
    if (this.frame4D = Math.min(this.frame4D, this.nFrame4D - 1), this.nTotalFrame4D = this.nFrame4D, !this.hdr || !v)
      return;
    this.nVox3D = this.hdr.dims[1] * this.hdr.dims[2] * this.hdr.dims[3];
    const C = this.nVox3D * (this.hdr.numBitsPerVoxel / 8), b = v.byteLength / C;
    b !== this.nFrame4D && (b > 0 && b * C === v.byteLength ? V.debug("Loading the first " + b + " of " + this.nFrame4D + " volumes") : V.warn("This header does not match voxel data", this.hdr, v.byteLength), this.nFrame4D = b), (this.hdr.intent_code === 1007 || this.hdr.intent_code === 2003) && this.nFrame4D === 3 && this.hdr.datatypeCode === 16 && (v = this.float32V1asRGBA(new Float32Array(v)).buffer), (this.hdr.pixDims[1] === 0 || this.hdr.pixDims[2] === 0 || this.hdr.pixDims[3] === 0) && V.error("pixDims not plausible", this.hdr), (isNaN(this.hdr.scl_slope) || this.hdr.scl_slope === 0) && (this.hdr.scl_slope = 1), isNaN(this.hdr.scl_inter) && (this.hdr.scl_inter = 0);
    let y = ar(this.hdr.affine);
    if (f || !y || this.hdr.qform_code > this.hdr.sform_code) {
      V.debug("spatial transform based on QForm");
      const E = this.hdr.quatern_b, S = this.hdr.quatern_c, D = this.hdr.quatern_d, M = Math.sqrt(1 - (Math.pow(E, 2) + Math.pow(S, 2) + Math.pow(D, 2))), B = this.hdr.pixDims[0] === 0 ? 1 : this.hdr.pixDims[0], T = [
        [M * M + E * E - S * S - D * D, 2 * E * S - 2 * M * D, 2 * E * D + 2 * M * S],
        [2 * E * S + 2 * M * D, M * M + S * S - E * E - D * D, 2 * S * D - 2 * M * E],
        [2 * E * D - 2 * M * S, 2 * S * D + 2 * M * E, M * M + D * D - S * S - E * E]
      ], U = this.hdr.affine;
      for (let R = 0; R < 3; R += 1)
        for (let N = 0; N < 3; N += 1)
          U[R][N] = T[R][N] * this.hdr.pixDims[N + 1], N === 2 && (U[R][N] *= B);
      U[0][3] = this.hdr.qoffset_x, U[1][3] = this.hdr.qoffset_y, U[2][3] = this.hdr.qoffset_z, this.hdr.affine = U;
    }
    if (y = ar(this.hdr.affine), !y) {
      V.debug("Defective NIfTI: spatial transform does not make sense");
      let E = this.hdr.pixDims[1], S = this.hdr.pixDims[2], D = this.hdr.pixDims[3];
      (isNaN(E) || E === 0) && (E = 1), (isNaN(S) || S === 0) && (S = 1), (isNaN(D) || D === 0) && (D = 1), this.hdr.pixDims[1] = E, this.hdr.pixDims[2] = S, this.hdr.pixDims[3] = D;
      const M = [
        [E, 0, 0, 0],
        [0, S, 0, 0],
        [0, 0, D, 0],
        [0, 0, 0, 1]
      ];
      this.hdr.affine = M;
    }
    if (this.hdr.datatypeCode !== 128 && this.hdr.datatypeCode !== 2304 && this.hdr.littleEndian !== ls() && this.hdr.numBitsPerVoxel > 8) {
      if (this.hdr.numBitsPerVoxel === 16) {
        const E = new Uint16Array(v);
        for (let S = 0; S < E.length; S++) {
          const D = E[S];
          E[S] = ((D & 255) << 8 | D >> 8 & 255) << 16 >> 16;
        }
      } else if (this.hdr.numBitsPerVoxel === 32) {
        const E = new Uint32Array(v);
        for (let S = 0; S < E.length; S++) {
          const D = E[S];
          E[S] = (D & 255) << 24 | (D & 65280) << 8 | D >> 8 & 65280 | D >> 24 & 255;
        }
      } else if (this.hdr.numBitsPerVoxel === 64) {
        const E = this.hdr.numBitsPerVoxel / 8, S = new Uint8Array(v);
        for (let D = 0; D < S.length; D += E) {
          let M = E - 1;
          for (let B = 0; B < M; B++) {
            const T = S[D + B];
            S[D + B] = S[D + M], S[D + M] = T, M--;
          }
        }
      }
    }
    switch (this.hdr.datatypeCode) {
      case 2:
        this.img = new Uint8Array(v);
        break;
      case 4:
        this.img = new Int16Array(v);
        break;
      case 16:
        this.img = new Float32Array(v);
        break;
      case 64:
        this.img = new Float64Array(v);
        break;
      case 128:
        this.img = new Uint8Array(v);
        break;
      case 512:
        this.img = new Uint16Array(v);
        break;
      case 2304:
        this.img = new Uint8Array(v);
        break;
      case 256: {
        const E = new Int8Array(v), S = E.length;
        this.img = new Int16Array(S);
        for (let D = 0; D < S; D++)
          this.img[D] = E[D];
        this.hdr.datatypeCode = 4, this.hdr.numBitsPerVoxel = 16;
        break;
      }
      case 1: {
        const E = this.hdr.dims[1] * this.hdr.dims[2] * Math.max(1, this.hdr.dims[3]) * Math.max(1, this.hdr.dims[4]), S = new Uint8Array(v);
        this.img = new Uint8Array(E);
        const D = new Uint8Array(8);
        for (let B = 0; B < 8; B++)
          D[B] = Math.pow(2, B);
        let M = -1;
        for (let B = 0; B < E; B++) {
          const T = B % 8;
          T === 0 && M++, S[M] & D[T] && (this.img[B] = 1);
        }
        this.hdr.datatypeCode = 2, this.hdr.numBitsPerVoxel = 8;
        break;
      }
      case 768: {
        const E = new Uint32Array(v), S = E.length;
        this.img = new Float64Array(S);
        for (let D = 0; D < S - 1; D++)
          this.img[D] = E[D];
        this.hdr.datatypeCode = 64;
        break;
      }
      case 8: {
        const E = new Int32Array(v), S = E.length;
        this.img = new Float64Array(S);
        for (let D = 0; D < S - 1; D++)
          this.img[D] = E[D];
        this.hdr.datatypeCode = 64;
        break;
      }
      case 1024: {
        const E = new BigInt64Array(v), S = E.length;
        this.img = new Float64Array(S);
        for (let D = 0; D < S - 1; D++)
          this.img[D] = Number(E[D]);
        this.hdr.datatypeCode = 64;
        break;
      }
      case 32: {
        const E = new Float32Array(v), S = Math.floor(E.length / 2);
        this.imaginary = new Float32Array(S), this.img = new Float32Array(S);
        let D = 0;
        for (let M = 0; M < S - 1; M++)
          this.img[M] = E[D], this.imaginary[M] = E[D + 1], D += 2;
        this.hdr.datatypeCode = 16;
        break;
      }
      default:
        throw new Error("datatype " + this.hdr.datatypeCode + " not supported");
    }
    this.calculateRAS(), isNaN(n) || (this.hdr.cal_min = n), isNaN(o) || (this.hdr.cal_max = o), this.calMinMax();
  }
  static async new(t = null, i = "", s = "", r = 1, a = null, n = NaN, o = NaN, l = !0, c = 0.02, h = !1, f = !1, d = "", u = 0, m = j.UNKNOWN, g = NaN, p = NaN, A = !0, x = null, w = 0, v) {
    const F = new bi(), C = /(?:\.([^.]+))?$/;
    let b = C.exec(i)[1] || "";
    b = b.toUpperCase(), b === "GZ" && (b = C.exec(i.slice(0, -3))[1], b = b.toUpperCase());
    let y = null;
    if (m === j.UNKNOWN && (m = j.parse(b)), t instanceof ArrayBuffer && t.byteLength >= 2 && m === j.DCM) {
      const E = new Uint8Array(t);
      (E[0] === 92 && E[1] === 1 || E[1] === 92 && E[0] === 1) && (m = j.NII);
    }
    switch (F.imageType = m, m) {
      case j.DCM_FOLDER:
      case j.DCM_MANIFEST:
      case j.DCM:
        return;
      case j.FIB:
        [y, F.v1] = await F.readFIB(t);
        break;
      case j.MIH:
      case j.MIF:
        y = await F.readMIF(t, a);
        break;
      case j.NHDR:
      case j.NRRD:
        if (y = await un.readNrrd(F, t), y === null)
          throw new Error(`Failed to parse NHDR/NRRD file ${i}`);
        break;
      case j.MHD:
      case j.MHA:
        y = await F.readMHA(t, a);
        break;
      case j.MGH:
      case j.MGZ:
        if (y = await cn.readMgh(F, t), y === null)
          throw new Error(`Failed to parse MGH/MGZ file ${i}`);
        break;
      case j.SRC:
        y = await F.readSRC(t);
        break;
      case j.V:
        y = F.readECAT(t);
        break;
      case j.V16:
        y = F.readV16(t);
        break;
      case j.VMR:
        y = F.readVMR(t);
        break;
      case j.HEAD:
        y = await F.readHEAD(t, a);
        break;
      case j.BMP:
        y = await F.readBMP(t);
        break;
      case j.NPY:
        y = await F.readNPY(t);
        break;
      case j.NPZ:
        y = await F.readNPZ(t);
        break;
      case j.ZARR:
        y = await F.readZARR(t, v);
        break;
      case j.NII:
        if (y = await dn.readNifti(F, t, a), y === null)
          throw new Error(`Failed to parse NIfTI file ${i}.`);
        break;
      default:
        throw new Error("Image type not supported");
    }
    return F.init(
      t,
      i,
      s,
      r,
      a,
      n,
      o,
      l,
      c,
      h,
      f,
      d,
      u,
      m,
      g,
      p,
      A,
      x,
      w,
      y
    ), F;
  }
  // not included in public docs
  // detect difference between voxel grid and world space
  // https://github.com/afni/afni/blob/25e77d564f2c67ff480fa99a7b8e48ec2d9a89fc/src/thd_coords.c#L717
  computeObliqueAngle(t) {
    const i = mt(t);
    Ut(i, t);
    const s = Math.sqrt(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]), r = Math.max(Math.max(Math.abs(i[0]), Math.abs(i[1])), Math.abs(i[2])) / s, a = Math.sqrt(i[4] * i[4] + i[5] * i[5] + i[6] * i[6]), n = Math.max(Math.max(Math.abs(i[4]), Math.abs(i[5])), Math.abs(i[6])) / a, o = Math.sqrt(i[8] * i[8] + i[9] * i[9] + i[10] * i[10]), l = Math.max(Math.max(Math.abs(i[8]), Math.abs(i[9])), Math.abs(i[10])) / o, c = Math.min(Math.min(r, n), l);
    let h = Math.abs(Math.acos(c) * 180 / 3.141592653);
    return h > 0.01 ? V.warn("Warning voxels not aligned with world space: " + h + ` degrees from plumb.
`) : h = 0, h;
  }
  float32V1asRGBA(t) {
    t.length !== this.nVox3D * 3 && V.warn("float32V1asRGBA() expects " + this.nVox3D * 3 + "voxels, got ", +t.length);
    const i = t.slice();
    this.hdr.datatypeCode = 2304, this.nFrame4D = 1;
    for (let l = 4; l < 7; l++)
      this.hdr.dims[l] = 1;
    this.hdr.dims[0] = 3;
    const s = new Uint8Array(this.nVox3D * 4);
    let r = 1;
    for (let l = 0; l < this.nVox3D * 3; l++)
      isNaN(i[l]) || (r = Math.max(r, Math.abs(i[l])));
    const a = 255 / r, n = this.nVox3D * 2;
    let o = 0;
    for (let l = 0; l < this.nVox3D; l++) {
      const c = i[l], h = i[l + this.nVox3D], f = i[l + n];
      s[o] = Math.abs(c * a), s[o + 1] = Math.abs(h * a), s[o + 2] = Math.abs(f * a);
      const d = +(c > 0) * 1, u = +(h > 0) * 2, m = +(f > 0) * 4;
      let g = 248 + d + u + m;
      Math.abs(c) + Math.abs(h) + Math.abs(f) < 0.1 && (g = 0), s[o + 3] = g, o += 4;
    }
    return s;
  }
  loadImgV1(t = !1, i = !1, s = !1) {
    let r = this.v1;
    if (!r && this.nFrame4D === 3 && this.img.constructor === Float32Array && (r = this.img.slice()), !r)
      return V.warn("Image does not have V1 data"), !1;
    if (t)
      for (let a = 0; a < this.nVox3D; a++)
        r[a] = -r[a];
    if (i)
      for (let a = this.nVox3D; a < 2 * this.nVox3D; a++)
        r[a] = -r[a];
    if (s)
      for (let a = 2 * this.nVox3D; a < 3 * this.nVox3D; a++)
        r[a] = -r[a];
    return this.img = this.float32V1asRGBA(r), !0;
  }
  // not included in public docs
  // detect difference between voxel grid and world space
  calculateOblique() {
    if (!this.matRAS)
      throw new Error("matRAS not defined");
    if (this.pixDimsRAS === void 0)
      throw new Error("pixDimsRAS not defined");
    if (!this.dimsRAS)
      throw new Error("dimsRAS not defined");
    this.oblique_angle = this.computeObliqueAngle(this.matRAS);
    const t = this.vox2mm([0, 0, 0], this.matRAS), i = this.vox2mm([1 / this.pixDimsRAS[1], 0, 0], this.matRAS), s = this.vox2mm([0, 1 / this.pixDimsRAS[2], 0], this.matRAS), r = this.vox2mm([0, 0, 1 / this.pixDimsRAS[3]], this.matRAS);
    ot(i, i, t), ot(s, s, t), ot(r, r, t);
    const a = Pt(
      i[0],
      i[1],
      i[2],
      0,
      s[0],
      s[1],
      s[2],
      0,
      r[0],
      r[1],
      r[2],
      0,
      0,
      0,
      0,
      1
    );
    this.obliqueRAS = mt(a);
    const n = Math.abs(90 - Ri(i, s) * (180 / Math.PI)), o = Math.abs(90 - Ri(i, r) * (180 / Math.PI)), l = Math.abs(90 - Ri(s, r) * (180 / Math.PI));
    this.maxShearDeg = Math.max(Math.max(n, o), l), this.maxShearDeg > 0.1 && V.warn("Warning: voxels are rhomboidal, maximum shear is %f degrees.", this.maxShearDeg);
    const c = ht(this.dimsRAS[1], this.dimsRAS[2], this.dimsRAS[3], 1), h = mt(this.matRAS);
    Ut(h, h);
    const f = ht(-0.5, -0.5, -0.5, 0);
    me(h, h, O(f[0], f[1], f[2])), h[0] *= c[0], h[1] *= c[0], h[2] *= c[0], h[4] *= c[1], h[5] *= c[1], h[6] *= c[1], h[8] *= c[2], h[9] *= c[2], h[10] *= c[2], this.frac2mm = mt(h);
    const d = this.pixDimsRAS[1], u = this.pixDimsRAS[2], m = this.pixDimsRAS[3], g = mt(h);
    g[0] = d * c[0], g[1] = 0, g[2] = 0, g[4] = 0, g[5] = u * c[1], g[6] = 0, g[8] = 0, g[9] = 0, g[10] = m * c[2];
    const p = this.mm2vox([0, 0, 0], !0);
    g[12] = (-p[0] - 0.5) * d, g[13] = (-p[1] - 0.5) * u, g[14] = (-p[2] - 0.5) * m, this.frac2mmOrtho = mt(g), this.extentsMinOrtho = [g[12], g[13], g[14]], this.extentsMaxOrtho = [g[0] + g[12], g[5] + g[13], g[10] + g[14]], this.mm2ortho = it(), Vt(this.mm2ortho, a);
  }
  // not included in public docs
  // convert AFNI head/brik space to NIfTI format
  // https://github.com/afni/afni/blob/d6997e71f2b625ac1199460576d48f3136dac62c/src/thd_niftiwrite.c#L315
  THD_daxes_to_NIFTI(t, i, s) {
    const r = this.hdr;
    if (r === null)
      throw new Error("HDR is not set");
    r.sform_code = 2;
    const a = "xxyyzzg";
    let n = -1, o = -1, l = -1;
    const c = ["x", "y", "z"];
    c[0] = a[s[0]], c[1] = a[s[1]], c[2] = a[s[2]];
    const h = t.slice(0, 3), f = i.slice(0, 3);
    for (let d = 0; d < 3; d++)
      c[d] === "x" ? n = d : c[d] === "y" ? o = d : l = d;
    n < 0 || o < 0 || l < 0 || n === o || n === l || o === l || (r.pixDims[1] = Math.abs(h[0]), r.pixDims[2] = Math.abs(h[1]), r.pixDims[3] = Math.abs(h[2]), r.affine = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ], r.affine[0][n] = -h[n], r.affine[1][o] = -h[o], r.affine[2][l] = h[l], r.affine[0][3] = -f[n], r.affine[1][3] = -f[o], r.affine[2][3] = f[l]);
  }
  // not included in public docs
  // determine spacing voxel centers (rows, columns, slices)
  SetPixDimFromSForm() {
    if (!this.hdr)
      throw new Error("hdr not defined");
    const t = this.hdr.affine, i = Pt(
      t[0][0],
      t[0][1],
      t[0][2],
      t[0][3],
      t[1][0],
      t[1][1],
      t[1][2],
      t[1][3],
      t[2][0],
      t[2][1],
      t[2][2],
      t[2][3],
      t[3][0],
      t[3][1],
      t[3][2],
      t[3][3]
    ), s = this.vox2mm([0, 0, 0], i), r = this.vox2mm([1, 0, 0], i);
    ot(r, r, s);
    const a = this.vox2mm([0, 1, 0], i);
    ot(a, a, s);
    const n = this.vox2mm([0, 0, 1], i);
    ot(n, n, s), this.hdr.pixDims[1] = $t(r), this.hdr.pixDims[2] = $t(a), this.hdr.pixDims[3] = $t(n);
  }
  // not included in public docs
  // read DICOM format image and treat it like a NIfTI
  // -----------------
  // readDICOM(buf: ArrayBuffer | ArrayBuffer[]): ArrayBuffer {
  //   this.series = new daikon.Series()
  //   // parse DICOM file
  //   if (Array.isArray(buf)) {
  //     for (let i = 0; i < buf.length; i++) {
  //       const dataview = new DataView(buf[i])
  //       const image = daikon.Series.parseImage(dataview)
  //       if (image === null) {
  //         log.error(daikon.Series.parserError)
  //       } else if (image.hasPixelData()) {
  //         // if it's part of the same series, add it
  //         if (this.series.images.length === 0 || image.getSeriesId() === this.series.images[0].getSeriesId()) {
  //           this.series.addImage(image)
  //         }
  //       } // if hasPixelData
  //     } // for i
  //   } else {
  //     // not a dicom folder drop
  //     const image = daikon.Series.parseImage(new DataView(buf))
  //     if (image === null) {
  //       log.error(daikon.Series.parserError)
  //     } else if (image.hasPixelData()) {
  //       // if it's part of the same series, add it
  //       if (this.series.images.length === 0 || image.getSeriesId() === this.series.images[0].getSeriesId()) {
  //         this.series.addImage(image)
  //       }
  //     }
  //   }
  //   // order the image files, determines number of frames, etc.
  //   this.series.buildSeries()
  //   // output some header info
  //   this.hdr = new nifti.NIFTI1()
  //   const hdr = this.hdr
  //   hdr.scl_inter = 0
  //   hdr.scl_slope = 1
  //   if (this.series.images[0].getDataScaleIntercept()) {
  //     hdr.scl_inter = this.series.images[0].getDataScaleIntercept()
  //   }
  //   if (this.series.images[0].getDataScaleSlope()) {
  //     hdr.scl_slope = this.series.images[0].getDataScaleSlope()
  //   }
  //   hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0]
  //   hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0]
  //   hdr.dims[1] = this.series.images[0].getCols()
  //   hdr.dims[2] = this.series.images[0].getRows()
  //   hdr.dims[3] = this.series.images[0].getNumberOfFrames()
  //   if (this.series.images.length > 1) {
  //     if (hdr.dims[3] > 1) {
  //       log.debug('To Do: multiple slices per file and multiple files (XA30 DWI)')
  //     }
  //     hdr.dims[3] = this.series.images.length
  //   }
  //   const rc = this.series.images[0].getPixelSpacing() // TODO: order?
  //   hdr.pixDims[1] = rc[0]
  //   hdr.pixDims[2] = rc[1]
  //   if (this.series.images.length > 1) {
  //     // Multiple slices. The depth of a pixel is the physical distance between offsets. This is not the same as slice
  //     // spacing for tilted slices (skew).
  //     const p0 = vec3.fromValues(...(this.series.images[0].getImagePosition() as [number, number, number]))
  //     const p1 = vec3.fromValues(...(this.series.images[1].getImagePosition() as [number, number, number]))
  //     const n = vec3.fromValues(0, 0, 0)
  //     vec3.subtract(n, p0, p1)
  //     hdr.pixDims[3] = vec3.length(n)
  //   } else {
  //     // Single slice. Use the slice thickness as pixel depth.
  //     hdr.pixDims[3] = this.series.images[0].getSliceThickness()
  //   }
  //   hdr.pixDims[4] = this.series.images[0].getTR() / 1000.0 // msec -> sec
  //   const dt = this.series.images[0].getDataType() // 2=int,3=uint,4=float,
  //   const bpv = this.series.images[0].getBitsAllocated()
  //   hdr.numBitsPerVoxel = bpv
  //   this.hdr.littleEndian = this.series.images[0].littleEndian
  //   if (bpv === 8 && dt === 2) {
  //     hdr.datatypeCode = NiiDataType.DT_INT8
  //   } else if (bpv === 8 && dt === 3) {
  //     hdr.datatypeCode = NiiDataType.DT_UINT8
  //   } else if (bpv === 16 && dt === 2) {
  //     hdr.datatypeCode = NiiDataType.DT_INT16
  //   } else if (bpv === 16 && dt === 3) {
  //     hdr.datatypeCode = NiiDataType.DT_UINT16
  //   } else if (bpv === 32 && dt === 2) {
  //     hdr.datatypeCode = NiiDataType.DT_INT32
  //   } else if (bpv === 32 && dt === 3) {
  //     hdr.datatypeCode = NiiDataType.DT_UINT32
  //   } else if (bpv === 32 && dt === 4) {
  //     hdr.datatypeCode = NiiDataType.DT_FLOAT32
  //   } else if (bpv === 64 && dt === 4) {
  //     hdr.datatypeCode = NiiDataType.DT_FLOAT64
  //   } else if (bpv === 1) {
  //     hdr.datatypeCode = NiiDataType.DT_BINARY
  //   } else {
  //     log.warn('Unsupported DICOM format: ' + dt + ' ' + bpv)
  //   }
  //   const voxelDimensions = hdr.pixDims.slice(1, 4)
  //   const m = getBestTransform(
  //     this.series.images[0].getImageDirections(),
  //     voxelDimensions,
  //     this.series.images[0].getImagePosition()
  //   )
  //   if (m) {
  //     hdr.sform_code = 1
  //     hdr.affine = [
  //       [m[0][0], m[0][1], m[0][2], m[0][3]],
  //       [m[1][0], m[1][1], m[1][2], m[1][3]],
  //       [m[2][0], m[2][1], m[2][2], m[2][3]],
  //       [0, 0, 0, 1]
  //     ]
  //   }
  //   let data
  //   let length = this.series.validatePixelDataLength(this.series.images[0])
  //   const buffer = new Uint8Array(new ArrayBuffer(length * this.series.images.length))
  //   // implementation copied from:
  //   // https://github.com/rii-mango/Daikon/blob/bbe08bad9758dfbdf31ca22fb79048c7bad85706/src/series.js#L496
  //   for (let i = 0; i < this.series.images.length; i++) {
  //     if (this.series.isMosaic) {
  //       data = this.series.getMosaicData(this.series.images[i], this.series.images[i].getPixelDataBytes())
  //     } else {
  //       data = this.series.images[i].getPixelDataBytes()
  //     }
  //     length = this.series.validatePixelDataLength(this.series.images[i])
  //     this.series.images[i].clearPixelData()
  //     buffer.set(new Uint8Array(data, 0, length), length * i)
  //   } // for images.length
  //   return buffer.buffer
  // } // readDICOM()
  // -----------------------
  // not included in public docs
  // read ECAT7 format image
  // https://github.com/openneuropet/PET2BIDS/tree/28aae3fab22309047d36d867c624cd629c921ca6/ecat_validation/ecat_info
  readECAT(t) {
    this.hdr = new Z();
    const i = this.hdr;
    i.dims = [3, 1, 1, 1, 0, 0, 0, 0], i.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const s = new DataView(t), r = s.getInt32(0, !1), a = s.getInt16(50, !1);
    if (r !== 1296127058 || a < 1 || a > 14)
      throw new Error("Not a valid ECAT file");
    let n = 512, o = 0;
    const l = [];
    let c = new Float32Array();
    for (; ; ) {
      const h = s.getInt32(n, !1), f = s.getInt32(n + 12, !1);
      if (h + f !== 31)
        break;
      let d = n + 20, u = 0, m = 0;
      for (; u < 31 && (m = s.getInt32(d, !1), d += 16, m !== 0); ) {
        u++;
        let g = m * 512;
        const p = g - 512, A = s.getUint16(p, !1);
        i.dims[1] = s.getUint16(p + 4, !1), i.dims[2] = s.getUint16(p + 6, !1), i.dims[3] = s.getUint16(p + 8, !1);
        const x = s.getFloat32(p + 26, !1);
        i.pixDims[1] = s.getFloat32(p + 34, !1) * 10, i.pixDims[2] = s.getFloat32(p + 38, !1) * 10, i.pixDims[3] = s.getFloat32(p + 42, !1) * 10, i.pixDims[4] = s.getUint32(p + 46, !1) / 1e3, l.push(i.pixDims[4]);
        const w = i.dims[1] * i.dims[2] * i.dims[3], v = new Float32Array(w);
        if (A === 1)
          for (let C = 0; C < w; C++)
            v[C] = s.getUint8(g) * x, g++;
        else if (A === 6)
          for (let C = 0; C < w; C++)
            v[C] = s.getUint16(g, !1) * x, g += 2;
        else if (A === 7)
          for (let C = 0; C < w; C++)
            v[C] = s.getUint32(g, !1) * x, g += 4;
        else
          V.warn("Unknown ECAT data type " + A);
        const F = c.slice(0);
        c = new Float32Array(F.length + v.length), c.set(F), c.set(v, F.length), o++;
      }
      if (m === 0)
        break;
      n += 512;
    }
    if (i.dims[4] = o, i.pixDims[4] = l[0], o > 1) {
      i.dims[0] = 4;
      let h = !1;
      for (let f = 0; f < o; f++)
        l[f] !== l[0] && (h = !0);
      h && V.warn("Frame durations vary");
    }
    return i.sform_code = 1, i.affine = [
      [-i.pixDims[1], 0, 0, (i.dims[1] - 2) * 0.5 * i.pixDims[1]],
      [0, -i.pixDims[2], 0, (i.dims[2] - 2) * 0.5 * i.pixDims[2]],
      [0, 0, -i.pixDims[3], (i.dims[3] - 2) * 0.5 * i.pixDims[3]],
      [0, 0, 0, 1]
    ], i.numBitsPerVoxel = 32, i.datatypeCode = 16, c.buffer;
  }
  // readECAT()
  readV16(t) {
    this.hdr = new Z();
    const i = this.hdr;
    i.dims = [3, 1, 1, 1, 0, 0, 0, 0], i.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const s = new DataView(t);
    return i.dims[1] = s.getUint16(0, !0), i.dims[2] = s.getUint16(2, !0), i.dims[3] = s.getUint16(4, !0), 2 * i.dims[1] * i.dims[2] * i.dims[3] + 6 !== t.byteLength && V.warn("This does not look like a valid BrainVoyager V16 file"), i.numBitsPerVoxel = 16, i.datatypeCode = 512, V.warn("Warning: V16 files have no spatial transforms"), i.affine = [
      [0, 0, -i.pixDims[1], (i.dims[1] - 2) * 0.5 * i.pixDims[1]],
      [-i.pixDims[2], 0, 0, (i.dims[2] - 2) * 0.5 * i.pixDims[2]],
      [0, -i.pixDims[3], 0, (i.dims[3] - 2) * 0.5 * i.pixDims[3]],
      [0, 0, 0, 1]
    ], i.littleEndian = !0, t.slice(6);
  }
  // readV16()
  async readNPY(t) {
    function i(v) {
      return {
        "|b1": 1,
        // Boolean
        "<i1": 1,
        // Int8
        "<u1": 1,
        // UInt8
        "<i2": 2,
        // Int16
        "<u2": 2,
        // UInt16
        "<i4": 4,
        // Int32
        "<u4": 4,
        // UInt32
        "<f4": 4,
        // Float32
        "<f8": 8
        // Float64
      }[v] ?? 1;
    }
    function s(v) {
      return {
        "|b1": 2,
        // DT_BINARY
        "<i1": 256,
        // DT_INT8
        "<u1": 2,
        // DT_UINT8
        "<i2": 4,
        // DT_INT16
        "<u2": 512,
        // DT_UINT16
        "<i4": 8,
        // DT_INT32
        "<u4": 768,
        // DT_UINT32
        "<f4": 16,
        // DT_FLOAT32
        "<f8": 64
        // DT_FLOAT64
      }[v] ?? 16;
    }
    const r = new DataView(t), a = [r.getUint8(0), r.getUint8(1), r.getUint8(2), r.getUint8(3), r.getUint8(4), r.getUint8(5)], n = [147, 78, 85, 77, 80, 89];
    if (!a.every((v, F) => v === n[F]))
      throw new Error("Not a valid NPY file: Magic number mismatch");
    const o = r.getUint16(8, !0), l = new TextDecoder("utf-8").decode(t.slice(10, 10 + o)), c = l.match(/'shape': \((.*?)\)/);
    if (!c)
      throw new Error("Invalid NPY header: Shape not found");
    const h = c[1].split(",").map((v) => v.trim()).filter((v) => v !== "").map(Number), f = l.match(/'descr': '([^']+)'/);
    if (!f)
      throw new Error("Invalid NPY header: Data type not found");
    const d = f[1], u = h.reduce((v, F) => v * F, 1), m = 10 + o, g = t.slice(m, m + u * i(d)), p = h.length > 0 ? h[h.length - 1] : 1, A = h.length > 1 ? h[h.length - 2] : 1, x = h.length > 2 ? h[h.length - 3] : 1;
    this.hdr = new Z();
    const w = this.hdr;
    return w.dims = [3, p, A, x, 0, 0, 0, 0], w.pixDims = [1, 1, 1, 1, 1, 0, 0, 0], w.affine = [
      [w.pixDims[1], 0, 0, -(w.dims[1] - 2) * 0.5 * w.pixDims[1]],
      [0, -w.pixDims[2], 0, (w.dims[2] - 2) * 0.5 * w.pixDims[2]],
      [0, 0, -w.pixDims[3], (w.dims[3] - 2) * 0.5 * w.pixDims[3]],
      [0, 0, 0, 1]
    ], w.numBitsPerVoxel = i(d) * 8, w.datatypeCode = s(d), g;
  }
  async readNPZ(t) {
    const i = new sn(t);
    for (let s = 0; s < i.entries.length; s++) {
      const r = i.entries[s];
      if (r.fileName.toLowerCase().endsWith(".npy")) {
        const a = await r.extract();
        return await this.readNPY(a.buffer);
      }
    }
  }
  async imageDataFromArrayBuffer(t) {
    return new Promise((i, s) => {
      const r = new Blob([t]), a = URL.createObjectURL(r), n = new Image();
      n.crossOrigin = "Anonymous", n.src = a, n.onload = () => {
        URL.revokeObjectURL(a);
        const o = document.createElement("canvas");
        o.width = n.width, o.height = n.height;
        const l = o.getContext("2d");
        if (!l) {
          s(new Error("Failed to get 2D context"));
          return;
        }
        l.drawImage(n, 0, 0), i(l.getImageData(0, 0, n.width, n.height));
      }, n.onerror = (o) => {
        URL.revokeObjectURL(a), s(o);
      };
    });
  }
  async readBMP(t) {
    const i = await this.imageDataFromArrayBuffer(t), { width: s, height: r, data: a } = i;
    this.hdr = new Z();
    const n = this.hdr;
    n.dims = [3, s, r, 1, 0, 0, 0, 0], n.pixDims = [1, 1, 1, 1, 1, 0, 0, 0], n.affine = [
      [n.pixDims[1], 0, 0, -(n.dims[1] - 2) * 0.5 * n.pixDims[1]],
      [0, -n.pixDims[2], 0, (n.dims[2] - 2) * 0.5 * n.pixDims[2]],
      [0, 0, -n.pixDims[3], (n.dims[3] - 2) * 0.5 * n.pixDims[3]],
      [0, 0, 0, 1]
    ], n.numBitsPerVoxel = 8, n.datatypeCode = 2304;
    let o = !0;
    for (let l = 0; l < a.length; l += 4)
      if (a[l] !== a[l + 1] || a[l] !== a[l + 2]) {
        o = !1;
        break;
      }
    if (o) {
      n.datatypeCode = 2;
      const l = new Uint8Array(s * r);
      for (let c = 0, h = 0; c < a.length; c += 4, h++)
        l[h] = a[c];
      return l.buffer;
    }
    return a.buffer;
  }
  async readZARR(t, i) {
    let { width: s, height: r, depth: a = 1, data: n } = i ?? {}, o = s * r * a * 3, l = o === n.length;
    if (l || (o = s * r * a, a === 3 && (l = !0, a = 1)), o !== n.length)
      throw new Error(`Expected RGB ${s}${r}${a}3 =  ${o}, but ZARR length ${n.length}`);
    this.hdr = new Z();
    const c = this.hdr;
    if (c.dims = [3, s, r, a, 1, 1, 1, 1], c.pixDims = [1, 1, 1, 1, 0, 0, 0, 0], c.affine = [
      [c.pixDims[1], 0, 0, -(c.dims[1] - 2) * 0.5 * c.pixDims[1]],
      [0, -c.pixDims[2], 0, (c.dims[2] - 2) * 0.5 * c.pixDims[2]],
      [0, 0, -c.pixDims[3], (c.dims[3] - 2) * 0.5 * c.pixDims[3]],
      [0, 0, 0, 1]
    ], !l) {
      if (c.numBitsPerVoxel = 8, c.datatypeCode = 2, n instanceof Uint8Array) {
        const m = new ArrayBuffer(n.length);
        return new Uint8Array(m).set(n), m;
      }
      return n;
    }
    c.numBitsPerVoxel = 24, c.datatypeCode = 128;
    function h(m, g, p, A) {
      const x = g * p, w = new Uint8Array(x * A * 3), v = new Array(A);
      for (let b = 0; b < A; b++)
        v[b] = x * 3 * b;
      let F = 0, C = 0;
      for (let b = 0; b < x; b++) {
        for (let y = 0; y < A; y++)
          w[v[y] + C] = m[F++], w[v[y] + C + 1] = m[F++], w[v[y] + C + 2] = m[F++];
        C += 3;
      }
      return w;
    }
    const f = h(n, c.dims[1], c.dims[2], c.dims[3]), d = new ArrayBuffer(f.length);
    return new Uint8Array(d).set(f), d;
  }
  // not included in public docs
  // read brainvoyager format VMR image
  // https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/343-developer-guide-2-6-the-format-of-vmr-files
  readVMR(t) {
    this.hdr = new Z();
    const i = this.hdr;
    i.dims = [3, 1, 1, 1, 0, 0, 0, 0], i.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const s = new DataView(t), r = s.getUint16(0, !0);
    r !== 4 && V.warn("Not a valid version 4 VMR image"), i.dims[1] = s.getUint16(2, !0), i.dims[2] = s.getUint16(4, !0), i.dims[3] = s.getUint16(6, !0);
    const a = i.dims[1] * i.dims[2] * i.dims[3];
    if (r >= 4) {
      let n = 8 + a;
      const o = s.getUint32(n + 88, !0);
      if (n = n + 92, o > 0) {
        const l = t.byteLength;
        for (let c = 0; c < o; c++) {
          for (; n < l && s.getUint8(n) !== 0; )
            n++;
          for (n++, n += 4; n < l && s.getUint8(n) !== 0; )
            n++;
          n++;
          const h = s.getUint32(n, !0);
          n += 4;
          for (let f = 0; f < h; f++)
            n += 4;
        }
      }
      i.pixDims[1] = s.getFloat32(n + 2, !0), i.pixDims[2] = s.getFloat32(n + 6, !0), i.pixDims[3] = s.getFloat32(n + 10, !0);
    }
    return V.warn("Warning: VMR spatial transform not implemented"), i.affine = [
      [0, 0, -i.pixDims[1], (i.dims[1] - 2) * 0.5 * i.pixDims[1]],
      [-i.pixDims[2], 0, 0, (i.dims[2] - 2) * 0.5 * i.pixDims[2]],
      [0, -i.pixDims[3], 0, (i.dims[3] - 2) * 0.5 * i.pixDims[3]],
      [0, 0, 0, 1]
    ], V.debug(i), i.numBitsPerVoxel = 8, i.datatypeCode = 2, t.slice(8, 8 + a);
  }
  // readVMR()
  // not included in public docs
  // read DSI-Studio FIB format image
  // https://dsi-studio.labsolver.org/doc/cli_data.html
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async readFIB(t) {
    this.hdr = new Z();
    const i = this.hdr;
    i.littleEndian = !1, i.dims = [3, 1, 1, 1, 0, 0, 0, 0], i.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const s = await H.readMatV4(t, !0);
    if (!("dimension" in s) || !("dti_fa" in s))
      throw new Error("Not a valid DSIstudio FIB file");
    const r = "index0" in s && "index1" in s && "index2" in s && "odf_vertices" in s;
    i.numBitsPerVoxel = 32, i.datatypeCode = 16, i.dims[1] = s.dimension[0], i.dims[2] = s.dimension[1], i.dims[3] = s.dimension[2], i.dims[4] = 1, i.pixDims[1] = s.voxel_size[0], i.pixDims[2] = s.voxel_size[1], i.pixDims[3] = s.voxel_size[2], i.sform_code = 1;
    const a = (i.dims[1] - 1) * 0.5 * i.pixDims[1], n = (i.dims[2] - 1) * 0.5 * i.pixDims[2], o = (i.dims[3] - 1) * 0.5 * i.pixDims[3];
    i.affine = [
      [i.pixDims[1], 0, 0, -a],
      [0, -i.pixDims[2], 0, n],
      [0, 0, i.pixDims[2], -o],
      [0, 0, 0, 1]
    ], i.littleEndian = !0;
    const l = i.dims[1] * i.dims[2] * i.dims[3], c = l * Math.ceil(i.numBitsPerVoxel / 8), h = c * i.dims[4], f = new Uint8Array(new ArrayBuffer(l * 4 * 3));
    if (r) {
      const g = i.dims[1] * i.dims[2] * i.dims[3], p = new Float32Array(g), A = new Float32Array(g), x = new Float32Array(g), w = s.index0, v = s.odf_vertices;
      for (let F = 0; F < g; F++) {
        const C = w[F] * 3;
        p[F] = v[C + 0], A[F] = v[C + 1], x[F] = -v[C + 2];
      }
      f.set(new Uint8Array(p.buffer, p.byteOffset, p.byteLength), 0 * c), f.set(new Uint8Array(A.buffer, A.byteOffset, A.byteLength), 1 * c), f.set(new Uint8Array(x.buffer, x.byteOffset, x.byteLength), 2 * c);
    }
    "report" in s && (i.description = new TextDecoder().decode(s.report.subarray(0, Math.min(79, s.report.byteLength))));
    const d = new Uint8Array(new ArrayBuffer(h)), u = Float32Array.from(s.dti_fa);
    if ("mask" in s) {
      let g = 1;
      "dti_fa_slope" in s && (g = s.dti_fa_slope[0]);
      let p = 1;
      "dti_fa_inter" in s && (p = s.dti_fa_inter[0]);
      const A = i.dims[1] * i.dims[2] * i.dims[3], x = s.mask, w = new Float32Array(A);
      let v = 0;
      for (let F = 0; F < A; F++)
        x[F] !== 0 && (w[F] = u[v] * g + p, v++);
      return [w.buffer, new Float32Array(f.buffer)];
    }
    const m = new Uint8Array(u.buffer, u.byteOffset, u.byteLength);
    return d.set(m, 0), [d.buffer, new Float32Array(f.buffer)];
  }
  // readFIB()
  // not included in public docs
  // read DSI-Studio SRC format image
  // https://dsi-studio.labsolver.org/doc/cli_data.html
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async readSRC(t) {
    this.hdr = new Z();
    const i = this.hdr;
    i.littleEndian = !1, i.dims = [3, 1, 1, 1, 0, 0, 0, 0], i.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    const s = await H.readMatV4(t);
    if (!("dimension" in s) || !("image0" in s))
      throw new Error("Not a valid DSIstudio SRC file");
    let r = 0, a = 0;
    for (const [u, m] of Object.entries(s))
      if (u.startsWith("image")) {
        if (r === 0 ? a = m.length : a !== m.length && (a = -1), m.constructor !== Uint16Array)
          throw new Error("DSIstudio SRC files always use Uint16 datatype");
        r++;
      }
    if (a < 1 || r < 1)
      throw new Error("SRC file not valid DSI Studio data. The image(s) should have the same length");
    i.numBitsPerVoxel = 16, i.datatypeCode = 512, i.dims[1] = s.dimension[0], i.dims[2] = s.dimension[1], i.dims[3] = s.dimension[2], i.dims[4] = r, i.dims[4] > 1 && (i.dims[0] = 4), i.pixDims[1] = s.voxel_size[0], i.pixDims[2] = s.voxel_size[1], i.pixDims[3] = s.voxel_size[2], i.sform_code = 1;
    const n = (i.dims[1] - 1) * 0.5 * i.pixDims[1], o = (i.dims[2] - 1) * 0.5 * i.pixDims[2], l = (i.dims[3] - 1) * 0.5 * i.pixDims[3];
    i.affine = [
      [i.pixDims[1], 0, 0, -n],
      [0, -i.pixDims[2], 0, o],
      [0, 0, i.pixDims[2], -l],
      [0, 0, 0, 1]
    ], i.littleEndian = !0;
    const c = i.dims[1] * i.dims[2] * i.dims[3] * (i.numBitsPerVoxel / 8), h = c * i.dims[4], f = new Uint8Array(new ArrayBuffer(h));
    let d = 0;
    for (let u = 0; u < r; u++) {
      const m = s[`image${u}`], g = new Uint8Array(m.buffer, m.byteOffset, m.byteLength);
      f.set(g, d), d += c;
    }
    return "report" in s && (i.description = new TextDecoder().decode(s.report.subarray(0, Math.min(79, s.report.byteLength)))), f.buffer;
  }
  // readSRC()
  // not included in public docs
  // read AFNI head/brik format image
  async readHEAD(t, i) {
    this.hdr = new Z();
    const s = this.hdr;
    s.dims[0] = 3, s.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
    let r = [0, 0, 0], a = [0, 0, 0], n = [1, 1, 1];
    const l = new TextDecoder().decode(t).split(/\r?\n/), c = (t.byteLength + 8) % 16, h = t.byteLength + (16 - c);
    V.debug(t.byteLength, "len", h);
    const f = new ArrayBuffer(h);
    new Uint8Array(f).set(new Uint8Array(t));
    const d = new Kr(h + 8, 42, f, !0);
    s.addExtension(d), s.extensionCode = 42, s.extensionFlag[0] = 1, s.extensionSize = h + 8;
    const u = l.length;
    let m = 0, g = !1;
    for (; m < u; ) {
      let A = l[m];
      if (m++, !A.startsWith("type"))
        continue;
      const x = A.includes("integer-attribute"), w = A.includes("float-attribute");
      if (A = l[m], m++, !A.startsWith("name"))
        continue;
      let v = A.split("= ");
      const F = v[1];
      A = l[m], m++, v = A.split("= ");
      let C = parseInt(v[1]);
      if (!(C < 1)) {
        if (A = l[m], m++, v = A.trim().split(/\s+/), w || x) {
          for (; v.length < C; ) {
            A = l[m], m++;
            const b = A.trim().split(/\s+/);
            v.push(...b);
          }
          for (let b = 0; b < C; b++)
            v[b] = parseFloat(v[b]);
        }
        switch (F) {
          case "BYTEORDER_STRING":
            v[0].includes("LSB_FIRST") ? s.littleEndian = !0 : v[0].includes("MSB_FIRST") && (s.littleEndian = !1);
            break;
          case "BRICK_TYPES":
            {
              s.dims[4] = C;
              const b = parseInt(v[0]);
              b === 0 ? (s.numBitsPerVoxel = 8, s.datatypeCode = 2) : b === 1 ? (s.numBitsPerVoxel = 16, s.datatypeCode = 4) : b === 3 ? (s.numBitsPerVoxel = 32, s.datatypeCode = 16) : V.warn("Unknown BRICK_TYPES ", b);
            }
            break;
          case "IJK_TO_DICOM_REAL":
            if (C < 12)
              break;
            g = !0, s.sform_code = 2, s.affine = [
              [-v[0], -v[1], -v[2], -v[3]],
              [-v[4], -v[5], -v[6], -v[7]],
              // TODO don't reuse items for numeric values
              [v[8], v[9], v[10], v[11]],
              [0, 0, 0, 1]
            ];
            break;
          case "DATASET_DIMENSIONS":
            C = Math.max(C, 3);
            for (let b = 0; b < C; b++)
              s.dims[b + 1] = v[b];
            break;
          case "ORIENT_SPECIFIC":
            r = v;
            break;
          case "ORIGIN":
            a = v;
            break;
          case "DELTA":
            n = v;
            break;
          case "TAXIS_FLOATS":
            s.pixDims[4] = v[0];
            break;
          default:
            V.warn("Unknown:", F);
        }
      }
    }
    g ? this.SetPixDimFromSForm() : this.THD_daxes_to_NIFTI(n, a, r);
    const p = s.numBitsPerVoxel / 8 * s.dims[1] * s.dims[2] * s.dims[3] * s.dims[4];
    if (!i)
      throw new Error("pairedImgData not set");
    return i.byteLength < p ? await H.decompressToBuffer(new Uint8Array(i)) : i.slice(0);
  }
  // not included in public docs
  // read ITK MHA format image
  // https://itk.org/Wiki/ITK/MetaIO/Documentation#Reading_a_Brick-of-Bytes_.28an_N-Dimensional_volume_in_a_single_file.29
  async readMHA(t, i) {
    const s = t.byteLength;
    if (s < 20)
      throw new Error("File too small to be VTK: bytes = " + t.byteLength);
    const r = new Uint8Array(t);
    let a = 0;
    function n(g) {
      return g === 10 || g === 13;
    }
    function o() {
      for (; a < s && n(r[a]); )
        a++;
      const g = a;
      for (; a < s && !n(r[a]); )
        a++;
      return a - g < 2 ? "" : new TextDecoder().decode(t.slice(g, a));
    }
    let l = o();
    this.hdr = new Z();
    const c = this.hdr;
    c.pixDims = [1, 1, 1, 1, 1, 0, 0, 0], c.dims = [1, 1, 1, 1, 1, 1, 1, 1], c.littleEndian = !0;
    let h = !1, f = !1;
    const d = jt(NaN, 0, 0, 0, 1, 0, 0, 0, 1), u = O(0, 0, 0);
    for (; l !== ""; ) {
      let g = l.split(" ");
      if (g.length > 2 && (g = g.slice(2)), l.startsWith("BinaryDataByteOrderMSB") && g[0].includes("False") && (c.littleEndian = !0), l.startsWith("BinaryDataByteOrderMSB") && g[0].includes("True") && (c.littleEndian = !1), l.startsWith("CompressedData") && g[0].includes("True") && (h = !0), l.startsWith("TransformMatrix"))
        for (let p = 0; p < 9; p++)
          d[p] = parseFloat(g[p]);
      if (l.startsWith("Offset"))
        for (let p = 0; p < Math.min(g.length, 3); p++)
          u[p] = parseFloat(g[p]);
      if (l.startsWith("ElementSpacing"))
        for (let p = 0; p < g.length; p++)
          c.pixDims[p + 1] = parseFloat(g[p]);
      if (l.startsWith("DimSize")) {
        c.dims[0] = g.length;
        for (let p = 0; p < g.length; p++)
          c.dims[p + 1] = parseInt(g[p]);
      }
      if (l.startsWith("ElementType"))
        switch (g[0]) {
          case "MET_UCHAR":
            c.numBitsPerVoxel = 8, c.datatypeCode = 2;
            break;
          case "MET_CHAR":
            c.numBitsPerVoxel = 8, c.datatypeCode = 256;
            break;
          case "MET_SHORT":
            c.numBitsPerVoxel = 16, c.datatypeCode = 4;
            break;
          case "MET_USHORT":
            c.numBitsPerVoxel = 16, c.datatypeCode = 512;
            break;
          case "MET_INT":
            c.numBitsPerVoxel = 32, c.datatypeCode = 8;
            break;
          case "MET_UINT":
            c.numBitsPerVoxel = 32, c.datatypeCode = 768;
            break;
          case "MET_FLOAT":
            c.numBitsPerVoxel = 32, c.datatypeCode = 16;
            break;
          case "MET_DOUBLE":
            c.numBitsPerVoxel = 64, c.datatypeCode = 64;
            break;
          default:
            throw new Error("Unsupported MHA data type: " + g[0]);
        }
      if (l.startsWith("ObjectType") && !g[0].includes("Image") && V.warn("Only able to read ObjectType = Image, not " + l), l.startsWith("ElementDataFile")) {
        g[0] !== "LOCAL" && (f = !0);
        break;
      }
      l = o();
    }
    const m = jt(c.pixDims[1], 0, 0, 0, c.pixDims[2], 0, 0, 0, c.pixDims[3]);
    for (Tr(d, d, m), c.affine = [
      [-d[0], -d[3], -d[6], -u[0]],
      [-d[1], -d[4], -d[7], -u[1]],
      [d[2], d[5], d[8], u[2]],
      [0, 0, 0, 1]
    ]; r[a] === 10; )
      a++;
    return c.vox_offset = a, f && i ? h ? await H.decompressToBuffer(new Uint8Array(i.slice(0))) : i.slice(0) : h ? await H.decompressToBuffer(new Uint8Array(t.slice(c.vox_offset))) : t.slice(c.vox_offset);
  }
  // readMHA()
  // not included in public docs
  // read mrtrix MIF format image
  // https://mrtrix.readthedocs.io/en/latest/getting_started/image_data.html#mrtrix-image-formats
  async readMIF(t, i) {
    this.hdr = new Z();
    const s = this.hdr;
    s.pixDims = [1, 1, 1, 1, 1, 0, 0, 0], s.dims = [1, 1, 1, 1, 1, 1, 1, 1];
    let r = t.byteLength;
    if (r < 20)
      throw new Error("File too small to be MIF: bytes = " + r);
    let a = new Uint8Array(t);
    a[0] === 31 && a[1] === 139 && (V.debug("MIF with GZ decompression"), t = await H.decompressToBuffer(new Uint8Array(t)), r = t.byteLength, a = new Uint8Array(t));
    let n = 0;
    function o() {
      for (; n < r && a[n] === 10; )
        n++;
      const M = n;
      for (; n < r && a[n] !== 10; )
        n++;
      return n++, n - M < 1 ? "" : new TextDecoder().decode(t.slice(M, n - 1));
    }
    let l = o();
    if (!l.startsWith("mrtrix image"))
      throw new Error("Not a valid MIF file");
    const c = [];
    let h = !1, f = 0, d = 0, u = !1;
    for (l = o(); n < r && !l.startsWith("END"); ) {
      let M = l.split(":");
      if (l = o(), M.length < 2)
        break;
      const B = M[0];
      M = M[1].split(",");
      for (let T = 0; T < M.length; T++)
        M[T] = M[T].trim();
      switch (B) {
        case "dim":
          s.dims[0] = M.length;
          for (let T = 0; T < M.length; T++)
            s.dims[T + 1] = parseInt(M[T]);
          break;
        case "vox":
          for (let T = 0; T < M.length; T++)
            s.pixDims[T + 1] = parseFloat(M[T]), isNaN(s.pixDims[T + 1]) && (s.pixDims[T + 1] = 0);
          break;
        case "layout":
          for (let T = 0; T < M.length; T++)
            c.push(parseInt(M[T]));
          break;
        case "datatype":
          {
            const T = M[0];
            T.startsWith("Bit") ? (h = !0, s.datatypeCode = 2) : T.startsWith("Int8") ? s.datatypeCode = 256 : T.startsWith("UInt8") ? s.datatypeCode = 2 : T.startsWith("Int16") ? s.datatypeCode = 4 : T.startsWith("UInt16") ? s.datatypeCode = 512 : T.startsWith("Int32") ? s.datatypeCode = 8 : T.startsWith("UInt32") ? s.datatypeCode = 768 : T.startsWith("Float32") ? s.datatypeCode = 16 : T.startsWith("Float64") ? s.datatypeCode = 64 : V.warn("Unsupported datatype " + T), T.includes("8") ? s.numBitsPerVoxel = 8 : T.includes("16") ? s.numBitsPerVoxel = 16 : T.includes("32") ? s.numBitsPerVoxel = 32 : T.includes("64") && (s.numBitsPerVoxel = 64), s.littleEndian = !0, T.endsWith("LE") && (s.littleEndian = !0), T.endsWith("BE") && (s.littleEndian = !1);
          }
          break;
        case "transform":
          if (f > 2 || M.length !== 4)
            break;
          s.affine[f][0] = parseFloat(M[0]), s.affine[f][1] = parseFloat(M[1]), s.affine[f][2] = parseFloat(M[2]), s.affine[f][3] = parseFloat(M[3]), f++;
          break;
        case "comments":
          s.description = M[0].substring(0, Math.min(79, M[0].length));
          break;
        case "RepetitionTime":
          d = parseFloat(M[0]);
          break;
        case "file":
          u = !M[0].startsWith(". "), u || (M = M[0].split(" "), s.vox_offset = parseInt(M[1]));
          break;
      }
    }
    const m = s.dims[0];
    m > 5 && V.warn("reader only designed for a maximum of 5 dimensions (XYZTD)");
    let g = 1;
    for (let M = 0; M < m; M++)
      g *= Math.max(s.dims[M + 1], 1);
    for (let M = 0; M < 3; M++)
      for (let B = 0; B < 3; B++)
        s.affine[M][B] *= s.pixDims[B + 1];
    V.debug("mif affine:" + s.affine[0]), d > 0 && (s.pixDims[4] = d), u && !i && V.warn("MIH header provided without paired image data");
    let p;
    if (i && u)
      p = i.slice(0);
    else if (h) {
      s.numBitsPerVoxel = 8;
      const M = new Uint8Array(g), B = t.slice(s.vox_offset, s.vox_offset + Math.ceil(g / 8)), T = new Uint8Array(B);
      let U = 0;
      for (let R = 0; R < g; R++) {
        const N = R % 8;
        M[R] = T[U] >> 7 - N & 1, N === 7 && U++;
      }
      p = M.buffer;
    } else
      p = t.slice(s.vox_offset, s.vox_offset + g * (s.numBitsPerVoxel / 8));
    c.length !== s.dims[0] && V.warn("dims does not match layout");
    let A = 1;
    const x = [1, 1, 1, 1, 1], w = [!1, !1, !1, !1, !1];
    for (let M = 0; M < c.length; M++)
      for (let B = 0; B < c.length; B++)
        Math.abs(c[B]) === M && (x[B] = A, (c[B] < 0 || Object.is(c[B], -0)) && (w[B] = !0), A *= s.dims[B + 1]);
    let v = H.range(0, s.dims[1] - 1, 1);
    w[0] && (v = H.range(s.dims[1] - 1, 0, -1));
    for (let M = 0; M < s.dims[1]; M++)
      v[M] *= x[0];
    let F = H.range(0, s.dims[2] - 1, 1);
    w[1] && (F = H.range(s.dims[2] - 1, 0, -1));
    for (let M = 0; M < s.dims[2]; M++)
      F[M] *= x[1];
    let C = H.range(0, s.dims[3] - 1, 1);
    w[2] && (C = H.range(s.dims[3] - 1, 0, -1));
    for (let M = 0; M < s.dims[3]; M++)
      C[M] *= x[2];
    let b = H.range(0, s.dims[4] - 1, 1);
    w[3] && (b = H.range(s.dims[4] - 1, 0, -1));
    for (let M = 0; M < s.dims[4]; M++)
      b[M] *= x[3];
    let y = H.range(0, s.dims[5] - 1, 1);
    w[4] && (y = H.range(s.dims[5] - 1, 0, -1));
    for (let M = 0; M < s.dims[5]; M++)
      y[M] *= x[4];
    let E = 0, S, D;
    switch (s.datatypeCode) {
      case 256:
        S = new Int8Array(p), D = new Int8Array(g);
        break;
      case 2:
        S = new Uint8Array(p), D = new Uint8Array(g);
        break;
      case 4:
        S = new Int16Array(p), D = new Int16Array(g);
        break;
      case 512:
        S = new Uint16Array(p), D = new Uint16Array(g);
        break;
      case 8:
        S = new Int32Array(p), D = new Int32Array(g);
        break;
      case 768:
        S = new Uint32Array(p), D = new Uint32Array(g);
        break;
      case 16:
        S = new Float32Array(p), D = new Float32Array(g);
        break;
      case 64:
        S = new Float64Array(p), D = new Float64Array(g);
        break;
      default:
        throw new Error("unknown datatypeCode");
    }
    for (let M = 0; M < s.dims[5]; M++)
      for (let B = 0; B < s.dims[4]; B++)
        for (let T = 0; T < s.dims[3]; T++)
          for (let U = 0; U < s.dims[2]; U++)
            for (let R = 0; R < s.dims[1]; R++)
              D[E] = S[v[R] + F[U] + C[T] + b[B] + y[M]], E++;
    return D.buffer;
  }
  // readMIF()
  // not included in public docs
  // Transform to orient NIfTI image to Left->Right,Posterior->Anterior,Inferior->Superior (48 possible permutations)
  calculateRAS() {
    if (!this.hdr)
      throw new Error("hdr not set");
    const t = this.hdr.affine, i = this.hdr, s = jt(
      Math.abs(t[0][0]),
      Math.abs(t[0][1]),
      Math.abs(t[0][2]),
      Math.abs(t[1][0]),
      Math.abs(t[1][1]),
      Math.abs(t[1][2]),
      Math.abs(t[2][0]),
      Math.abs(t[2][1]),
      Math.abs(t[2][2])
    ), r = [1, 1, 1];
    s[3] > s[0] && (r[0] = 2), s[6] > s[0] && s[6] > s[3] && (r[0] = 3), r[1] = 1, r[0] === 1 ? s[4] > s[7] ? r[1] = 2 : r[1] = 3 : r[0] === 2 ? s[1] > s[7] ? r[1] = 1 : r[1] = 3 : s[1] > s[4] ? r[1] = 1 : r[1] = 2, r[2] = 6 - r[1] - r[0];
    let a = [1, 2, 3];
    a[r[0] - 1] = 1, a[r[1] - 1] = 2, a[r[2] - 1] = 3;
    let n = Pt(
      t[0][0],
      t[0][1],
      t[0][2],
      t[0][3],
      t[1][0],
      t[1][1],
      t[1][2],
      t[1][3],
      t[2][0],
      t[2][1],
      t[2][2],
      t[2][3],
      0,
      0,
      0,
      1
    );
    this.mm000 = this.vox2mm([-0.5, -0.5, -0.5], n), this.mm100 = this.vox2mm([i.dims[1] - 0.5, -0.5, -0.5], n), this.mm010 = this.vox2mm([-0.5, i.dims[2] - 0.5, -0.5], n), this.mm001 = this.vox2mm([-0.5, -0.5, i.dims[3] - 0.5], n);
    const o = it();
    Ln(o, n);
    for (let p = 0; p < 3; p++)
      for (let A = 0; A < 3; A++)
        o[p * 4 + A] = n[p * 4 + a[A] - 1];
    const l = [0, 0, 0];
    o[0] < 0 && (l[0] = 1), o[5] < 0 && (l[1] = 1), o[10] < 0 && (l[2] = 1), this.dimsRAS = [i.dims[0], i.dims[a[0]], i.dims[a[1]], i.dims[a[2]]], this.pixDimsRAS = [i.pixDims[0], i.pixDims[a[0]], i.pixDims[a[1]], i.pixDims[a[2]]], this.permRAS = a.slice();
    for (let p = 0; p < 3; p++)
      l[p] === 1 && (this.permRAS[p] = -this.permRAS[p]);
    if (this.arrayEquals(a, [1, 2, 3]) && this.arrayEquals(l, [0, 0, 0])) {
      this.toRAS = it(), this.matRAS = mt(n), this.calculateOblique(), this.img2RASstep = [1, this.dimsRAS[1], this.dimsRAS[1] * this.dimsRAS[2]], this.img2RASstart = [0, 0, 0];
      return;
    }
    Vr(n), n[0 + 0 * 4] = 1 - l[0] * 2, n[1 + 1 * 4] = 1 - l[1] * 2, n[2 + 2 * 4] = 1 - l[2] * 2, n[3 + 0 * 4] = (i.dims[a[0]] - 1) * l[0], n[3 + 1 * 4] = (i.dims[a[1]] - 1) * l[1], n[3 + 2 * 4] = (i.dims[a[2]] - 1) * l[2];
    const c = it();
    Vt(c, n), re(c, c, o), this.matRAS = mt(c), n = Pt(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1), n[a[0] - 1 + 0 * 4] = -l[0] * 2 + 1, n[a[1] - 1 + 1 * 4] = -l[1] * 2 + 1, n[a[2] - 1 + 2 * 4] = -l[2] * 2 + 1, n[3 + 0 * 4] = l[0], n[3 + 1 * 4] = l[1], n[3 + 2 * 4] = l[2], this.toRAS = mt(n), n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, (this.permRAS[0] === -1 || this.permRAS[1] === -1 || this.permRAS[2] === -1) && (n[12] = i.dims[1] - 1), n[13] = 0, (this.permRAS[0] === -2 || this.permRAS[1] === -2 || this.permRAS[2] === -2) && (n[13] = i.dims[2] - 1), n[14] = 0, (this.permRAS[0] === -3 || this.permRAS[1] === -3 || this.permRAS[2] === -3) && (n[14] = i.dims[3] - 1), this.toRASvox = mt(n), V.debug(this.hdr.dims), V.debug(this.dimsRAS);
    const h = this.hdr;
    a = this.permRAS;
    const f = [Math.abs(a[0]), Math.abs(a[1]), Math.abs(a[2])], d = [h.dims[f[0]], h.dims[f[1]], h.dims[f[2]]], u = [1, h.dims[1], h.dims[1] * h.dims[2]], m = [u[f[0] - 1], u[f[1] - 1], u[f[2] - 1]], g = [0, 0, 0];
    for (let p = 0; p < 3; p++)
      a[p] < 0 && (g[p] = m[p] * (d[p] - 1), m[p] = -m[p]);
    this.img2RASstep = m, this.img2RASstart = g, this.calculateOblique();
  }
  // Reorient raw header data to RAS
  // assume single volume, use nVolumes to specify, set nVolumes = 0 for same as input
  async hdr2RAS(t = 1) {
    if (!this.permRAS)
      throw new Error("permRAS undefined");
    if (!this.hdr)
      throw new Error("hdr undefined");
    const i = Mi({ ...this.hdr, vox_offset: 352 }, !1), s = await Ie(i.buffer, !0);
    t === 1 ? (s.dims[0] = 3, s.dims[4] = 1) : t > 1 && (s.dims[0] = 4, s.dims[4] = t);
    const r = this.permRAS.slice();
    if (r[0] === 1 && r[1] === 2 && r[2] === 3)
      return s;
    s.qform_code = 0;
    for (let n = 1; n < 4; n++)
      s.dims[n] = this.dimsRAS[n];
    for (let n = 0; n < this.pixDimsRAS.length; n++)
      s.pixDims[n] = this.pixDimsRAS[n];
    let a = 0;
    for (let n = 0; n < 4; n++)
      for (let o = 0; o < 4; o++)
        s.affine[n][o] = this.matRAS[a], a++;
    return s;
  }
  // Reorient raw image data to RAS
  // note that GPU-based orient shader is much faster
  // returns single 3D volume even for 4D input. Use nVolume to select volume (0 indexed)
  img2RAS(t = 0) {
    if (!this.permRAS)
      throw new Error("permRAS undefined");
    if (!this.img)
      throw new Error("img undefined");
    if (!this.hdr)
      throw new Error("hdr undefined");
    const i = this.permRAS.slice();
    if (i[0] === 1 && i[1] === 2 && i[2] === 3)
      return this.img;
    const s = this.hdr, r = s.dims[1] * s.dims[2] * s.dims[3];
    let a = t * r;
    (a + r > this.img.length || a < 0) && (a = 0, V.warn(`img2RAS nVolume (${t}) out of bounds (${t}+1)${r} > ${this.img.length}`));
    const n = this.img.slice(0, r), o = [Math.abs(i[0]), Math.abs(i[1]), Math.abs(i[2])], l = [s.dims[o[0]], s.dims[o[1]], s.dims[o[2]]], c = [1, s.dims[1], s.dims[1] * s.dims[2]], h = [c[o[0] - 1], c[o[1] - 1], c[o[2] - 1]], f = [0, 0, 0];
    for (let u = 0; u < 3; u++)
      i[u] < 0 && (f[u] = h[u] * (l[u] - 1), h[u] = -h[u]);
    let d = 0;
    for (let u = 0; u < l[2]; u++) {
      const m = f[2] + u * h[2];
      for (let g = 0; g < l[1]; g++) {
        const p = f[1] + g * h[1];
        for (let A = 0; A < l[0]; A++) {
          const x = f[0] + A * h[0];
          n[d] = this.img[x + p + m + a], d++;
        }
      }
    }
    return n;
  }
  // img2RAS()
  // not included in public docs
  // convert voxel location (row, column slice, indexed from 0) to world space
  vox2mm(t, i) {
    const s = mt(i);
    Ut(s, s);
    const r = ht(t[0], t[1], t[2], 1);
    return Ct(r, r, s), O(r[0], r[1], r[2]);
  }
  // vox2mm()
  // not included in public docs
  // convert world space to voxel location (row, column slice, indexed from 0)
  mm2vox(t, i = !1) {
    if (!this.matRAS)
      throw new Error("matRAS undefined");
    const s = mt(this.matRAS), r = mt(s);
    Ut(r, s), Vt(r, r);
    const a = ht(t[0], t[1], t[2], 1);
    Ct(a, a, r);
    const n = O(a[0], a[1], a[2]);
    return i ? n : [Math.round(n[0]), Math.round(n[1]), Math.round(n[2])];
  }
  // vox2mm()
  // not included in public docs
  // returns boolean: are two arrays identical?
  // TODO this won't work for complex objects. Maybe use array-equal from NPM
  arrayEquals(t, i) {
    return Array.isArray(t) && Array.isArray(i) && t.length === i.length && t.every((s, r) => s === i[r]);
  }
  // not included in public docs
  // base function for niivue.setColormap()
  // colormaps are continuously interpolated between 256 values (0..256)
  setColormap(t) {
    this._colormap = t, this.calMinMax(), this.onColormapChange && this.onColormapChange(this);
  }
  // not included in public docs
  // base function for niivue.setColormap()
  // label colormaps are discretely sampled from an arbitrary number of colors
  setColormapLabel(t) {
    this.colormapLabel = rt.makeLabelLut(t);
  }
  async setColormapLabelFromUrl(t) {
    this.colormapLabel = await rt.makeLabelLutFromUrl(t);
  }
  get colormap() {
    return this._colormap;
  }
  get colorMap() {
    return this._colormap;
  }
  // TODO duplicate fields, see niivue/loadDocument
  set colormap(t) {
    this.setColormap(t);
  }
  set colorMap(t) {
    this.setColormap(t);
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(t) {
    this._opacity = t, this.onOpacityChange && this.onOpacityChange(this);
  }
  /**
   * set contrast/brightness to robust range (2%..98%)
   * @param vol - volume for estimate (use -1 to use estimate on all loaded volumes; use INFINITY for current volume)
   * @param isBorder - if true (default) only center of volume used for estimate
   * @returns volume brightness and returns array [pct2, pct98, mnScale, mxScale]
   * @see {@link https://niivue.com/demos/features/timeseries2.html | live demo usage}
   */
  calMinMax(t = Number.POSITIVE_INFINITY, i = !0) {
    if (!this.hdr)
      throw new Error("hdr undefined");
    if (!this.img)
      throw new Error("img undefined");
    let s = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, a = 0, n = 0, o = this.hdr.dims[1] * this.hdr.dims[2] * this.hdr.dims[3];
    const l = Math.floor(this.img.length / o);
    t >= l && (t = this.frame4D), t = Math.min(t, l - 1);
    const c = t * o;
    let h = [];
    if (i) {
      const B = [
        Math.floor(0.25 * this.hdr.dims[1]),
        Math.floor(0.25 * this.hdr.dims[2]),
        Math.floor(0.25 * this.hdr.dims[3])
      ], T = [
        this.hdr.dims[1] - 2 * B[0],
        this.hdr.dims[2] - 2 * B[1],
        this.hdr.dims[3] - 2 * B[2]
      ], U = [T[0] + B[0], T[1] + B[1], T[2] + B[2]];
      o = T[0] * T[1] * T[2], h = new this.img.constructor(o);
      let R = -1, N = 0;
      for (let k = 0; k < this.hdr.dims[3]; k++)
        for (let L = 0; L < this.hdr.dims[2]; L++)
          for (let q = 0; q < this.hdr.dims[1]; q++)
            R++, !(q < B[0] || L < B[1] || k < B[2]) && (q >= U[0] || L >= U[1] || k >= U[2] || (h[N] = this.img[R + c], N++));
    } else {
      h = new this.img.constructor(o);
      for (let M = 0; M < o; M++)
        h[M] = this.img[M + c];
    }
    const f = h.constructor !== Float64Array && h.constructor !== Float32Array && this.ignoreZeroVoxels;
    if (f)
      for (let M = 0; M < o; M++)
        s = Math.min(h[M], s), r = Math.max(h[M], r), h[M] === 0 && a++;
    else
      for (let M = 0; M < o; M++) {
        if (isNaN(h[M])) {
          n++;
          continue;
        }
        h[M] === 0 && (a++, this.ignoreZeroVoxels) || (s = Math.min(h[M], s), r = Math.max(h[M], r));
      }
    this.ignoreZeroVoxels && s === r && a > 0 && (s = 0);
    const d = this.intensityRaw2Scaled(s), u = this.intensityRaw2Scaled(r), m = rt.colormapFromKey(this._colormap);
    let g = 0, p = 0;
    if (m.min !== void 0 && (g = m.min), m.max !== void 0 && (p = m.max), g === p && this.trustCalMinMax && isFinite(this.hdr.cal_min) && isFinite(this.hdr.cal_max) && this.hdr.cal_max > this.hdr.cal_min)
      return this.cal_min = this.hdr.cal_min, this.cal_max = this.hdr.cal_max, this.robust_min = this.cal_min, this.robust_max = this.cal_max, this.global_min = d, this.global_max = u, [this.hdr.cal_min, this.hdr.cal_max, this.hdr.cal_min, this.hdr.cal_max];
    if (g !== p)
      return this.cal_min = g, this.cal_max = p, this.robust_min = this.cal_min, this.robust_max = this.cal_max, [g, p, g, p];
    const A = 100 * a / (o - 0);
    let x = !1;
    A > 60 && !this.ignoreZeroVoxels && (V.warn(`${Math.round(A)}% of voxels are zero: ignoring zeros for cal_max`), x = !0, this.ignoreZeroVoxels = !0), this.ignoreZeroVoxels || (a = 0), a += n;
    const w = Math.round((o - 0 - a) * this.percentileFrac);
    if (w < 1 || s === r)
      return i ? this.calMinMax(t, !1) : (V.debug("no variability in image intensity?"), this.cal_min = d, this.cal_max = u, this.robust_min = this.cal_min, this.robust_max = this.cal_max, this.global_min = d, this.global_max = u, [d, u, d, u]);
    const v = 1001, F = (v - 1) / (r - s), C = new Array(v);
    for (let M = 0; M < v; M++)
      C[M] = 0;
    if (f)
      for (let M = 0; M < o; M++)
        C[Math.round((h[M] - s) * F)]++;
    else if (this.ignoreZeroVoxels)
      for (let M = 0; M < o; M++)
        h[M] !== 0 && (isNaN(h[M]) || C[Math.round((h[M] - s) * F)]++);
    else
      for (let M = 0; M < o; M++)
        isNaN(h[M]) || C[Math.round((h[M] - s) * F)]++;
    let b = 0, y = 0;
    for (; b < w; )
      b += C[y], y++;
    y--, b = 0;
    let E = v;
    for (; b < w; )
      E--, b += C[E];
    if (y === E) {
      let M = -1;
      for (; M !== 0; )
        y > 0 && (y--, C[y] > 0 && (M = 0)), M !== 0 && E < v - 1 && (E++, C[E] > 0 && (M = 0)), y === 0 && E === v - 1 && (M = 0);
    }
    let S = this.intensityRaw2Scaled(y / F + s), D = this.intensityRaw2Scaled(E / F + s);
    return this.hdr.cal_min < this.hdr.cal_max && this.hdr.cal_min >= d && this.hdr.cal_max <= u && (S = this.hdr.cal_min, D = this.hdr.cal_max), x && (S = Math.min(S, 0)), this.cal_min = S, this.cal_max = D, this.hdr.intent_code === 1002 && (this.cal_min = d, this.cal_max = u), this.robust_min = this.cal_min, this.robust_max = this.cal_max, this.global_min = d, this.global_max = u, [S, D, d, u];
  }
  // calMinMax
  // not included in public docs
  // convert voxel intensity from stored value to scaled intensity
  intensityRaw2Scaled(t) {
    if (!this.hdr)
      throw new Error("hdr undefined");
    return this.hdr.scl_slope === 0 && (this.hdr.scl_slope = 1), t * this.hdr.scl_slope + this.hdr.scl_inter;
  }
  // convert voxel intensity from scaled intensity to stored value
  intensityScaled2Raw(t) {
    if (!this.hdr)
      throw new Error("hdr undefined");
    return this.hdr.scl_slope === 0 && (this.hdr.scl_slope = 1), (t - this.hdr.scl_inter) / this.hdr.scl_slope;
  }
  /**
   * Converts NVImage to NIfTI compliant byte array, potentially compressed.
   * Delegates to ImageWriter.saveToUint8Array.
   */
  async saveToUint8Array(t, i = null) {
    return on(this, t, i);
  }
  /**
   * save image as NIfTI volume and trigger download.
   * Delegates to ImageWriter.saveToDisk.
   */
  async saveToDisk(t = "", i = null) {
    return _l(this, t, i);
  }
  static async fetchDicomData(t, i = {}) {
    if (t === "")
      throw Error("url must not be empty");
    let r = /^(?:[a-z+]+:)?\/\//i.test(t) ? t : new URL(t, window.location.href);
    /(?:.([^.]+))?$/.exec(r.pathname) || (r = new URL("niivue-manifest.txt", t));
    let o = await fetch(r, { headers: i });
    if (!o.ok)
      throw Error(o.statusText);
    const c = (await o.text()).split(`
`), f = /(.*\/).*/.exec(r)[0], d = [];
    for (const u of c) {
      const m = new URL(u, f);
      if (o = await fetch(m, { headers: i }), !o.ok)
        throw Error(o.statusText);
      const g = await o.arrayBuffer();
      d.push({ name: u, data: g });
    }
    return d;
  }
  static async readFirstDecompressedBytes(t, i) {
    const s = t.getReader(), r = new va(), a = [];
    let n = 0, o = !1, l, c;
    const h = new Promise((d, u) => {
      l = d, c = u;
    });
    function f() {
      const d = new Uint8Array(n);
      let u = 0;
      for (const m of a)
        d.set(m, u), u += m.length;
      l(d);
    }
    return r.ondata = (d) => {
      a.push(d), n += d.length, n >= i && (o = !0, s.cancel().catch(() => {
      }), f());
    }, (async () => {
      try {
        for (; !o; ) {
          const { done: d, value: u } = await s.read();
          if (d) {
            o = !0, r.push(new Uint8Array(), !0);
            return;
          }
          r.push(u, !1);
        }
      } catch (d) {
        c(d);
      }
    })().catch(() => {
    }), h;
  }
  static extractFilenameFromUrl(t) {
    const s = new URL(t).searchParams.get("response-content-disposition");
    if (s) {
      const r = s.match(/filename\*?=(?:UTF-8'')?"?([^";]+)"?/);
      if (r)
        return decodeURIComponent(r[1]);
    }
    return t.split("/").pop().split("?")[0];
  }
  static async loadInitialVolumesGz(t = "", i = {}, s = NaN) {
    if (isNaN(s))
      return null;
    const r = await fetch(t, { headers: i, cache: "force-cache" });
    let a = 352, n = await this.readFirstDecompressedBytes(r.body, a);
    const o = new DataView(n.buffer, n.byteOffset, n.byteLength), l = o.getUint16(0, !0), c = l === 348;
    if (!c && !(l === 23553) || (n.length > 111 && (a = o.getFloat32(108, c)), a > n.length && (n = await this.readFirstDecompressedBytes(r.body, a)), !(n[0] === 92 && n[1] === 1 || n[1] === 92 && n[0] === 1)))
      return null;
    const d = await Ie(n.buffer);
    if (!d)
      throw new Error("Could not read NIfTI header");
    const u = d.numBitsPerVoxel / 8, m = [1, 2, 3].reduce((v, F) => v * (d.dims[F] > 1 ? d.dims[F] : 1), 1), g = [4, 5, 6].reduce((v, F) => v * (d.dims[F] > 1 ? d.dims[F] : 1), 1), p = Math.max(Math.min(s, g), 1), A = d.vox_offset + p * m * u;
    if (p === g)
      return null;
    const x = await fetch(t, { headers: i, cache: "force-cache" });
    return (await this.readFirstDecompressedBytes(x.body, A)).buffer.slice(0, A);
  }
  static async loadInitialVolumes(t = "", i = {}, s = NaN) {
    if (isNaN(s))
      return null;
    const a = (await fetch(t, { headers: i, cache: "force-cache" })).body.getReader(), { value: n, done: o } = await a.read();
    let l = n;
    if (o || !l || l.length < 2)
      throw new Error("Not enough data to determine compression");
    const c = new DataView(l.buffer, l.byteOffset, l.byteLength), h = c.getUint16(0, !0);
    if (h === 35615)
      return await a.cancel(), this.loadInitialVolumesGz(t, i, s);
    const d = h === 348;
    if (!d && !(h === 23553))
      return await a.cancel(), null;
    let m = 352;
    for (l.length > 111 && (m = c.getFloat32(108, d)); l.length < m; ) {
      let y = function(D, M) {
        const B = new Uint8Array(D.length + M.length);
        return B.set(D, 0), B.set(M, D.length), B;
      };
      const { value: E, done: S } = await a.read();
      if (S || !E)
        break;
      l = y(l, E);
    }
    const g = await Ie(l.buffer);
    if (!g)
      throw new Error("Could not read NIfTI header");
    const p = g.numBitsPerVoxel / 8, A = [1, 2, 3].reduce((y, E) => y * (g.dims[E] > 1 ? g.dims[E] : 1), 1), x = [4, 5, 6].reduce((y, E) => y * (g.dims[E] > 1 ? g.dims[E] : 1), 1), w = Math.max(Math.min(s, x), 1), v = g.vox_offset + w * A * p, F = new Uint8Array(v), C = Math.min(l.length, v);
    F.set(l.subarray(0, C), 0);
    let b = C;
    for (; b < v; ) {
      const { value: y, done: E } = await a.read();
      if (E || !y)
        return await a.cancel(), null;
      const S = Math.min(y.length, v - b);
      F.set(y.subarray(0, S), b), b += S;
    }
    return await a.cancel(), F.buffer;
  }
  /**
   * factory function to load and return a new NVImage instance from a given URL
   */
  static async loadFromUrl({
    url: t = "",
    urlImgData: i = "",
    headers: s = {},
    name: r = "",
    colormap: a = "",
    opacity: n = 1,
    cal_min: o = NaN,
    cal_max: l = NaN,
    trustCalMinMax: c = !0,
    percentileFrac: h = 0.02,
    ignoreZeroVoxels: f = !1,
    useQFormNotSForm: d = !1,
    colormapNegative: u = "",
    frame4D: m = 0,
    isManifest: g = !1,
    limitFrames4D: p = NaN,
    imageType: A = j.UNKNOWN,
    colorbarVisible: x = !0,
    buffer: w = new ArrayBuffer(0)
  } = {}) {
    if (t === "")
      throw Error("url must not be empty");
    let v = null, F = null, C = null;
    if (t instanceof Uint8Array && (t = t.slice().buffer), w.byteLength > 0 && (t = w), t instanceof ArrayBuffer)
      if (F = t, r !== "")
        t = r;
      else {
        const D = new Uint8Array(F);
        t = D[0] === 31 && D[1] === 139 ? "array.nii.gz" : "array.nii";
      }
    function b(D) {
      const M = D.match(/\.([^.]+)(?:\.gz|\.bz2|\.xz)?$/);
      return M ? M[1] : "";
    }
    let y = "";
    if (r === "" ? y = b(t) : y = b(r), A === j.UNKNOWN && (A = j.parse(y)), A === j.UNKNOWN && typeof t == "string") {
      const D = await fetch(t, {});
      if (D.redirected) {
        const M = this.extractFilenameFromUrl(D.url);
        M && M.length > 0 && r === "" && (r = M, y = b(r), A = j.parse(y));
      }
    }
    if (A === j.ZARR) {
      const D = new URL(t).searchParams, M = D.get("z"), B = D.get("y"), T = D.get("x"), U = M ? Pe(parseInt(M), parseInt(M) + 1) : null, R = B ? Pe(parseInt(B), parseInt(B) + 1) : null, N = T ? Pe(parseInt(T), parseInt(T) + 1) : null, k = t.split("?")[0], L = new Ua(k), q = Za(L);
      let _;
      try {
        _ = await Jt(q.resolve(t), { kind: "array" });
      } catch {
        _ = await Jt(q, { kind: "array" });
      }
      let z;
      if (_.shape.length === 4) {
        const ut = _.shape[2], bt = _.shape[1], xt = _.shape[0];
        U && U[0] >= ut && (U[0] = ut - 1), R && R[0] >= bt && (R[0] = bt - 1), N && N[0] >= xt && (N[0] = xt - 1), z = await ir(_, [N, R, U, null]);
      } else
        z = await ir(_, [N, R, U]);
      F = z.data;
      const [K, W, $, tt] = z.shape;
      C = {
        data: F,
        width: W,
        height: K,
        depth: $,
        channels: tt
      };
    }
    const E = A === j.DCM || j.NII;
    if (!F && E && (F = await this.loadInitialVolumes(t, s, p)), !F)
      if (g)
        F = await bi.fetchDicomData(t, s), A = j.DCM_MANIFEST;
      else {
        const D = await fetch(t, { headers: s });
        if (!D.ok)
          throw Error(D.statusText);
        if (!D.body)
          throw new Error("No readable stream available");
        const M = await Oi(D.body), B = [], T = M.getReader();
        for (; ; ) {
          const { done: k, value: L } = await T.read();
          if (k)
            break;
          B.push(L);
        }
        const U = B.reduce((k, L) => k + L.length, 0);
        F = new ArrayBuffer(U);
        const R = new Uint8Array(F);
        let N = 0;
        for (const k of B)
          R.set(k, N), N += k.length;
      }
    y.toUpperCase() === "HEAD" && i === "" && (i = t.substring(0, t.lastIndexOf("HEAD")) + "BRIK"), y.toUpperCase() === "HDR" && i === "" && (i = t.substring(0, t.lastIndexOf("HDR")) + "IMG");
    let S = null;
    if (i)
      try {
        let D = await fetch(i, { headers: s });
        if (D.status === 404 && (i.includes("BRIK") || i.includes("IMG")) && (D = await fetch(`${i}.gz`, { headers: s })), D.ok && D.body) {
          const M = await Oi(D.body), B = [], T = M.getReader();
          for (; ; ) {
            const { done: k, value: L } = await T.read();
            if (k)
              break;
            B.push(L);
          }
          const U = B.reduce((k, L) => k + L.length, 0);
          S = new ArrayBuffer(U);
          const R = new Uint8Array(S);
          let N = 0;
          for (const k of B)
            R.set(k, N), N += k.length;
        }
      } catch (D) {
        console.error("Error loading paired image data:", D);
      }
    if (!F)
      throw new Error("Unable to load buffer properly from volume");
    if (!r) {
      let D;
      try {
        D = new URL(t).pathname.split("/");
      } catch {
        D = t.split("/");
      }
      r = D.slice(-1)[0], r.indexOf("?") > -1 && (r = r.slice(0, r.indexOf("?")));
    }
    return v = await this.new(
      F,
      r,
      a,
      n,
      S,
      o,
      l,
      c,
      h,
      f,
      d,
      u,
      m,
      A,
      NaN,
      NaN,
      !0,
      null,
      0,
      C
    ), v.url = t, v.colorbarVisible = x, v;
  }
  // not included in public docs
  // loading Nifti files
  static async readFileAsync(t, i = NaN) {
    let s = t.stream();
    if (!isNaN(i)) {
      let f = 0;
      const d = new TransformStream({
        transform(u, m) {
          if (f >= i) {
            m.terminate();
            return;
          }
          const g = i - f;
          u.length > g ? (m.enqueue(u.slice(0, g)), m.terminate()) : m.enqueue(u), f += u.length;
        }
      });
      s = s.pipeThrough(d);
    }
    const r = await Oi(s), a = [], n = r.getReader();
    for (; ; ) {
      const { done: f, value: d } = await n.read();
      if (f)
        break;
      a.push(d);
    }
    const o = a.reduce((f, d) => f + d.length, 0), l = new ArrayBuffer(o), c = new Uint8Array(l);
    let h = 0;
    for (const f of a)
      c.set(f, h), h += f.length;
    return l;
  }
  /**
   * factory function to load and return a new NVImage instance from a file in the browser
   */
  static async loadFromFile({
    file: t,
    // file can be an array of file objects or a single file object
    name: i = "",
    colormap: s = "",
    opacity: r = 1,
    urlImgData: a = null,
    cal_min: n = NaN,
    cal_max: o = NaN,
    trustCalMinMax: l = !0,
    percentileFrac: c = 0.02,
    ignoreZeroVoxels: h = !1,
    useQFormNotSForm: f = !1,
    colormapNegative: d = "",
    frame4D: u = 0,
    limitFrames4D: m = NaN,
    imageType: g = j.UNKNOWN
  }) {
    let p = null, A = [];
    try {
      if (Array.isArray(t))
        A = await Promise.all(t.map((w) => this.readFileAsync(w)));
      else {
        if (isNaN(m))
          A = await this.readFileAsync(t);
        else {
          const w = await this.readFileAsync(t, 512), v = new Uint8Array(w);
          if (!(v[0] === 92 && v[1] === 1 || v[1] === 92 && v[0] === 1))
            A = await this.readFileAsync(t);
          else {
            const C = await Ie(w);
            if (!C)
              throw new Error("could not read nifti header");
            const b = C.numBitsPerVoxel / 8, y = [1, 2, 3].reduce((M, B) => M * (C.dims[B] > 1 ? C.dims[B] : 1), 1), E = [4, 5, 6].reduce((M, B) => M * (C.dims[B] > 1 ? C.dims[B] : 1), 1), S = Math.max(Math.min(m, E), 1), D = C.vox_offset + S * y * b;
            A = await this.readFileAsync(t, D);
          }
        }
        i = t.name;
      }
      let x = null;
      a && (x = await this.readFileAsync(a)), p = await this.new(
        A,
        i,
        s,
        r,
        x,
        n,
        o,
        l,
        c,
        h,
        f,
        d,
        u,
        g,
        NaN,
        NaN,
        !0,
        null,
        0,
        null
      ), p.fileObject = t;
    } catch (x) {
      throw V.error(x), new Error("could not build NVImage");
    }
    if (p === null)
      throw new Error("could not build NVImage");
    return p;
  }
  /**
   * Creates a Uint8Array representing a NIFTI file (header + optional image data).
   * Delegates to ImageWriter.createNiftiArray.
   */
  static createNiftiArray(t = [256, 256, 256], i = [1, 1, 1], s = [1, 0, 0, -128, 0, 1, 0, -128, 0, 0, 1, -128, 0, 0, 0, 1], r = 2, a = new Uint8Array()) {
    return Hl(t, i, s, r, a);
  }
  /**
   * Creates a NIFTI1 header object with basic properties.
   * Delegates to ImageWriter.createNiftiHeader.
   */
  static createNiftiHeader(t = [256, 256, 256], i = [1, 1, 1], s = [1, 0, 0, -128, 0, 1, 0, -128, 0, 0, 1, -128, 0, 0, 0, 1], r = 2) {
    return nn(t, i, s, r);
  }
  /**
   * read a 3D slab of voxels from a volume
   * @see {@link https://niivue.com/demos/features/slab_selection.html | live demo usage}
   */
  /**
   * read a 3D slab of voxels from a volume, specified in RAS coordinates.
   * Delegates to VolumeUtils.getVolumeData.
   */
  getVolumeData(t = [-1, 0, 0], i = [0, 0, 0], s = "same") {
    return jl(this, t, i, s);
  }
  /**
   * write a 3D slab of voxels from a volume
   * @see {@link https://niivue.com/demos/features/slab_selection.html | live demo usage}
   */
  /**
   * write a 3D slab of voxels from a volume, specified in RAS coordinates.
   * Delegates to VolumeUtils.setVolumeData.
   * Input slabData is assumed to be in the correct raw data type for the target image.
   */
  setVolumeData(t = [-1, 0, 0], i = [0, 0, 0], s = new Uint8Array()) {
    Zl(this, t, i, s);
  }
  /**
   * factory function to load and return a new NVImage instance from a base64 encoded string
   * @example
   * myImage = NVImage.loadFromBase64('SomeBase64String')
   */
  static async loadFromBase64({
    base64: t,
    name: i = "",
    colormap: s = "",
    opacity: r = 1,
    cal_min: a = NaN,
    cal_max: n = NaN,
    trustCalMinMax: o = !0,
    percentileFrac: l = 0.02,
    ignoreZeroVoxels: c = !1,
    useQFormNotSForm: h = !1,
    colormapNegative: f = "",
    frame4D: d = 0,
    imageType: u = j.UNKNOWN,
    cal_minNeg: m = NaN,
    cal_maxNeg: g = NaN,
    colorbarVisible: p = !0,
    colormapLabel: A = null
  }) {
    function x(v) {
      const F = window.atob(v), C = F.length, b = new Uint8Array(C);
      for (let y = 0; y < C; y++)
        b[y] = F.charCodeAt(y);
      return b.buffer;
    }
    let w = null;
    try {
      const v = x(t);
      w = await this.new(
        v,
        i,
        s,
        r,
        null,
        a,
        n,
        o,
        l,
        c,
        h,
        f,
        d,
        u,
        m,
        g,
        p,
        A,
        0,
        null
      );
    } catch (v) {
      V.debug(v);
    }
    if (w === null)
      throw new Error("could not load NVImage");
    return w;
  }
  /**
   * make a clone of a NVImage instance and return a new NVImage
   * @example
   * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
   * clonedImage = myImage.clone()
   */
  clone() {
    const t = new bi();
    return t.id = $i(), t.hdr = Object.assign({}, this.hdr), t.img = this.img.slice(), t.calculateRAS(), t.calMinMax(), t;
  }
  /**
   * fill a NVImage instance with zeros for the image data
   * @example
   * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
   * clonedImageWithZeros = myImage.clone().zeroImage()
   */
  zeroImage() {
    this.img.fill(0);
  }
  /**
   * get nifti specific metadata about the image
   */
  getImageMetadata() {
    if (!this.hdr)
      throw new Error("hdr undefined");
    const t = this.id, i = this.hdr.datatypeCode, s = this.hdr.dims, r = s[1], a = s[2], n = s[3], o = Math.max(1, s[4]), l = this.hdr.pixDims, c = l[1], h = l[2], f = l[3], d = l[4], u = Math.floor(this.hdr.numBitsPerVoxel / 8);
    return { id: t, datatypeCode: i, nx: r, ny: a, nz: n, nt: o, dx: c, dy: h, dz: f, dt: d, bpv: u };
  }
  /**
   * a factory function to make a zero filled image given a NVImage as a reference
   * @example
   * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
   * newZeroImage = NVImage.zerosLike(myImage)
   */
  static zerosLike(t, i = "same") {
    const s = t.clone();
    return s.zeroImage(), i === "uint8" && (s.img = Uint8Array.from(s.img), s.hdr.datatypeCode = 2, s.hdr.numBitsPerVoxel = 8), i === "float32" && (s.img = Float32Array.from(s.img), s.hdr.datatypeCode = 16, s.hdr.numBitsPerVoxel = 32), s;
  }
  /**
   * Returns voxel intensity at specific native coordinates.
   * Delegates to VolumeUtils.getValue.
   */
  getValue(t, i, s, r = 0, a = !1) {
    return Ql(this, t, i, s, r, a);
  }
  /**
   * Returns voxel intensities at specific native coordinates.
   * Delegates to VolumeUtils.getValue.
   */
  getValues(t, i, s, r = 0, a = !1) {
    return ln(this, t, i, s, r, a);
  }
  /**
   * Update options for image
   */
  applyOptionsUpdate(t) {
    this.hdr.cal_min = t.cal_min, this.hdr.cal_max = t.cal_max, Object.assign(this, t);
  }
  getImageOptions() {
    return wi(
      "",
      // url,
      "",
      // urlImageData
      this.name,
      // name
      this._colormap,
      // colormap
      this.opacity,
      // opacity
      this.hdr.cal_min,
      // cal_min
      this.hdr.cal_max,
      // cal_max
      this.trustCalMinMax,
      // trustCalMinMax,
      this.percentileFrac,
      // percentileFrac
      this.ignoreZeroVoxels,
      // ignoreZeroVoxels
      this.useQFormNotSForm,
      // useQFormNotSForm
      this.colormapNegative,
      // colormapNegative
      this.frame4D,
      this.imageType,
      // imageType
      this.colormapType
    );
  }
  /**
   * Converts NVImage to NIfTI compliant byte array.
   * Handles potential re-orientation of drawing data.
   * Delegates to ImageWriter.toUint8Array.
   */
  toUint8Array(t = null) {
    return an(this, t);
  }
  // not included in public docs
  convertVox2Frac(t) {
    return O(
      (t[0] + 0.5) / this.dimsRAS[1],
      (t[1] + 0.5) / this.dimsRAS[2],
      (t[2] + 0.5) / this.dimsRAS[3]
    );
  }
  // not included in public docs
  convertFrac2Vox(t) {
    return O(
      Math.round(t[0] * this.dims[1] - 0.5),
      // dims === RAS
      Math.round(t[1] * this.dims[2] - 0.5),
      // dims === RAS
      Math.round(t[2] * this.dims[3] - 0.5)
      // dims === RAS
    );
  }
  // not included in public docs
  convertFrac2MM(t, i = !1) {
    const s = ht(t[0], t[1], t[2], 1);
    return i ? Ct(s, s, this.frac2mm) : Ct(s, s, this.frac2mmOrtho), s;
  }
  // not included in public docs
  convertMM2Frac(t, i = !1) {
    const s = ht(t[0], t[1], t[2], 1), r = this.dimsRAS, a = O(0, 0, 0);
    if (typeof r > "u")
      return a;
    if (!i) {
      const o = mt(this.frac2mmOrtho);
      return Vt(o, o), Ct(s, s, o), a[0] = s[0], a[1] = s[1], a[2] = s[2], a;
    }
    if (r[1] < 1 || r[2] < 1 || r[3] < 1)
      return a;
    const n = mt(this.matRAS);
    return Vt(n, n), Ut(n, n), Ct(s, s, n), a[0] = (s[0] + 0.5) / r[1], a[1] = (s[1] + 0.5) / r[2], a[2] = (s[2] + 0.5) / r[3], a;
  }
}, mn = /* @__PURE__ */ ((e) => (e[e.none = 0] = "none", e[e.contrast = 1] = "contrast", e[e.measurement = 2] = "measurement", e[e.pan = 3] = "pan", e[e.slicer3D = 4] = "slicer3D", e[e.callbackOnly = 5] = "callbackOnly", e[e.roiSelection = 6] = "roiSelection", e[e.angle = 7] = "angle", e[e.crosshair = 8] = "crosshair", e[e.windowing = 9] = "windowing", e))(mn || {}), kt = {
  textHeight: -1,
  fontSizeScaling: 0.4,
  fontMinPx: 13,
  colorbarHeight: 0.05,
  colorbarWidth: -1,
  // automatic (full width)
  showColorbarBorder: !0,
  // show border around the colorbar
  crosshairWidth: 1,
  crosshairWidthUnit: "voxels",
  crosshairGap: 0,
  rulerWidth: 4,
  show3Dcrosshair: !1,
  backColor: [0, 0, 0, 1],
  crosshairColor: [1, 0, 0, 1],
  fontColor: [0.5, 0.5, 0.5, 1],
  selectionBoxColor: [1, 1, 1, 0.5],
  clipPlaneColor: [0.7, 0, 0.7, 0.5],
  isClipPlanesCutaway: !1,
  paqdUniforms: [0.3, 0.5, 0.5, 1],
  // paqdUniforms: [0.3, 0.9, 1.0, 0.5],
  rulerColor: [1, 0, 0, 0.8],
  colorbarMargin: 0.05,
  trustCalMinMax: !0,
  clipPlaneHotKey: "KeyC",
  cycleClipPlaneHotKey: "KeyP",
  viewModeHotKey: "KeyV",
  doubleTouchTimeout: 500,
  longTouchTimeout: 1e3,
  keyDebounceTime: 50,
  isNearestInterpolation: !1,
  isResizeCanvas: !0,
  atlasOutline: 0,
  atlasActiveIndex: 0,
  isRuler: !1,
  isColorbar: !1,
  isOrientCube: !1,
  tileMargin: 0,
  multiplanarPadPixels: 0,
  // @deprecated
  multiplanarForceRender: !1,
  multiplanarEqualSize: !1,
  multiplanarShowRender: 2,
  // auto is the same behaviour as multiplanarForceRender: false
  isRadiologicalConvention: !1,
  meshThicknessOn2D: 1 / 0,
  dragMode: 1,
  dragModePrimary: 8,
  mouseEventConfig: void 0,
  touchEventConfig: void 0,
  yoke3Dto2DZoom: !1,
  isDepthPickMesh: !1,
  isCornerOrientationText: !1,
  isOrientationTextVisible: !0,
  showAllOrientationMarkers: !1,
  heroImageFraction: 0,
  heroSliceType: 4,
  sagittalNoseLeft: !1,
  isSliceMM: !1,
  isV1SliceShader: !1,
  forceDevicePixelRatio: 0,
  logLevel: "info",
  loadingText: "loading ...",
  isForceMouseClickToVoxelCenters: !1,
  dragAndDropEnabled: !0,
  drawingEnabled: !1,
  penValue: 1,
  penType: 0,
  floodFillNeighbors: 6,
  isFilledPen: !1,
  thumbnail: "",
  maxDrawUndoBitmaps: 8,
  sliceType: 3,
  meshXRay: 0,
  isAntiAlias: null,
  limitFrames4D: NaN,
  isAdditiveBlend: !1,
  showLegend: !0,
  legendBackgroundColor: [0.3, 0.3, 0.3, 0.5],
  legendTextColor: [1, 1, 1, 1],
  multiplanarLayout: 0,
  renderOverlayBlend: 1,
  sliceMosaicString: "",
  centerMosaic: !1,
  penSize: 1,
  // in voxels, since all drawing is done using bitmap indices
  interactive: !0,
  clickToSegment: !1,
  clickToSegmentRadius: 3,
  // in mm
  clickToSegmentBright: !0,
  clickToSegmentAutoIntensity: !1,
  // new option, but keep clickToSegmentBright for backwards compatibility
  clickToSegmentIntensityMax: NaN,
  // NaN will use auto threshold (default flood fill behavior from before)
  clickToSegmentIntensityMin: NaN,
  // NaN will use auto threshold (default flood fill behavior from before)
  // 0 will use auto threshold (default flood fill behavior from before)
  // Take the voxel intensity at the click point and use this percentage +/- to threshold the flood fill operation.
  // If greater than 0, clickedVoxelIntensity +/- clickedVoxelIntensity * clickToSegmentPercent will be used
  // for the clickToSegmentIntensityMin and clickToSegmentIntensityMax values.
  clickToSegmentPercent: 0,
  clickToSegmentMaxDistanceMM: Number.POSITIVE_INFINITY,
  // default value is infinity for backwards compatibility with flood fill routine.
  clickToSegmentIs2D: !1,
  selectionBoxLineThickness: 4,
  selectionBoxIsOutline: !1,
  scrollRequiresFocus: !1,
  // determines if the cavas need to be focused to scroll
  showMeasureUnits: !0,
  // e.g. 20.2 vs 20.2 mm
  measureTextJustify: "center",
  // start, center, end
  measureTextColor: [1, 0, 0, 1],
  // red
  measureLineColor: [1, 0, 0, 1],
  // red
  measureTextHeight: 0.06,
  isAlphaClipDark: !1,
  gradientOrder: 1,
  gradientOpacity: 0,
  renderSilhouette: 0,
  gradientAmount: 0,
  invertScrollDirection: !1,
  is2DSliceShader: !1,
  bounds: null,
  showBoundsBorder: !1,
  boundsBorderColor: [1, 1, 1, 1]
  // white border by default
}, Be = {
  gamma: 1,
  azimuth: 110,
  elevation: 10,
  crosshairPos: O(0.5, 0.5, 0.5),
  clipPlanes: [[0, 0, 0, 0]],
  // start with no planes
  clipPlaneDepthAziElevs: [[2, 0, 0]],
  // empty by default
  volScaleMultiplier: 1,
  pan2Dxyzmm: ht(0, 0, 0, 1)
};
function ec(e, t) {
  const i = {};
  for (const s in e) {
    const r = e[s], a = t[s], n = Array.isArray(r) && Array.isArray(a);
    (n && r.some((o, l) => o !== a[l]) || !n && r !== a) && (i[s] = r);
  }
  return i;
}
var zi = class Ht {
  constructor() {
    I(this, "data", {
      title: "Untitled document",
      imageOptionsArray: [],
      meshOptionsArray: [],
      opts: { ...kt },
      previewImageDataURL: "",
      labels: [],
      encodedImageBlobs: [],
      encodedDrawingBlob: ""
    }), I(this, "scene"), I(this, "volumes", []), I(this, "meshDataObjects"), I(this, "meshes", []), I(this, "drawBitmap", null), I(this, "imageOptionsMap", /* @__PURE__ */ new Map()), I(this, "meshOptionsMap", /* @__PURE__ */ new Map()), I(this, "completedMeasurements", []), I(this, "completedAngles", []), I(this, "_optsProxy", null), I(this, "_optsChangeCallback", null), this.scene = {
      onAzimuthElevationChange: () => {
      },
      onZoom3DChange: () => {
      },
      sceneData: {
        ...Be,
        pan2Dxyzmm: ht(0, 0, 0, 1),
        crosshairPos: O(0.5, 0.5, 0.5)
      },
      get renderAzimuth() {
        return this.sceneData.azimuth;
      },
      set renderAzimuth(t) {
        this.sceneData.azimuth = t, this.onAzimuthElevationChange && this.onAzimuthElevationChange(this.sceneData.azimuth, this.sceneData.elevation);
      },
      get renderElevation() {
        return this.sceneData.elevation;
      },
      set renderElevation(t) {
        this.sceneData.elevation = t, this.onAzimuthElevationChange && this.onAzimuthElevationChange(this.sceneData.azimuth, this.sceneData.elevation);
      },
      get volScaleMultiplier() {
        return this.sceneData.volScaleMultiplier;
      },
      set volScaleMultiplier(t) {
        this.sceneData.volScaleMultiplier = t, this.onZoom3DChange(t);
      },
      get crosshairPos() {
        return this.sceneData.crosshairPos;
      },
      set crosshairPos(t) {
        this.sceneData.crosshairPos = t;
      },
      get clipPlane() {
        return this.sceneData.clipPlanes[0] ?? [];
      },
      set clipPlane(t) {
        this.sceneData.clipPlanes[0] = t;
      },
      // get clipPlaneDepthAziElev(): number[] {
      //   return this.sceneData.clipPlaneDepthAziElevs[0] ?? []
      // },
      // set clipPlaneDepthAziElev(clipPlaneDepthAziElev: number[]) {
      //   this.sceneData.clipPlaneDepthAziElevs[0] = clipPlaneDepthAziElev
      // },
      get clipPlanes() {
        return this.sceneData.clipPlanes;
      },
      set clipPlanes(t) {
        this.sceneData.clipPlanes = t;
      },
      get clipPlaneDepthAziElevs() {
        return this.sceneData.clipPlaneDepthAziElevs;
      },
      set clipPlaneDepthAziElevs(t) {
        this.sceneData.clipPlaneDepthAziElevs = t;
      },
      get pan2Dxyzmm() {
        return this.sceneData.pan2Dxyzmm;
      },
      /**
       * Sets current 2D pan in 3D mm
       */
      set pan2Dxyzmm(t) {
        this.sceneData.pan2Dxyzmm = t;
      },
      get gamma() {
        return this.sceneData.gamma;
      },
      /**
       * Sets current gamma
       */
      set gamma(t) {
        this.sceneData.gamma = t;
      }
    };
  }
  /**
   * Title of the document
   */
  get title() {
    return this.data.title;
  }
  /**
   * Gets preview image blob
   * @returns dataURL of preview image
   */
  get previewImageDataURL() {
    return this.data.previewImageDataURL;
  }
  /**
   * Sets preview image blob
   * @param dataURL - encoded preview image
   */
  set previewImageDataURL(t) {
    this.data.previewImageDataURL = t;
  }
  /**
   * @param title - title of document
   */
  set title(t) {
    this.data.title = t;
  }
  get imageOptionsArray() {
    return this.data.imageOptionsArray;
  }
  /**
   * Gets the base 64 encoded blobs of associated images
   */
  get encodedImageBlobs() {
    return this.data.encodedImageBlobs;
  }
  /**
   * Gets the base 64 encoded blob of the associated drawing
   * TODO the return type was marked as string[] here, was that an error?
   */
  get encodedDrawingBlob() {
    return this.data.encodedDrawingBlob;
  }
  /**
   * Gets the options of the {@link Niivue} instance
   */
  get opts() {
    return this._optsProxy || this._createOptsProxy(), this._optsProxy;
  }
  /**
   * Sets the options of the {@link Niivue} instance
   */
  set opts(t) {
    this.data.opts = { ...t }, this._optsProxy = null;
  }
  /**
   * Gets the 3D labels of the {@link Niivue} instance
   */
  get labels() {
    return this.data.labels;
  }
  /**
   * Sets the 3D labels of the {@link Niivue} instance
   */
  set labels(t) {
    this.data.labels = t;
  }
  get customData() {
    return this.data.customData;
  }
  set customData(t) {
    this.data.customData = t;
  }
  /**
   * Checks if document has an image by id
   */
  hasImage(t) {
    return this.volumes.find((i) => i.id === t.id) !== void 0;
  }
  /**
   * Checks if document has an image by url
   */
  hasImageFromUrl(t) {
    return this.data.imageOptionsArray.find((i) => i.url === t) !== void 0;
  }
  /**
   * Adds an image and the options an image was created with
   */
  addImageOptions(t, i) {
    if (!this.hasImage(t) && !i.name)
      if (i.url) {
        const r = /^(?:[a-z+]+:)?\/\//i.test(i.url) ? new URL(i.url) : new URL(i.url, window.location.href);
        i.name = r.pathname.split("/").pop(), i.name.toLowerCase().endsWith(".gz") && (i.name = i.name.slice(0, -3)), i.name.toLowerCase().endsWith(".nii") || (i.name += ".nii");
      } else
        i.name = "untitled.nii";
    i.imageType = j.NII, this.data.imageOptionsArray.push(i), this.imageOptionsMap.set(t.id, this.data.imageOptionsArray.length - 1);
  }
  /**
   * Removes image from the document as well as its options
   */
  removeImage(t) {
    if (this.imageOptionsMap.has(t.id)) {
      const i = this.imageOptionsMap.get(t.id);
      this.data.imageOptionsArray.length > i && this.data.imageOptionsArray.splice(i, 1), this.imageOptionsMap.delete(t.id);
    }
    this.volumes = this.volumes.filter((i) => i.id !== t.id);
  }
  /**
   * Fetch any image data that is missing from this document.
   * This includes loading image blobs for `ImageFromUrlOptions` with valid `url` fields.
   * After calling this, `volumes` and `imageOptionsMap` will be populated.
   */
  async fetchLinkedData() {
    var t;
    if (this.data.encodedImageBlobs = [], !!((t = this.imageOptionsArray) != null && t.length)) {
      for (const i of this.imageOptionsArray)
        if (i.url)
          try {
            const s = await fetch(i.url);
            if (!s.ok) {
              console.warn("Failed to fetch image:", i.url);
              continue;
            }
            const r = await s.arrayBuffer(), a = new Uint8Array(r), n = H.uint8tob64(a);
            this.data.encodedImageBlobs.push(n), console.info("fetch linked data fetched from ", i.url);
          } catch (s) {
            console.warn(`Failed to fetch/encode image from ${i.url}:`, s);
          }
    }
  }
  /**
   * Returns the options for the image if it was added by url
   */
  getImageOptions(t) {
    return this.imageOptionsMap.has(t.id) ? this.data.imageOptionsArray[this.imageOptionsMap.get(t.id)] : null;
  }
  /**
   * Serialise the document.
   *
   * @param embedImages  If false, encodedImageBlobs is left empty
   *                     (imageOptionsArray still records the URL / name).
   * @param embedDrawing  If false, encodedDrawingBlob is left empty
   */
  json(t = !0, i = !0) {
    const s = {
      encodedImageBlobs: [],
      previewImageDataURL: this.data.previewImageDataURL,
      imageOptionsMap: /* @__PURE__ */ new Map()
    }, r = [];
    s.sceneData = { ...this.scene.sceneData }, delete s.sceneData.clipPlane, delete s.sceneData.clipPlaneDepthAziElev, delete s.sceneData.clipThick, delete s.sceneData.clipVolumeLow, delete s.sceneData.clipVolumeHigh, s.opts = ec(this.opts, kt), this.opts.meshThicknessOn2D === 1 / 0 && (s.opts.meshThicknessOn2D = "infinity"), this.opts.meshThicknessOn2D === 1 / 0 && (s.opts.meshThicknessOn2D = "infinity"), s.labels = [...this.data.labels];
    for (const n of s.labels)
      delete n.onClick;
    if (s.customData = this.customData, s.completedMeasurements = [...this.completedMeasurements], s.completedAngles = [...this.completedAngles], this.volumes.length)
      for (let n = 0; n < this.volumes.length; n++) {
        const o = this.volumes[n];
        let l = this.getImageOptions(o);
        if (l === null ? (V.warn("no options found for image, using options from the volume directly"), l = {
          name: (o == null ? void 0 : o.name) ?? "",
          colormap: (o == null ? void 0 : o._colormap) ?? "gray",
          opacity: (o == null ? void 0 : o._opacity) ?? 1,
          pairedImgData: null,
          cal_min: (o == null ? void 0 : o.cal_min) ?? NaN,
          cal_max: (o == null ? void 0 : o.cal_max) ?? NaN,
          trustCalMinMax: (o == null ? void 0 : o.trustCalMinMax) ?? !0,
          percentileFrac: (o == null ? void 0 : o.percentileFrac) ?? 0.02,
          ignoreZeroVoxels: (o == null ? void 0 : o.ignoreZeroVoxels) ?? !1,
          useQFormNotSForm: (o == null ? void 0 : o.useQFormNotSForm) ?? !1,
          colormapNegative: (o == null ? void 0 : o.colormapNegative) ?? "",
          colormapLabel: (o == null ? void 0 : o.colormapLabel) ?? null,
          imageType: (o == null ? void 0 : o.imageType) ?? j.NII,
          frame4D: (o == null ? void 0 : o.frame4D) ?? 0,
          limitFrames4D: (o == null ? void 0 : o.limitFrames4D) ?? NaN,
          url: (o == null ? void 0 : o.url) ?? "",
          urlImageData: (o == null ? void 0 : o.urlImgData) ?? "",
          alphaThreshold: !1,
          cal_minNeg: (o == null ? void 0 : o.cal_minNeg) ?? NaN,
          cal_maxNeg: (o == null ? void 0 : o.cal_maxNeg) ?? NaN,
          colorbarVisible: (o == null ? void 0 : o.colorbarVisible) ?? !0
        }) : "imageType" in l || (l.imageType = j.NII), l.colormap = o.colormap, l.colormapLabel = o.colormapLabel, l.opacity = o.opacity, l.cal_max = o.cal_max ?? NaN, l.cal_min = o.cal_min ?? NaN, r.push(l), t) {
          const c = H.uint8tob64(o.toUint8Array());
          s.encodedImageBlobs.push(c);
        }
        s.imageOptionsMap.set(o.id, n);
      }
    s.imageOptionsArray = [...r];
    const a = [];
    s.connectomes = [];
    for (const n of this.meshes) {
      if (n.type === "connectome") {
        s.connectomes.push(JSON.stringify(n.json()));
        continue;
      }
      const o = {
        pts: n.pts,
        tris: n.tris,
        name: n.name,
        rgba255: Uint8Array.from(n.rgba255),
        opacity: n.opacity,
        connectome: n.connectome,
        dpg: n.dpg,
        dps: n.dps,
        dpv: n.dpv,
        meshShaderIndex: n.meshShaderIndex,
        layers: n.layers.map((l) => ({
          values: l.values,
          nFrame4D: l.nFrame4D,
          frame4D: 0,
          outlineBorder: l.outlineBorder,
          global_min: l.global_min,
          global_max: l.global_max,
          cal_min: l.cal_min,
          cal_max: l.cal_max,
          opacity: l.opacity,
          colormap: l.colormap,
          colormapNegative: l.colormapNegative,
          colormapLabel: l.colormapLabel,
          useNegativeCmap: l.useNegativeCmap
        })),
        hasConnectome: n.hasConnectome,
        edgeColormap: n.edgeColormap,
        edgeColormapNegative: n.edgeColormapNegative,
        edgeMax: n.edgeMax,
        edgeMin: n.edgeMin,
        edges: n.edges && Array.isArray(n.edges) ? [...n.edges] : [],
        extentsMax: n.extentsMax,
        extentsMin: n.extentsMin,
        furthestVertexFromOrigin: n.furthestVertexFromOrigin,
        nodeColormap: n.nodeColormap,
        nodeColormapNegative: n.nodeColormapNegative,
        nodeMaxColor: n.nodeMaxColor,
        nodeMinColor: n.nodeMinColor,
        nodeScale: n.nodeScale,
        legendLineThickness: n.legendLineThickness,
        offsetPt0: n.offsetPt0,
        nodes: n.nodes
      };
      n.offsetPt0 && n.offsetPt0.length > 0 && (o.offsetPt0 = n.offsetPt0, o.fiberGroupColormap = n.fiberGroupColormap, o.fiberColor = n.fiberColor, o.fiberDither = n.fiberDither, o.fiberRadius = n.fiberRadius, o.colormap = n.colormap), a.push(o);
    }
    return s.meshesString = JSON.stringify(aa(a)), i && this.drawBitmap && (s.encodedDrawingBlob = H.uint8tob64(this.drawBitmap)), s;
  }
  async download(t, i, s = { embedImages: !0 }) {
    const r = this.json(s.embedImages), a = JSON.stringify(r), n = i ? "application/gzip" : "application/json", o = i ? await H.compressStringToArrayBuffer(a) : a;
    H.download(o, t, n);
  }
  /**
   * Deserialize mesh data objects
   */
  static deserializeMeshDataObjects(t) {
    if (!t.data.meshesString || t.data.meshesString === "[]") {
      t.meshDataObjects = [];
      return;
    }
    if (t.data.meshesString) {
      t.meshDataObjects = ia(JSON.parse(t.data.meshesString));
      for (const i of t.meshDataObjects)
        for (const s of i.layers)
          "colorMap" in s && (s.colormap = s.colorMap, delete s.colorMap), "colorMapNegative" in s && (s.colormapNegative = s.colorMapNegative, delete s.colorMapNegative);
    }
  }
  /**
   * Factory method to return an instance of NVDocument from a URL
   */
  static async loadFromUrl(t) {
    const s = await (await fetch(t)).arrayBuffer();
    let r;
    if (H.isArrayBufferCompressed(s)) {
      const a = await H.decompressArrayBuffer(s);
      r = JSON.parse(a);
    } else {
      const a = new TextDecoder();
      r = JSON.parse(a.decode(s));
    }
    return Ht.loadFromJSON(r);
  }
  /**
   * Factory method to return an instance of NVDocument from a File object
   */
  static async loadFromFile(t) {
    const i = await H.readFileAsync(t);
    let s;
    const r = new Ht();
    return H.isArrayBufferCompressed(i) ? s = await H.decompressArrayBuffer(i) : s = new TextDecoder().decode(i), r.data = JSON.parse(s), r.data.opts.meshThicknessOn2D === "infinity" && (r.data.opts.meshThicknessOn2D = 1 / 0), r.scene.sceneData = { ...Be, ...r.data.sceneData }, Ht.deserializeMeshDataObjects(r), r;
  }
  /**
   * Factory method to return an instance of NVDocument from JSON.
   *
   * This will merge any saved configuration options (`opts`) with the DEFAULT_OPTIONS,
   * ensuring any missing values are filled with defaults. It also restores special-case
   * fields like `meshThicknessOn2D` when serialized as the string "infinity".
   *
   * @param data - A serialized DocumentData object
   * @returns A reconstructed NVDocument instance
   */
  static loadFromJSON(t) {
    const i = new Ht();
    Object.assign(i.data, {
      ...t,
      imageOptionsArray: t.imageOptionsArray ?? [],
      encodedImageBlobs: t.encodedImageBlobs ?? [],
      labels: t.labels ?? [],
      meshOptionsArray: t.meshOptionsArray ?? [],
      connectomes: t.connectomes ?? [],
      encodedDrawingBlob: t.encodedDrawingBlob ?? "",
      previewImageDataURL: t.previewImageDataURL ?? "",
      customData: t.customData ?? "",
      title: t.title ?? "untitled"
    }), i.data.opts = {
      ...kt,
      ...t.opts || {}
    }, i.data.opts.meshThicknessOn2D === "infinity" && (i.data.opts.meshThicknessOn2D = 1 / 0), i.scene.sceneData = {
      ...Be,
      ...t.sceneData || {}
    };
    const s = t.sceneData || {};
    return s.clipPlane && !s.clipPlanes && (i.scene.sceneData.clipPlanes = [s.clipPlane]), s.clipPlaneDepthAziElev && !s.clipPlaneDepthAziElevs && (i.scene.sceneData.clipPlaneDepthAziElevs = [s.clipPlaneDepthAziElev]), t.completedMeasurements && (i.completedMeasurements = t.completedMeasurements.map((r) => ({
      ...r,
      startMM: Ot(r.startMM),
      endMM: Ot(r.endMM)
    }))), t.completedAngles && (i.completedAngles = t.completedAngles.map((r) => ({
      ...r,
      firstLineMM: {
        start: Ot(r.firstLineMM.start),
        end: Ot(r.firstLineMM.end)
      },
      secondLineMM: {
        start: Ot(r.secondLineMM.start),
        end: Ot(r.secondLineMM.end)
      }
    }))), i.data.meshesString && Ht.deserializeMeshDataObjects(i), i;
  }
  /**
   * Factory method to return an instance of NVDocument from JSON
   */
  static oldloadFromJSON(t) {
    const i = new Ht();
    return i.data = t, i.data.opts.meshThicknessOn2D === "infinity" && (i.data.opts.meshThicknessOn2D = 1 / 0), i.scene.sceneData = { ...Be, ...t.sceneData }, Ht.deserializeMeshDataObjects(i), i;
  }
  /**
   * Sets the callback function to be called when opts properties change
   */
  setOptsChangeCallback(t) {
    this._optsChangeCallback = t, this._optsProxy = null;
  }
  /**
   * Removes the opts change callback
   */
  removeOptsChangeCallback() {
    this._optsChangeCallback = null, this._optsProxy = null;
  }
  /**
   * Creates a Proxy wrapper around the opts object to detect changes
   */
  _createOptsProxy() {
    const t = this.data.opts;
    this._optsProxy = new Proxy(t, {
      set: (i, s, r) => {
        const a = i[s];
        return a !== r && (i[s] = r, this._optsChangeCallback && typeof s == "string" && s in kt && this._optsChangeCallback(s, r, a)), !0;
      },
      get: (i, s) => i[s]
    });
  }
}, ic = {
  colormap: "gray",
  opacity: 0,
  nFrame4D: 0,
  frame4D: 0,
  outlineBorder: 0,
  cal_min: 0,
  cal_max: 0,
  cal_minNeg: 0,
  cal_maxNeg: 0,
  colormapType: 0,
  values: new Array(),
  useNegativeCmap: !1,
  showLegend: !0
}, Ae = class Gt {
  /**
   * @param pts - a 3xN array of vertex positions (X,Y,Z coordinates).
   * @param tris - a 3xN array of triangle indices (I,J,K; indexed from zero). Each triangle generated from three vertices.
   * @param name - a name for this image. Default is an empty string
   * @param rgba255 - the base color of the mesh. RGBA values from 0 to 255. Default is white
   * @param opacity - the opacity for this mesh. default is 1
   * @param visible - whether or not this image is to be visible
   * @param gl - WebGL rendering context
   * @param connectome - specify connectome edges and nodes. Default is null (not a connectome).
   * @param dpg - Data per group for tractography, see TRK format. Default is null (not tractograpgy)
   * @param dps - Data per streamline for tractography, see TRK format.  Default is null (not tractograpgy)
   * @param dpv - Data per vertex for tractography, see TRK format.  Default is null (not tractograpgy)
   * @param groups - Groups for tractography, see TRK format. Default is null (not tractograpgy)
   * @param colorbarVisible - does this mesh display a colorbar
   * @param anatomicalStructurePrimary - region for mesh. Default is an empty string
   */
  constructor(t, i, s = "", r = new Uint8Array([255, 255, 255, 255]), a = 1, n = !0, o, l = null, c = null, h = null, f = null, d = null, u = !0, m = "") {
    I(this, "id"), I(this, "name"), I(this, "anatomicalStructurePrimary"), I(this, "colorbarVisible"), I(this, "furthestVertexFromOrigin"), I(this, "extentsMin"), I(this, "extentsMax"), I(this, "opacity"), I(this, "visible"), I(this, "meshShaderIndex", 0), I(this, "offsetPt0", null), I(this, "colormapInvert", !1), I(this, "fiberGroupColormap", null), I(this, "indexBuffer"), I(this, "vertexBuffer"), I(this, "vao"), I(this, "vaoFiber"), I(this, "pts"), I(this, "tris"), I(this, "layers"), I(
      this,
      "type",
      "mesh"
      /* MESH */
    ), I(this, "data_type"), I(this, "rgba255"), I(this, "fiberLength"), I(this, "fiberLengths"), I(this, "fiberDensity"), I(this, "fiberDither", 0.1), I(this, "fiberColor", "Global"), I(this, "fiberDecimationStride", 1), I(this, "fiberSides", 5), I(this, "fiberRadius", 0), I(this, "fiberOcclusion", 0), I(this, "f32PerVertex", 5), I(this, "dpsThreshold", NaN), I(this, "fiberMask"), I(this, "colormap"), I(this, "dpg"), I(this, "dps"), I(this, "dpv"), I(this, "groups"), I(this, "hasConnectome", !1), I(this, "connectome"), I(this, "indexCount"), I(this, "vertexCount", 1), I(this, "nodeScale", 4), I(this, "edgeScale", 1), I(this, "legendLineThickness", 0), I(this, "showLegend", !0), I(this, "nodeColormap", "warm"), I(this, "edgeColormap", "warm"), I(this, "nodeColormapNegative"), I(this, "edgeColormapNegative"), I(this, "nodeMinColor"), I(this, "nodeMaxColor"), I(this, "edgeMin"), I(this, "edgeMax"), I(this, "nodes"), I(this, "edges"), I(this, "points"), this.anatomicalStructurePrimary = m, this.name = s, this.colorbarVisible = u, this.id = $i();
    const g = ne.getExtents(t);
    if (this.furthestVertexFromOrigin = g.mxDx, this.extentsMin = g.extentsMin, this.extentsMax = g.extentsMax, this.opacity = a > 1 ? 1 : a, this.visible = n, this.meshShaderIndex = 0, this.indexBuffer = o.createBuffer(), this.vertexBuffer = o.createBuffer(), this.vao = o.createVertexArray(), o.bindVertexArray(this.vao), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, this.indexBuffer), o.bindBuffer(o.ARRAY_BUFFER, this.vertexBuffer), o.enableVertexAttribArray(0), o.enableVertexAttribArray(1), this.f32PerVertex !== 7 ? (o.vertexAttribPointer(0, 3, o.FLOAT, !1, 20, 0), o.vertexAttribPointer(1, 4, o.BYTE, !0, 20, 12), o.enableVertexAttribArray(2), o.vertexAttribPointer(2, 4, o.UNSIGNED_BYTE, !0, 20, 16)) : (o.vertexAttribPointer(0, 3, o.FLOAT, !1, 28, 0), o.vertexAttribPointer(1, 3, o.FLOAT, !1, 28, 12), o.enableVertexAttribArray(2), o.vertexAttribPointer(2, 4, o.UNSIGNED_BYTE, !0, 28, 24)), o.bindVertexArray(null), this.vaoFiber = o.createVertexArray(), this.offsetPt0 = null, this.hasConnectome = !1, this.colormapInvert = !1, this.fiberGroupColormap = null, this.pts = t, this.layers = [], this.type = "mesh", this.tris = i, r[3] < 1) {
      this.rgba255 = r, this.fiberLength = 2, this.fiberDither = 0.1, this.fiberColor = "Global", this.fiberDecimationStride = 1, this.fiberMask = [], this.colormap = l, this.dpg = c, this.dps = h, this.dpv = f, this.groups = d, c && this.initValuesArray(c), h && this.initValuesArray(h), f && this.initValuesArray(f), d && this.initValuesArray(d), this.offsetPt0 = new Uint32Array(i), this.tris = new Uint32Array(0), this.updateFibers(o), o.bindVertexArray(this.vaoFiber), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, this.indexBuffer), o.bindBuffer(o.ARRAY_BUFFER, this.vertexBuffer), o.enableVertexAttribArray(0), o.vertexAttribPointer(0, 3, o.FLOAT, !1, 16, 0), o.enableVertexAttribArray(1), o.vertexAttribPointer(1, 4, o.UNSIGNED_BYTE, !0, 16, 12), o.bindVertexArray(null);
      return;
    }
    if (l) {
      this.connectome = l, this.hasConnectome = !0;
      const A = Object.keys(l);
      for (let x = 0, w = A.length; x < w; x++)
        this[A[x]] = l[A[x]];
    }
    this.rgba255 = r, this.updateMesh(o);
  }
  initValuesArray(t) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i].vals.reduce((a, n) => Math.min(a, n)), r = t[i].vals.reduce((a, n) => Math.max(a, n));
      t[i].global_min = s, t[i].global_max = r, t[i].cal_min = s, t[i].cal_max = r;
    }
    return t;
  }
  // given streamlines (which webGL renders as a single pixel), extrude to cylinders
  linesToCylinders(t, i, s) {
    function r(E) {
      return O(E[0], E[1], E[2]);
    }
    const a = Math.pow(2, 32) - 1, n = s.length;
    let o = 0, l = 0;
    for (let E = 0; E < n; E++) {
      if (s[E] === a) {
        l++;
        continue;
      }
      o++;
    }
    const c = this.fiberSides, h = c * o, f = this.f32PerVertex;
    if (f !== 5)
      throw Error("fiberSides > 1 requires f32PerVertex == 5");
    const d = new Float32Array(h * f), u = new Uint8Array(d.buffer);
    let m = 0, g = Wt(), p = Wt(), A = Wt();
    const x = nt();
    let w = nt(), v = 0;
    const F = this.fiberRadius;
    for (let E = 0; E < n; E++) {
      const S = s[E] === a;
      if (S && v < 1)
        continue;
      let D = s[E] * 4;
      if (v++, v <= 1) {
        g = ht(i[D + 0], i[D + 1], i[D + 2], i[D + 3]), p = Zt(g), E + 1 < n && s[E + 1] !== a && (D = s[E + 1] * 4, A = ht(i[D + 0], i[D + 1], i[D + 2], i[D + 3]), ot(x, r(g), r(A)), Rt(x, x), w = he.getFirstPerpVector(x));
        continue;
      }
      S ? A = Zt(p) : A = ht(i[D + 0], i[D + 1], i[D + 2], i[D + 3]), ot(x, r(g), r(A)), Rt(x, x);
      const M = nt();
      mi(M, w, x);
      const B = nt();
      mi(B, x, M), w = Ot(w);
      const T = nt();
      mi(T, x, B), Rt(T, T);
      const U = nt();
      for (let R = 0; R < c; R++) {
        const N = Math.cos(R / c * 2 * Math.PI), k = Math.sin(R / c * 2 * Math.PI);
        U[0] = F * (N * B[0] + k * T[0]), U[1] = F * (N * B[1] + k * T[1]), U[2] = F * (N * B[2] + k * T[2]), le(U, r(p), U);
        const L = m * f;
        d[L + 0] = U[0], d[L + 1] = U[1], d[L + 2] = U[2];
        const q = nt();
        ot(q, U, r(p)), Rt(q, q);
        const _ = (L + 3) * 4;
        u[_ + 0] = q[0] * 127, u[_ + 1] = q[1] * 127, u[_ + 2] = q[2] * 127, d[L + 4] = p[3], m++;
      }
      g = Zt(p), p = Zt(A), S && (v = 0);
    }
    const C = (o - l) * c * 2 * 3, b = new Uint32Array(C);
    let y = 0;
    m = 0;
    for (let E = 1; E < n; E++) {
      if (s[E] === a) {
        m += c;
        continue;
      }
      if (s[E - 1] === a)
        continue;
      let S = m, D = m + c;
      const M = D, B = D + c;
      for (let T = 0; T < c; T++)
        b[y++] = S, b[y++] = D++, D === B && (D = B - c), b[y++] = D, b[y++] = S++, S === M && (S = M - c), b[y++] = D, b[y++] = S;
      m += c;
    }
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, Uint32Array.from(b), t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, u, t.STATIC_DRAW), this.indexCount = C;
  }
  // linesToCylinders
  createFiberDensityMap() {
    if (this.fiberDensity)
      return;
    const t = this.pts, i = t.length / 3;
    let s = 0;
    for (let x = 0; x < 3; x++) {
      const w = this.extentsMax[x] - this.extentsMin[x];
      s = Math.max(s, w);
    }
    if (this.fiberDensity = new Float32Array(i), s === 0)
      return;
    const r = 64, n = s / (r - 1) / 2, o = (r - 1) / s;
    let l = new Float32Array(r * r * r);
    const c = [this.extentsMin[0] - n, this.extentsMin[1] - n, this.extentsMin[2] - n], h = [0, 0, 0], f = -1, d = r * r;
    let u = 0;
    for (let x = 0; x < i; x++) {
      h[0] = Math.round((t[u++] - c[0]) * o), h[1] = Math.round((t[u++] - c[1]) * o), h[2] = Math.round((t[u++] - c[2]) * o);
      const w = h[0] + h[1] * r + h[2] * d;
      w !== f && l[w]++;
    }
    function m(x, w) {
      let v = x.slice(), F = -1;
      const C = w - 1;
      for (let y = 0; y < w; y++)
        for (let E = 0; E < w; E++)
          for (let S = 0; S < w; S++)
            F++, !(S < 1 || S >= C) && (x[F] = v[F - 1] + v[F] + v[F] + v[F + 1]);
      F = -1, v = x.slice();
      for (let y = 0; y < w; y++)
        for (let E = 0; E < w; E++)
          for (let S = 0; S < w; S++)
            F++, !(E < 1 || E >= C) && (x[F] = v[F - w] + v[F] + v[F] + v[F + w]);
      const b = w * w;
      F = -1, v = x.slice();
      for (let y = 0; y < w; y++)
        for (let E = 0; E < w; E++)
          for (let S = 0; S < w; S++)
            F++, !(y < 1 || y >= C) && (x[F] = v[F - b] + v[F] + v[F] + v[b]);
      return x;
    }
    l = m(l, r), l = m(l, r);
    let g = 0, p = 1 / 0;
    const A = r * r * r;
    for (let x = 0; x < A; x++)
      l[x] <= 0 || (g = Math.max(g, l[x]), p = Math.min(p, l[x]));
    if (!(g <= 1 || g <= p)) {
      u = 0;
      for (let x = 0; x < A; x++)
        l[x] = Math.max(0, l[x] - p);
      g -= p;
      for (let x = 0; x < i; x++) {
        h[0] = Math.round((t[u++] - c[0]) * o), h[1] = Math.round((t[u++] - c[1]) * o), h[2] = Math.round((t[u++] - c[2]) * o);
        const w = h[0] + h[1] * r + h[2] * d;
        this.fiberDensity[x] = l[w] / g;
      }
    }
  }
  // not included in public docs
  // internal function filters tractogram to identify which color and visibility of streamlines
  updateFibers(t) {
    if (!this.offsetPt0 || !this.fiberLength)
      return;
    const i = this.pts, s = this.offsetPt0, r = s.length - 1, a = i.length / 3;
    if (!this.fiberLengths) {
      this.fiberLengths = new Uint32Array(r);
      for (let C = 0; C < r; C++) {
        const b = s[C] * 3, y = (s[C + 1] - 1) * 3;
        let E = 0;
        for (let S = b; S < y; S += 3) {
          const D = O(i[S + 0] - i[S + 3], i[S + 1] - i[S + 4], i[S + 2] - i[S + 5]);
          E += Le(D);
        }
        this.fiberLengths[C] = E;
      }
    }
    const n = new Float32Array(a * 4), o = new Uint32Array(n.buffer);
    let l = 0, c = 0;
    for (let C = 0; C < a; C++)
      n[c + 0] = i[l + 0], n[c + 1] = i[l + 1], n[c + 2] = i[l + 2], l += 3, c += 4;
    const h = this.fiberDither, f = h * 0.5;
    function d(C, b, y) {
      const S = 255 * (h * Math.random() - f);
      return C = Math.max(Math.min(C + S, 255), 0), b = Math.max(Math.min(b + S, 255), 0), y = Math.max(Math.min(y + S, 255), 0), C + (b << 8) + (y << 16);
    }
    function u(C, b, y, E, S, D, M) {
      const B = O(Math.abs(C - E), Math.abs(b - S), Math.abs(y - D));
      Rt(B, B);
      const T = M - f;
      for (let U = 0; U < 3; U++)
        B[U] = 255 * Math.max(Math.min(Math.abs(B[U]) + T, 1), 0);
      return B[0] + (B[1] << 8) + (B[2] << 16);
    }
    const m = this.fiberColor.toLowerCase();
    let g = null, p = null;
    if (m.startsWith("dps") && this.dps && this.dps.length > 0) {
      const C = parseInt(m.substring(3));
      C < this.dps.length && this.dps[C].vals.length === r && (g = this.dps[C].vals);
    }
    if (m.startsWith("dpv") && this.dpv && this.dpv.length > 0) {
      const C = parseInt(m.substring(3));
      C < this.dpv.length && this.dpv[C].vals.length === a && (p = this.dpv[C]);
    }
    const A = new Int16Array(r);
    if (this.groups && this.fiberGroupColormap !== null || m.startsWith("dpg") && this.dpg.length > 0) {
      const C = new Uint8ClampedArray(this.groups.length * 4), b = new Array(this.groups.length).fill(!1);
      if (this.fiberGroupColormap) {
        const y = this.fiberGroupColormap;
        y.A === void 0 && (y.A = Array.from(new Uint8ClampedArray(y.I.length).fill(255)));
        for (let E = 0; E < y.I.length; E++) {
          let S = y.I[E];
          S < 0 || S >= this.groups.length || y.A[E] < 1 || (b[S] = !0, S *= 4, C[S] = y.R[E], C[S + 1] = y.G[E], C[S + 2] = y.B[E], C[S + 3] = 255);
        }
      } else if (m.startsWith("dpg") && this.dpg.length > 0) {
        const y = parseInt(m.substring(3)), E = y < this.dpg.length ? this.dpg[y] : this.dpg[0], S = rt.colormap(this.colormap, this.colormapInvert), D = E.cal_min, M = E.cal_max, B = this.groups.length;
        for (let T = 0; T < B; T++) {
          const U = E.vals[T];
          if (U < D)
            continue;
          let R = Math.round(255 * Math.min(Math.max((U - D) / (M - D), 0), 1));
          b[T] = !0;
          const N = T * 4;
          R *= 4, C[N] = S[R + 0], C[N + 1] = S[R + 1], C[N + 2] = S[R + 2], C[N + 3] = 255;
        }
      }
      A.fill(-1);
      for (let y = 0; y < this.groups.length; y++)
        if (b[y])
          for (let E = 0; E < this.groups[y].vals.length; E++)
            A[this.groups[y].vals[E]] = y;
      for (let y = 0; y < r; y++) {
        if (A[y] < 0)
          continue;
        const E = A[y] % 256 * 4, S = d(C[E], C[E + 1], C[E + 2]), D = s[y], M = s[y + 1] - 1, B = D * 4 + 3, T = M * 4 + 3;
        for (let U = B; U <= T; U += 4)
          o[U] = S;
      }
    } else if (p) {
      const C = rt.colormap(this.colormap, this.colormapInvert), b = p.cal_min, y = p.cal_max;
      let E = 3;
      for (let S = 0; S < a; S++) {
        let D = Math.min(Math.max((p.vals[S] - b) / (y - b), 0), 1);
        D = Math.round(Math.max(Math.min(255, D * 255))) * 4;
        const M = C[D] + (C[D + 1] << 8) + (C[D + 2] << 16);
        o[E] = M, E += 4;
      }
    } else if (g) {
      const C = rt.colormap(this.colormap, this.colormapInvert);
      let b = g[0], y = g[0];
      for (let E = 0; E < r; E++)
        b = Math.min(b, g[E]), y = Math.max(y, g[E]);
      y === b && (b -= 1);
      for (let E = 0; E < r; E++) {
        let S = (g[E] - b) / (y - b);
        S = Math.round(Math.max(Math.min(255, S * 255))) * 4;
        const D = C[S] + (C[S + 1] << 8) + (C[S + 2] << 16), M = s[E], B = s[E + 1] - 1, T = M * 4 + 3, U = B * 4 + 3;
        for (let R = T; R <= U; R += 4)
          o[R] = D;
      }
    } else if (m.includes("fixed"))
      if (h === 0) {
        const C = this.rgba255[0] + (this.rgba255[1] << 8) + (this.rgba255[2] << 16);
        let b = 3;
        for (let y = 0; y < a; y++)
          o[b] = C, b += 4;
      } else
        for (let C = 0; C < r; C++) {
          const b = d(this.rgba255[0], this.rgba255[1], this.rgba255[2]), y = s[C], E = s[C + 1] - 1, S = y * 4 + 3, D = E * 4 + 3;
          for (let M = S; M <= D; M += 4)
            o[M] = b;
        }
    else if (m.includes("local"))
      for (let C = 0; C < r; C++) {
        const b = s[C], y = s[C + 1] - 1;
        let E = b * 3;
        const S = y * 3, D = h * Math.random();
        let M = u(i[E], i[E + 1], i[E + 2], i[E + 4], i[E + 5], i[E + 6], D), B = b * 4 + 3;
        for (; E < S; )
          o[B] = M, B += 4, E += 3, M = u(i[E - 3], i[E - 2], i[E - 1], i[E + 3], i[E + 4], i[E + 5], D);
        o[B] = o[B - 4];
      }
    else
      for (let C = 0; C < r; C++) {
        const b = s[C], y = s[C + 1] - 1, E = b * 3, S = y * 3, D = u(
          i[E],
          i[E + 1],
          i[E + 2],
          i[S],
          i[S + 1],
          i[S + 2],
          h * Math.random()
        ), M = b * 4 + 3, B = y * 4 + 3;
        for (let T = M; T <= B; T += 4)
          o[T] = D;
      }
    if (this.fiberOcclusion > 0) {
      let C = function(b, y) {
        const E = y * (b & 255), S = y * (b >> 8 & 255), D = y * (b >> 16 & 255);
        return E + (S << 8) + (D << 16);
      };
      this.createFiberDensityMap();
      for (let b = 0; b < r; b++) {
        const y = s[b], E = s[b + 1] - 1, S = y * 4 + 3, D = E * 4 + 3;
        let M = y;
        const B = Math.min(this.fiberOcclusion, 0.99);
        for (let T = S; T <= D; T += 4) {
          let U = this.fiberDensity[M++];
          if (U <= 0)
            continue;
          U = U / ((1 / B - 2) * (1 - U) + 1);
          const R = 1 - Math.min(U, 0.9);
          let N = o[T];
          N = C(N, R), o[T] = N;
        }
      }
    }
    if (Number.isFinite(this.dpsThreshold) && this.dps && (g || this.dps[0].vals.length === r && (g = this.dps[0].vals), g))
      for (let C = 0; C < r; C++)
        g[C] < this.dpsThreshold && (A[C] = -1);
    const x = this.fiberLength, w = Math.pow(2, 32) - 1, v = [];
    let F = -1;
    for (let C = 0; C < r; C++)
      if (!(A[C] < 0) && !(this.fiberLengths[C] < x) && (F++, F % this.fiberDecimationStride === 0)) {
        for (let b = s[C]; b < s[C + 1]; b++)
          v.push(b);
        v.push(w);
      }
    this.fiberSides > 2 && this.fiberRadius > 0 ? this.linesToCylinders(t, n, v) : (this.indexCount = v.length, t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, Uint32Array.from(o), t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, Uint32Array.from(v), t.STATIC_DRAW));
  }
  // updateFibers()
  // given X,Y,Z coordinates in world space, return index of nearest vertex as well as
  // the distance of this closest vertex to the coordinates
  indexNearestXYZmm(t, i, s) {
    const r = this.pts, a = this.pts.length / 3;
    let n = 0, o = 1 / 0, l = 0;
    for (let c = 0; c < a; c++) {
      const h = Math.pow(r[n] - t, 2) + Math.pow(r[n + 1] - i, 2) + Math.pow(r[n + 2] - s, 2);
      h < o && (o = h, l = c), n += 3;
    }
    return o = Math.sqrt(o), [l, o];
  }
  // indexNearestXYZmm()
  // internal function discards GPU resources
  unloadMesh(t) {
    if (t.bindBuffer(t.ARRAY_BUFFER, null), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null), t.bindVertexArray(null), t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.indexBuffer), t.deleteVertexArray(this.vao), t.deleteVertexArray(this.vaoFiber), this.offsetPt0 = null, this.tris = null, this.pts = null, this.layers && this.layers.length > 0)
      for (let i = 0; i < this.layers.length; i++)
        this.layers[i].values = null;
    if (this.dpg && this.dpg.length > 0)
      for (let i = 0; i < this.dpg.length; i++)
        this.dpg[i].vals = null;
    if (this.dps && this.dps.length > 0)
      for (let i = 0; i < this.dps.length; i++)
        this.dps[i].vals = null;
  }
  // apply color lookup table to convert scalar array to RGBA array
  scalars2RGBA(t, i, s, r = !1) {
    const a = s.length;
    if (4 * a < t.length)
      return V.error(`colormap2RGBA incorrectly specified ${a}*4 != ${t.length}`), t;
    const n = Math.round(i.opacity * 255);
    let o = i.cal_min, l = i.cal_max, c = rt.colormap(i.colormap, this.colormapInvert), h = 1;
    if (r) {
      if (!i.useNegativeCmap)
        return t;
      h = -1, c = rt.colormap(i.colormapNegative, i.colormapInvert), o = i.cal_min, l = i.cal_max, isFinite(i.cal_minNeg) && isFinite(i.cal_minNeg) && (o = -i.cal_minNeg, l = -i.cal_maxNeg);
    }
    let f = o;
    i.isTransparentBelowCalMin || (f = Number.NEGATIVE_INFINITY);
    const d = i.colormapType === 2;
    i.colormapType !== 0 && (o = Math.min(o, 0));
    const u = 255 / (l - o);
    for (let m = 0; m < a; m++) {
      let g = s[m] * h;
      if (isNaN(g))
        continue;
      let p = n;
      if (g < f)
        if (g > 0 && d)
          p = Math.round(i.opacity * 255 * Math.pow(g / f, 2));
        else
          continue;
      if (g = (g - o) * u, g < 0 && i.isTransparentBelowCalMin)
        continue;
      g = Math.min(255, Math.max(0, Math.round(g))) * 4;
      const A = m * 4;
      t[A + 0] = c[g + 0], t[A + 1] = c[g + 1], t[A + 2] = c[g + 2], t[A + 3] = p;
    }
    return t;
  }
  blendColormap(t, i, s, r, a, n, o = !1) {
    const l = this.pts.length / 3, c = Math.min(s.opacity, 1);
    function h(w, v, F) {
      return w * (1 - F) + v * F;
    }
    function f(w, v) {
      return Math.min(w + v, 255);
    }
    const d = o ? -1 : 1, u = Math.min(Math.max(s.frame4D, 0), s.nFrame4D - 1), m = l * u;
    let g = r;
    s.isTransparentBelowCalMin || (g = Number.NEGATIVE_INFINITY), s.colormapType !== 0 && (r = Math.min(r, 0));
    const p = 255 / (a - r);
    let A = new Array(l).fill(!1);
    if (s.outlineBorder !== 0) {
      const w = new Uint8Array(l).fill(0);
      for (let v = 0; v < l; v++)
        d * s.values[v + m] >= g && (w[v] = 1);
      A = ne.getClusterBoundaryU8(w, this.tris);
      for (let v = 0; v < l; v++)
        d * s.values[v + m] < g && (A[v] = !1);
    }
    const x = new Float32Array(256).fill(c);
    if (g > r && s.colormapType === 2) {
      let w = Math.round((g - r) * p);
      w = Math.max(w, 1);
      for (let v = 1; v < w; v++)
        x[v] = c * Math.pow(v / w, 2);
      x[0] = 0, g = r + Number.EPSILON;
    }
    for (let w = 0; w < l; w++) {
      const v = d * s.values[w + m];
      if (v < g)
        continue;
      let F = Math.round((v - r) * p);
      if (F < 0 && s.isTransparentBelowCalMin)
        continue;
      F = Math.max(0, F), F = Math.min(255, F);
      let C = x[F];
      F *= 4;
      let b = w * 28 + 24;
      if (this.f32PerVertex !== 7 && (b = w * 20 + 16), s.isAdditiveBlend) {
        const y = w * 4;
        i[y + 0] = f(i[y + 0], n[F + 0]), i[y + 1] = f(i[y + 1], n[F + 1]), i[y + 2] = f(i[y + 2], n[F + 2]), i[y + 3] = f(i[y + 3], 255);
      } else {
        if (A[w] && (C = s.outlineBorder, s.outlineBorder < 0)) {
          t[b + 0] = 0, t[b + 1] = 0, t[b + 2] = 0;
          continue;
        }
        t[b + 0] = h(t[b + 0], n[F + 0], C), t[b + 1] = h(t[b + 1], n[F + 1], C), t[b + 2] = h(t[b + 2], n[F + 2], C);
      }
    }
  }
  // blendColormap()
  // internal function filters mesh to identify which color of triangulated mesh vertices
  updateMesh(t) {
    if (this.offsetPt0) {
      this.updateFibers(t);
      return;
    }
    if (this.hasConnectome)
      return;
    if (!this.pts || !this.tris || !this.rgba255) {
      V.warn("underspecified mesh");
      return;
    }
    function i(c, h, f) {
      return c * (1 - f) + h * f;
    }
    const s = this.generatePosNormClr(this.pts, this.tris, this.rgba255), r = this.pts.length / 3, a = new Uint8Array(s.buffer);
    let n = 0;
    const o = new Uint8Array(r * 4);
    let l = this.tris;
    if (this.layers && this.layers.length > 0)
      for (let c = 0; c < this.layers.length; c++) {
        const h = this.layers[c], f = h.opacity;
        if (f <= 0 || h.cal_min > h.cal_max)
          continue;
        if (h.outlineBorder === void 0 && (h.outlineBorder = 0), h.isAdditiveBlend === void 0 && (h.isAdditiveBlend = !1), h.colormapLabel && h.colormapLabel.R && !h.colormapLabel.lut && (h.colormapLabel = rt.makeLabelLut(h.colormapLabel, 255, h.global_max)), h.colormapLabel && h.colormapLabel.lut) {
          const u = h.colormapLabel;
          let m = 0;
          h.colormapLabel.min && (m = h.colormapLabel.min);
          let g = u.lut;
          const p = Math.floor(g.length / 4);
          if (h.atlasValues && p > 0 && p === h.atlasValues.length && h.colormap) {
            const C = h.atlasValues;
            let b = !1, y = !0;
            for (let E = 0; E < p; E++)
              isNaN(C[E]) ? b = !0 : y = !1;
            if (y) {
              V.debug("invisible mesh: all atlasValues are NaN.");
              return;
            }
            if (b) {
              V.debug("some vertices have NaN atlasValues (mesh will be decimated).");
              const E = new Array(r).fill(!1);
              for (let T = 0; T < r; T++) {
                const U = Math.round(h.values[T]) - m;
                isNaN(C[U]) && (E[T] = !0);
              }
              const S = new Array(l.length).fill(!1);
              for (let T = 0; T < l.length; T++)
                E[l[T]] && (S[T] = !0);
              const D = this.tris;
              let M = 0;
              for (let T = 0; T < D.length; T += 3)
                !S[T] && !S[T + 1] && !S[T + 2] && M++;
              M === 0 && V.debug("invisible mesh: all triangles of a vertex with a NaN atlasValue."), l = new Uint32Array(M * 3);
              let B = 0;
              for (let T = 0; T < D.length; T += 3)
                !S[T] && !S[T + 1] && !S[T + 2] && (l[B++] = D[T], l[B++] = D[T + 1], l[B++] = D[T + 2]);
            }
            g.fill(0), g = this.scalars2RGBA(g, h, C), h.useNegativeCmap && (g = this.scalars2RGBA(g, h, C, !0));
          } else h.atlasValues && V.warn(`Expected ${p} atlasValues but got ${h.atlasValues.length} for mesh layer`);
          if (h.showLegend && p === h.colormapLabel.labels.length) {
            h.labels = [];
            for (let C = 0; C < p; C++) {
              const b = Array.from(g.slice(C * 4, C * 4 + 4)).map((M) => M / 255), y = h.colormapLabel.labels[C], E = [0, 0, 0];
              let S = 0;
              for (let M = 0; M < r; M++)
                if (h.values[M] === C) {
                  const B = M * 3;
                  E[0] += this.pts[B], E[1] += this.pts[B + 1], E[2] += this.pts[B + 2], S++;
                }
              if (S > 0 && (E[0] /= S, E[1] /= S, E[2] /= S), b[3] === 0 || !y || // handles empty string, null, undefined
              y.startsWith("_"))
                continue;
              b[3] = 1;
              const D = new Es(
                y,
                {
                  textColor: b,
                  bulletScale: 1,
                  bulletColor: b,
                  lineWidth: 0,
                  lineColor: b,
                  textScale: 1,
                  textAlignment: "left",
                  lineTerminator: "none"
                  /* NONE */
                },
                E
              );
              h.labels.push(D), V.debug("label for mesh layer:", D);
            }
          } else
            delete h.labels;
          const A = Math.min(Math.max(h.frame4D, 0), h.nFrame4D - 1), x = r * A, w = new Uint8Array(r * 4);
          let v = 0;
          for (let C = 0; C < r; C++) {
            const b = h.values[C + x] - m, y = 4 * Math.min(Math.max(b, 0), p - 1);
            w[v + 0] = g[y + 0], w[v + 1] = g[y + 1], w[v + 2] = g[y + 2], w[v + 3] = Math.round(g[y + 3] / 255 * h.opacity * 255), v += 4;
          }
          let F = new Array(r).fill(!1);
          h.outlineBorder !== 0 && (F = ne.getClusterBoundary(w, this.tris)), v = 0;
          for (let C = 0; C < r; C++) {
            let b = C * 28 + 24;
            this.f32PerVertex !== 7 && (b = C * 20 + 16);
            let y = w[v + 3] / 255;
            if (F[C] && (y = h.outlineBorder, h.outlineBorder < 0)) {
              a[b + 0] = 0, a[b + 1] = 0, a[b + 2] = 0, v += 4;
              continue;
            }
            a[b + 0] = i(a[b + 0], w[v + 0], y), a[b + 1] = i(a[b + 1], w[v + 1], y), a[b + 2] = i(a[b + 2], w[v + 2], y), v += 4;
          }
          continue;
        }
        if (h.values instanceof Uint8Array) {
          const u = new Uint8Array(h.values.buffer);
          let m = new Array(r).fill(!0);
          h.outlineBorder !== 0 && (m = ne.getClusterBoundary(u, this.tris));
          let g = 0;
          for (let p = 0; p < h.values.length; p++) {
            let A = p * 28 + 24;
            this.f32PerVertex !== 7 && (A = p * 20 + 16);
            let x = f;
            if (m[p] && (x = h.outlineBorder, h.outlineBorder < 0)) {
              a[A + 0] = 0, a[A + 1] = 0, a[A + 2] = 0, g += 4;
              continue;
            }
            a[A + 0] = i(a[A + 0], u[g + 0], x), a[A + 1] = i(a[A + 1], u[g + 1], x), a[A + 2] = i(a[A + 2], u[g + 2], x), g += 4;
          }
          continue;
        }
        h.useNegativeCmap && (h.cal_min = Math.max(Number.EPSILON, h.cal_min), h.cal_max = Math.max(h.cal_min + 1e-6, h.cal_max)), h.isTransparentBelowCalMin === void 0 && (h.isTransparentBelowCalMin = !0);
        const d = rt.colormap(h.colormap, h.colormapInvert);
        if (h.isAdditiveBlend && n++, this.blendColormap(a, o, h, h.cal_min, h.cal_max, d), h.useNegativeCmap) {
          const u = rt.colormap(h.colormapNegative, h.colormapInvert);
          let m = h.cal_min, g = h.cal_max;
          isFinite(h.cal_minNeg) && isFinite(h.cal_minNeg) && (m = -h.cal_minNeg, g = -h.cal_maxNeg), this.blendColormap(a, o, h, m, g, u, !0);
        }
      }
    if (n > 0)
      for (let c = 0; c < r; c++) {
        let h = function(m, g) {
          return Math.min(m * g * 0.00392156862745098, 255);
        }, f = c * 28 + 24;
        this.f32PerVertex !== 7 && (f = c * 20 + 16);
        const d = c * 4, u = Math.min(n, o[d + 3] / 255);
        u <= 0 || (a[f + 0] = h(a[f + 0], o[d + 0]), a[f + 1] = h(a[f + 1], o[d + 1]), a[f + 2] = h(a[f + 2], o[d + 2]), a[f + 0] = i(a[f + 0], o[d + 0], u), a[f + 1] = i(a[f + 1], o[d + 1], u), a[f + 2] = i(a[f + 2], o[d + 2], u));
      }
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, Uint32Array.from(l), t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, a, t.STATIC_DRAW), this.indexCount = l.length, this.vertexCount = this.pts.length;
  }
  // updateMesh()
  // internal function filters mesh to identify which color of triangulated mesh vertices
  reverseFaces(t) {
    if (this.offsetPt0 || this.hasConnectome)
      return;
    const i = this.tris || [];
    for (let s = 0; s < i.length; s += 3) {
      const r = i[s];
      i[s] = i[s + 1], i[s + 1] = r;
    }
    this.updateMesh(t);
  }
  hierarchicalOrder() {
    const s = this.tris.length / 3, r = Math.log(s / 20) / Math.log(4);
    if (s !== Math.pow(4, r) * 20)
      return NaN;
    if (this.pts.length / 3 !== Math.pow(4, r) * 10 + 2)
      return NaN;
    for (let n = 0; n < 15; n += 3)
      if (this.tris[n] !== 0)
        return NaN;
    for (let n = 15; n < 24; n += 3)
      if (this.tris[n] !== 3)
        return NaN;
    for (let n = 24; n < 30; n += 3)
      if (this.tris[n] !== 4)
        return NaN;
    return r;
  }
  decimateFaces(t, i) {
    let s = this.tris;
    const r = 12, a = 20;
    for (let n = t - 1; n >= i; n--) {
      const o = Math.pow(4, n + 1) * (r - 2) + 2, l = Math.pow(4, n) * (r - 2) + 2, c = s.length / 3, h = Math.pow(4, n) * a;
      V.info(`order ${n + 1} -> ${n} vertices ${o} -> ${l} faces ${c} -> ${h}`);
      const f = Array.from({ length: o }, (u, m) => m + 1);
      for (let u = 0; u < c; u++) {
        const m = s[3 * u], g = s[3 * u + 1], p = s[3 * u + 2];
        f[m - 1] = Math.min(f[m - 1], g, p);
      }
      const d = new Uint32Array(h * 3);
      for (let u = 0; u < h; u++)
        d[3 * u] = f[s[3 * u] - 1], d[3 * u + 1] = f[s[3 * u + 1] - 1], d[3 * u + 2] = f[s[3 * u + 2] - 1];
      s = d;
    }
    this.tris = new Uint32Array(s);
  }
  // internal function simplifies FreeSurfer triangulated mesh and overlays
  decimateHierarchicalMesh(t, i = 4) {
    const s = this.hierarchicalOrder();
    if (isNaN(s))
      return V.warn("Unable to decimate mesh: it does not have a hierarchical structure"), !1;
    if (i >= s)
      return V.warn(`Unable to decimate mesh: input order (${s}) must be larger than downsampled order (${i})`), !1;
    const r = this.pts.length / 3, n = Math.pow(4, i) * (12 - 2) + 2;
    if (this.pts = new Float32Array(this.pts.slice(0, n * 3)), this.decimateFaces(s, i), this.layers && this.layers.length > 0)
      for (let o = 0; o < this.layers.length; o++) {
        const l = this.layers[o];
        l.values instanceof Float32Array || l.values.length !== r ? l.values = new Float32Array(l.values.slice(0, n)) : V.warn("decimation logic needs to be updated");
      }
    return this.updateMesh(t), !0;
  }
  // adjust attributes of a mesh layer. invoked by niivue.setMeshLayerProperty()
  // TODO this method is a bit too generic
  async setLayerProperty(t, i, s, r) {
    const a = this.layers[t];
    if (!a || !(i in a)) {
      V.warn("mesh does not have property ", i, " for layer ", a);
      return;
    }
    if (i === "colormapLabel")
      if (typeof s == "object")
        a[i] = rt.makeLabelLut(s, 255, a.global_max);
      else if (typeof s == "string") {
        const n = await rt.makeLabelLutFromUrl(s);
        a[i] = n, this.updateMesh(r);
        return;
      } else
        V.error("colormapLabel requires a string or object");
    else
      a[i] = s;
    this.updateMesh(r);
  }
  // adjust mesh attributes. invoked by niivue.setMeshProperty(()
  // TODO this method is too generic
  setProperty(t, i, s) {
    if (!(t in this)) {
      console.warn("Mesh does not have property:", t, this);
      return;
    }
    this[t] = i, this.updateMesh(s);
  }
  // Each streamline vertex has color, normal and position attributes
  // Interleaved Vertex Data https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html
  generatePosNormClr(t, i, s) {
    (t.length < 3 || s.length < 4) && (V.error("Catastrophic failure generatePosNormClr()"), V.debug("this", this), V.debug("pts", t), V.debug("rgba", s));
    const r = ne.generateNormals(t, i), a = t.length / 3, n = a === s.length / 4, o = this.f32PerVertex, l = new Float32Array(a * o), c = new Uint8Array(l.buffer);
    let h = 0, f = 0, d = 0, u = (o - 1) * 4;
    for (let m = 0; m < a; m++)
      l[d + 0] = t[h + 0], l[d + 1] = t[h + 1], l[d + 2] = t[h + 2], o !== 7 ? (c[u - 4] = r[h + 0] * 127, c[u - 3] = r[h + 1] * 127, c[u - 2] = r[h + 2] * 127) : (l[d + 3] = r[h + 0], l[d + 4] = r[h + 1], l[d + 5] = r[h + 2]), c[u] = s[f + 0], c[u + 1] = s[f + 1], c[u + 2] = s[f + 2], c[u + 3] = s[f + 3], n && (f += 4), h += 3, d += o, u += o * 4;
    return l;
  }
  // wrapper to read meshes, tractograms and connectomes regardless of format
  static async readMesh(t, i, s, r = 1, a = new Uint8Array([255, 255, 255, 255]), n = !0) {
    let o = new Uint32Array([]), l = new Float32Array([]), c = "", h;
    const f = /(?:\.([^.]+))?$/;
    let d = f.exec(i)[1];
    if (d = d.toUpperCase(), d === "GZ" && (d = f.exec(i.slice(0, -3))[1], d = d.toUpperCase()), d === "JCON" && V.error("you should never see this message: load using nvconnectome not nvmesh"), d === "JSON" && V.error("you should never see this message: load using nvconnectome not nvmesh"), a[3] = Math.max(1, a[3]), d === "TCK" || d === "TRK" || d === "TT" || d === "TRX" || d === "TRACT") {
      if (d === "TCK" ? h = ct.readTCK(t) : d === "TRACT" ? h = ct.readTRACT(t) : d === "TT" ? h = await ct.readTT(t) : d === "TRX" ? h = await ct.readTRX(t) : h = await ct.readTRK(t), typeof h > "u") {
        const p = new Float32Array([0, 0, 0, 0, 0, 0]), A = new Uint32Array([0]);
        h = { pts: p, offsetPt0: A }, V.error("Creating empty tracts");
      }
      return a[3] = 0, new Gt(
        h.pts,
        h.offsetPt0,
        i,
        a,
        // colormap,
        r,
        // opacity,
        n,
        // visible,
        s,
        "inferno",
        h.dpg || null,
        h.dps || null,
        h.dpv || null,
        h.groups
      );
    }
    if (d === "GII")
      h = await ct.readGII(t);
    else if (d === "MZ3")
      h = await ct.readMZ3(t), "positions" in h || V.warn("MZ3 does not have positions (statistical overlay?)");
    else if (d === "ASC")
      h = ct.readASC(t);
    else if (d === "DFS")
      h = ct.readDFS(t);
    else if (d === "BYU" || d === "G")
      h = ct.readGEO(t);
    else if (d === "GEO")
      h = ct.readGEO(t, !0);
    else if (d === "ICO" || d === "TRI")
      h = ct.readICO(t);
    else if (d === "OFF")
      h = ct.readOFF(t);
    else if (d === "NV")
      h = ct.readNV(t);
    else if (d === "OBJ")
      h = await ct.readOBJ(t);
    else if (d === "PLY")
      h = ct.readPLY(t);
    else if (d === "WRL")
      h = ct.readWRL(t);
    else if (d === "X3D")
      h = ct.readX3D(t);
    else if (d === "FIB" || d === "VTK") {
      if (h = ct.readVTK(t), "offsetPt0" in h)
        return a[3] = 0, new Gt(
          h.pts,
          h.offsetPt0,
          i,
          a,
          // colormap,
          r,
          // opacity,
          n,
          // visible,
          s,
          "inferno"
        );
    } else d === "SRF" ? h = await ct.readSRF(t) : d === "STL" ? h = ct.readSTL(t) : h = ct.readFreeSurfer(t);
    if (h.anatomicalStructurePrimary && (c = h.anatomicalStructurePrimary), h instanceof Float32Array)
      throw new Error("fatal: unknown mesh type loaded");
    if (!("positions" in h))
      throw new Error("positions not loaded");
    if (!h.indices)
      throw new Error("indices not loaded");
    if (l = h.positions, o = h.indices, "rgba255" in h && h.rgba255.length > 0 && (a = h.rgba255), "colors" in h && h.colors && h.colors.length === l.length) {
      const p = l.length / 3;
      a = new Uint8Array(p * 4);
      let A = 0, x = 0;
      for (let w = 0; w < p; w++)
        a[x++] = h.colors[A] * 255, a[x++] = h.colors[A + 1] * 255, a[x++] = h.colors[A + 2] * 255, a[x++] = 255, A += 3;
    }
    const u = l.length / 3;
    if (o.length / 3 < 1 || u < 3)
      throw new Error("Mesh should have at least one triangle and three vertices");
    a[3] = Math.max(1, a[3]);
    const g = new Gt(
      l,
      o,
      i,
      a,
      // colormap,
      r,
      // opacity,
      n,
      // visible,
      s,
      null,
      // connectome
      null,
      // dpg
      null,
      // dps
      null,
      // dpv
      null,
      // groups
      !0,
      // colorbarVisible
      c
    );
    if ("scalars" in h && h.scalars.length > 0) {
      const p = await ct.readLayer(i, t, g, r, "gray");
      typeof p > "u" ? V.warn("readLayer() failed to convert scalars") : (g.layers.push(p), g.updateMesh(s));
    }
    return g;
  }
  static async loadLayer(t, i) {
    let s = new Uint8Array().buffer;
    function r(m) {
      const g = window.atob(m), p = g.length, A = new Uint8Array(p);
      for (let x = 0; x < p; x++)
        A[x] = g.charCodeAt(x);
      return A.buffer;
    }
    if (t.base64 !== void 0)
      s = r(t.base64);
    else {
      if (!t.url)
        throw new Error("layer: missing url");
      const m = await fetch(t.url, { headers: t.headers });
      if (!m.ok)
        throw Error(m.statusText);
      s = await m.arrayBuffer();
    }
    let a, n = [];
    if (t.name && t.name !== "")
      a = t.name;
    else {
      if (!t.url)
        throw new Error("layer: missing url");
      try {
        n = new URL(t.url).pathname.split("/");
      } catch {
        n = t.url.split("/");
      } finally {
        a = n.slice(-1)[0];
      }
    }
    a.indexOf("?") > -1 && (a = a.slice(0, a.indexOf("?")));
    let o = 0.5;
    "opacity" in t && (o = t.opacity);
    let l = "warm";
    "colormap" in t && (l = t.colormap);
    let c = "winter";
    "colormapNegative" in t && (c = t.colormapNegative);
    let h = !1;
    "useNegativeCmap" in t && (h = t.useNegativeCmap);
    let f = null;
    "cal_min" in t && (f = t.cal_min);
    let d = null;
    "cal_max" in t && (d = t.cal_max);
    const u = await ct.readLayer(
      a,
      s,
      i,
      o,
      l,
      c,
      h,
      f,
      d
    );
    u && i.layers.push(u);
  }
  /**
   * factory function to load and return a new NVMesh instance from a given URL
   */
  static async loadFromUrl({
    url: t = "",
    headers: i = {},
    gl: s,
    name: r = "",
    opacity: a = 1,
    rgba255: n = [255, 255, 255, 255],
    visible: o = !0,
    layers: l = [],
    buffer: c = new ArrayBuffer(0)
  } = {}) {
    let h = t.split("/");
    if (r === "") {
      try {
        h = new URL(t).pathname.split("/");
      } catch {
        h = t.split("/");
      }
      r = h.slice(-1)[0], r.indexOf("?") > -1 && (r = r.slice(0, r.indexOf("?")));
    }
    if (t === "")
      throw Error("url must not be empty");
    if (!s)
      throw Error("gl context is null");
    let f;
    if (c.byteLength > 0)
      f = c;
    else {
      const u = await fetch(t, { headers: i });
      if (!u.ok)
        throw Error(u.statusText);
      f = await u.arrayBuffer();
    }
    const d = await this.readMesh(f, r, s, a, new Uint8Array(n), o);
    if (!l || l.length < 1)
      return d;
    for (let u = 0; u < l.length; u++)
      await Gt.loadLayer(l[u], d);
    return d.updateMesh(s), d;
  }
  // not included in public docs
  // loading Nifti files
  static async readFileAsync(t) {
    return new Promise((i, s) => {
      const r = new FileReader();
      r.onload = () => {
        i(r.result);
      }, r.onerror = s, r.readAsArrayBuffer(t);
    });
  }
  /**
   * factory function to load and return a new NVMesh instance from a file in the browser
   *
   * @returns NVMesh instance
   */
  static async loadFromFile({
    file: t,
    gl: i,
    name: s = "",
    opacity: r = 1,
    rgba255: a = [255, 255, 255, 255],
    visible: n = !0,
    layers: o = []
  } = {}) {
    if (!t)
      throw new Error("file must be set");
    if (!i)
      throw new Error("rendering context must be set");
    const l = await Gt.readFileAsync(t), c = await Gt.readMesh(l, s, i, r, new Uint8Array(a), n);
    if (!o || o.length < 1)
      return c;
    for (let h = 0; h < o.length; h++)
      await Gt.loadLayer(o[h], c);
    return c.updateMesh(i), c;
  }
  /**
   * load and return a new NVMesh instance from a base64 encoded string
   */
  async loadFromBase64({
    base64: t,
    gl: i,
    name: s = "",
    opacity: r = 1,
    rgba255: a = [255, 255, 255, 255],
    visible: n = !0,
    layers: o = []
  } = {}) {
    if (!t)
      throw new Error("base64 must bet set");
    if (!i)
      throw new Error("rendering context must be set");
    function l(f) {
      const d = window.atob(f), u = d.length, m = new Uint8Array(u);
      for (let g = 0; g < u; g++)
        m[g] = d.charCodeAt(g);
      return m.buffer;
    }
    const c = l(t), h = await Gt.readMesh(c, s, i, r, new Uint8Array(a), n);
    if (!o || o.length < 1)
      return h;
    for (let f = 0; f < o.length; f++)
      await Gt.loadLayer(o[f], h);
    return h.updateMesh(i), h;
  }
}, sc = "data:image/jpeg;base64,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ZwAAAAAAAAALY3JvcFJlY3RUb3Bsb25nAAAAAAA4QklNA+0AAAAAABAASAAAAAEAAQBIAAAAAQABOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAABOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0EAAAAAAAAAgAAOEJJTQQCAAAAAAACAAA4QklNBDAAAAAAAAEBADhCSU0ELQAAAAAABgABAAAAMjhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAAM9AAAABgAAAAAAAAAAAAACAAAAAgAAAAAEAG0AYwA2ADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAIAAAAAAFJnaHRsb25nAAACAAAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xpY2VUeXBlAAAAAEltZyAAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAA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bnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTgtMDctMTJUMjA6MDc6NDcrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL2pwZWciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo0OGNjMGI3YS1iYTJkLWZmNDAtYmNkNC1jNGQzMzIyZjBiNzQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphYzFjM2NhNS1hYTg4LWI5NGMtOGE4MS05YmU4MjA3ZGZiODciPiA8cGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPiA8cmRmOkJhZz4gPHJkZjpsaT5hZG9iZTpkb2NpZDpwaG90b3Nob3A6YThjMGNhZTYtODNjYy1hYzQ4LWI2YzAtN2FiODNlOWJkMGM3PC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YWMxYzNjYTUtYWE4OC1iOTRjLThhODEtOWJlODIwN2RmYjg3IiBzdEV2dDp3aGVuPSIyMDE4LTA3LTEyVDIwOjA3OjQ3KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYmI3MzZlZC0zOTRhLTM2NDgtYThiOC02Mzk1MmY0NDcxMjIiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTY6MTM6NTgrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RFdnQ6d2hlbj0iMjAxOC0wNy0xM1QxNzo1NDoyNyswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvanBlZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9qcGVnIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTc6NTQ6MjcrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjg3NjM1NDk5LWZiMTItYWU0MC04NWEzLThkMWFiN2NkZGVhOSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmFjMWMzY2E1LWFhODgtYjk0Yy04YTgxLTliZTgyMDdkZmI4NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+IMWElDQ19QUk9GSUxFAAEBAAAMSExpbm8CEAAAbW50clJHQiBYWVogB84AAgAJAAYAMQAAYWNzcE1TRlQAAAAASUVDIHNSR0IAAAAAAAAAAAAAAAEAAPbWAAEAAAAA0y1IUCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARY3BydAAAAVAAAAAzZGVzYwAAAYQAAABsd3RwdAAAAfAAAAAUYmtwdAAAAgQAAAAUclhZWgAAAhgAAAAUZ1hZWgAAAiwAAAAUYlhZWgAAAkAAAAAUZG1uZAAAAlQAAABwZG1kZAAAAsQAAACIdnVlZAAAA0wAAACGdmlldwAAA9QAAAAkbHVtaQAAA/gAAAAUbWVhcwAABAwAAAAkdGVjaAAABDAAAAAMclRSQwAABDwAAAgMZ1RSQwAABDwAAAgMYlRSQwAABDwAAAgMdGV4dAAAAABDb3B5cmlnaHQgKGMpIDE5OTggSGV3bGV0dC1Q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", lr = "data:image/png;base64,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", cr = {
  atlas: {
    type: "msdf",
    distanceRange: 2,
    size: 59.65625,
    width: 512,
    height: 256,
    yOrigin: "bottom"
  },
  metrics: {
    emSize: 1,
    lineHeight: 1.171875,
    ascender: 0.927734375,
    descender: -0.244140625,
    underlineY: -0.09765625,
    underlineThickness: 0.048828125
  },
  glyphs: [
    { unicode: 32, advance: 0.24755859375 },
    {
      unicode: 33,
      advance: 0.25732421875,
      planeBounds: {
        left: 0.056159633438645884,
        bottom: -0.02437761405677056,
        right: 0.20702396031135412,
        top: 0.7299440203067705
      },
      atlasBounds: {
        left: 488.5,
        bottom: 145.5,
        right: 497.5,
        top: 190.5
      }
    },
    {
      unicode: 34,
      advance: 0.31982421875,
      planeBounds: {
        left: 0.049409125974004715,
        bottom: 0.48691155587022,
        right: 0.2840869677759953,
        top: 0.77187750662978
      },
      atlasBounds: {
        left: 486.5,
        bottom: 213.5,
        right: 500.5,
        top: 230.5
      }
    },
    {
      unicode: 35,
      advance: 0.61572265625,
      planeBounds: {
        left: 0.037219103997511785,
        bottom: -0.02169206718177056,
        right: 0.6239137085024882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 66.5,
        bottom: 51.5,
        right: 101.5,
        top: 96.5
      }
    },
    {
      unicode: 36,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.02956531458715296,
        bottom: -0.12381369908983761,
        right: 0.5324464041628472,
        top: 0.8484230740898377
      },
      atlasBounds: {
        left: 109.5,
        bottom: 197.5,
        right: 139.5,
        top: 255.5
      }
    },
    {
      unicode: 37,
      advance: 0.732421875,
      planeBounds: {
        left: 0.026481776289942378,
        bottom: -0.030073418674698794,
        right: 0.7137525987100576,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 88.5,
        bottom: 144.5,
        right: 129.5,
        top: 190.5
      }
    },
    {
      unicode: 38,
      advance: 0.62158203125,
      planeBounds: {
        left: 0.03225572125458355,
        bottom: -0.030073418674698794,
        right: 0.6357130287454166,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 130.5,
        bottom: 144.5,
        right: 166.5,
        top: 190.5
      }
    },
    {
      unicode: 39,
      advance: 0.17431640625,
      planeBounds: {
        left: 0.028244602049502358,
        bottom: 0.49895501673814824,
        right: 0.14558352295049765,
        top: 0.7671582645118518
      },
      atlasBounds: {
        left: 498.5,
        bottom: 62.5,
        right: 505.5,
        top: 78.5
      }
    },
    {
      unicode: 40,
      advance: 0.341796875,
      planeBounds: {
        left: 0.042983329377291775,
        bottom: -0.250029542422407,
        right: 0.34471198312270823,
        top: 0.8227834486724072
      },
      atlasBounds: {
        left: 0.5,
        bottom: 191.5,
        right: 18.5,
        top: 255.5
      }
    },
    {
      unicode: 41,
      advance: 0.34765625,
      planeBounds: {
        left: -0.003159248747708225,
        bottom: -0.250029542422407,
        right: 0.29856940499770823,
        top: 0.8227834486724072
      },
      atlasBounds: {
        left: 19.5,
        bottom: 191.5,
        right: 37.5,
        top: 255.5
      }
    },
    {
      unicode: 42,
      advance: 0.4306640625,
      planeBounds: {
        left: -0.011208599684062338,
        bottom: 0.27785390031593765,
        right: 0.44138438093406235,
        top: 0.7304468809340623
      },
      atlasBounds: {
        left: 449.5,
        bottom: 23.5,
        right: 476.5,
        top: 50.5
      }
    },
    {
      unicode: 43,
      advance: 0.56689453125,
      planeBounds: {
        left: 0.01353503347629649,
        bottom: 0.053493525733368255,
        right: 0.5499415290237036,
        top: 0.6066627242666317
      },
      atlasBounds: {
        left: 361.5,
        bottom: 17.5,
        right: 393.5,
        top: 50.5
      }
    },
    {
      unicode: 44,
      advance: 0.1962890625,
      planeBounds: {
        left: -0.009919475797210583,
        bottom: -0.15981695975478,
        right: 0.1744702570472106,
        top: 0.12514899100478
      },
      atlasBounds: {
        left: 498.5,
        bottom: 79.5,
        right: 509.5,
        top: 96.5
      }
    },
    {
      unicode: 45,
      advance: 0.27587890625,
      planeBounds: {
        left: -0.00527594412977999,
        bottom: 0.24333249267450235,
        right: 0.27969000662978,
        top: 0.36067141357549765
      },
      atlasBounds: { left: 52.5, bottom: 7.5, right: 69.5, top: 14.5 }
    },
    {
      unicode: 46,
      advance: 0.26318359375,
      planeBounds: {
        left: 0.051032680313645884,
        bottom: -0.027092319686354116,
        right: 0.20189700718635412,
        top: 0.12377200718635412
      },
      atlasBounds: {
        left: 501.5,
        bottom: 221.5,
        right: 510.5,
        top: 230.5
      }
    },
    {
      unicode: 47,
      advance: 0.412109375,
      planeBounds: {
        left: -0.013733006073205867,
        bottom: -0.08573505127848349,
        right: 0.4053345685732059,
        top: 0.7356373950284835
      },
      atlasBounds: {
        left: 252.5,
        bottom: 206.5,
        right: 277.5,
        top: 255.5
      }
    },
    {
      unicode: 48,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.037458384830081196,
        bottom: -0.030073418674698794,
        right: 0.5235767714199189,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 167.5,
        bottom: 144.5,
        right: 196.5,
        top: 190.5
      }
    },
    {
      unicode: 49,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.06023674350936354,
        bottom: -0.01998308280677056,
        right: 0.37872810024063647,
        top: 0.7343385515567705
      },
      atlasBounds: {
        left: 488.5,
        bottom: 97.5,
        right: 507.5,
        top: 142.5
      }
    },
    {
      unicode: 50,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.025334353719224725,
        bottom: -0.01680925468177056,
        right: 0.5449781462807752,
        top: 0.7375123796817705
      },
      atlasBounds: {
        left: 278.5,
        bottom: 51.5,
        right: 309.5,
        top: 96.5
      }
    },
    {
      unicode: 51,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.028181041080081196,
        bottom: -0.030073418674698794,
        right: 0.5142994276699189,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 197.5,
        bottom: 144.5,
        right: 226.5,
        top: 190.5
      }
    },
    {
      unicode: 52,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.005886103858368255,
        bottom: -0.02169206718177056,
        right: 0.5590553023916317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 310.5,
        bottom: 51.5,
        right: 343.5,
        top: 96.5
      }
    },
    {
      unicode: 53,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.055524791080081196,
        bottom: -0.02657487968177056,
        right: 0.5416431776699189,
        top: 0.7277467546817705
      },
      atlasBounds: {
        left: 344.5,
        bottom: 51.5,
        right: 373.5,
        top: 96.5
      }
    },
    {
      unicode: 54,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.046003306705081196,
        bottom: -0.034712090549698794,
        right: 0.5321216932949189,
        top: 0.7363722467996989
      },
      atlasBounds: {
        left: 227.5,
        bottom: 144.5,
        right: 256.5,
        top: 190.5
      }
    },
    {
      unicode: 55,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.018010134969224725,
        bottom: -0.02169206718177056,
        right: 0.5376539275307752,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 374.5,
        bottom: 51.5,
        right: 405.5,
        top: 96.5
      }
    },
    {
      unicode: 56,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.037702525455081196,
        bottom: -0.030073418674698794,
        right: 0.5238209120449189,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 257.5,
        bottom: 144.5,
        right: 286.5,
        top: 190.5
      }
    },
    {
      unicode: 57,
      advance: 0.5615234375,
      planeBounds: {
        left: 0.029401744205081196,
        bottom: -0.025434746799698794,
        right: 0.5155201307949189,
        top: 0.7456495905496989
      },
      atlasBounds: {
        left: 287.5,
        bottom: 144.5,
        right: 316.5,
        top: 190.5
      }
    },
    {
      unicode: 58,
      advance: 0.2421875,
      planeBounds: {
        left: 0.046394008438645884,
        bottom: -0.029431286627488215,
        right: 0.19725833531135412,
        top: 0.5572633178774882
      },
      atlasBounds: {
        left: 439.5,
        bottom: 61.5,
        right: 448.5,
        top: 96.5
      }
    },
    {
      unicode: 59,
      advance: 0.21142578125,
      planeBounds: {
        left: 0.001066852327789419,
        bottom: -0.16459733294591408,
        right: 0.1854565851722106,
        top: 0.556198895445914
      },
      atlasBounds: {
        left: 406.5,
        bottom: 53.5,
        right: 417.5,
        top: 96.5
      }
    },
    {
      unicode: 60,
      advance: 0.50830078125,
      planeBounds: {
        left: 0.016948142433865897,
        bottom: 0.0726146348300812,
        right: 0.4527784200661341,
        top: 0.5587330214199189
      },
      atlasBounds: {
        left: 394.5,
        bottom: 21.5,
        right: 420.5,
        top: 50.5
      }
    },
    {
      unicode: 61,
      advance: 0.548828125,
      planeBounds: {
        left: 0.051535540940937666,
        bottom: 0.17620354038436353,
        right: 0.5041285215590624,
        top: 0.49469489711563647
      },
      atlasBounds: {
        left: 477.5,
        bottom: 31.5,
        right: 504.5,
        top: 50.5
      }
    },
    {
      unicode: 62,
      advance: 0.5224609375,
      planeBounds: {
        left: 0.047629290940937666,
        bottom: 0.0731029160800812,
        right: 0.5002222715590624,
        top: 0.5592213026699189
      },
      atlasBounds: {
        left: 421.5,
        bottom: 21.5,
        right: 448.5,
        top: 50.5
      }
    },
    {
      unicode: 63,
      advance: 0.47216796875,
      planeBounds: {
        left: 0.016704001808865897,
        bottom: -0.027876153049698794,
        right: 0.4525342794411341,
        top: 0.7432081842996989
      },
      atlasBounds: {
        left: 317.5,
        bottom: 144.5,
        right: 343.5,
        top: 190.5
      }
    },
    {
      unicode: 64,
      advance: 0.89794921875,
      planeBounds: {
        left: 0.034064457306783605,
        bottom: -0.23896750384690937,
        right: 0.8721996065996072,
        top: 0.7165065663469093
      },
      atlasBounds: {
        left: 155.5,
        bottom: 198.5,
        right: 205.5,
        top: 255.5
      }
    },
    {
      unicode: 65,
      advance: 0.65234375,
      planeBounds: {
        left: -0.008838044092129387,
        bottom: -0.02169206718177056,
        right: 0.6616700753421295,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 237.5,
        bottom: 51.5,
        right: 277.5,
        top: 96.5
      }
    },
    {
      unicode: 66,
      advance: 0.62255859375,
      planeBounds: {
        left: 0.06464099434422473,
        bottom: -0.02169206718177056,
        right: 0.5842847869057752,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 205.5,
        bottom: 51.5,
        right: 236.5,
        top: 96.5
      }
    },
    {
      unicode: 67,
      advance: 0.65087890625,
      planeBounds: {
        left: 0.038439807122511785,
        bottom: -0.030073418674698794,
        right: 0.6251344116274882,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 344.5,
        bottom: 144.5,
        right: 379.5,
        top: 190.5
      }
    },
    {
      unicode: 68,
      advance: 0.65576171875,
      planeBounds: {
        left: 0.06301501010836826,
        bottom: -0.02169206718177056,
        right: 0.6161842086416317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 162.5,
        bottom: 51.5,
        right: 195.5,
        top: 96.5
      }
    },
    {
      unicode: 69,
      advance: 0.568359375,
      planeBounds: {
        left: 0.0652904160800812,
        bottom: -0.02169206718177056,
        right: 0.5514088026699189,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 132.5,
        bottom: 51.5,
        right: 161.5,
        top: 96.5
      }
    },
    {
      unicode: 70,
      advance: 0.552734375,
      planeBounds: {
        left: 0.059675181705081196,
        bottom: -0.02169206718177056,
        right: 0.5457935682949189,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 102.5,
        bottom: 51.5,
        right: 131.5,
        top: 96.5
      }
    },
    {
      unicode: 71,
      advance: 0.68115234375,
      planeBounds: {
        left: 0.040148791497511785,
        bottom: -0.030073418674698794,
        right: 0.6268433960024882,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 380.5,
        bottom: 144.5,
        right: 415.5,
        top: 190.5
      }
    },
    {
      unicode: 72,
      advance: 0.712890625,
      planeBounds: {
        left: 0.062365588372511785,
        bottom: -0.02169206718177056,
        right: 0.6490601928774882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 30.5,
        bottom: 51.5,
        right: 65.5,
        top: 96.5
      }
    },
    {
      unicode: 73,
      advance: 0.27197265625,
      planeBounds: {
        left: 0.06917965680657412,
        bottom: -0.02169206718177056,
        right: 0.20328128069342588,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 196.5,
        bottom: 51.5,
        right: 204.5,
        top: 96.5
      }
    },
    {
      unicode: 74,
      advance: 0.5517578125,
      planeBounds: {
        left: 0.007184947330081194,
        bottom: -0.02657487968177056,
        right: 0.4933033339199188,
        top: 0.7277467546817705
      },
      atlasBounds: { left: 0.5, bottom: 51.5, right: 29.5, top: 96.5 }
    },
    {
      unicode: 75,
      advance: 0.626953125,
      planeBounds: {
        left: 0.061633166497511785,
        bottom: -0.02169206718177056,
        right: 0.6483277710024882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 452.5,
        bottom: 97.5,
        right: 487.5,
        top: 142.5
      }
    },
    {
      unicode: 76,
      advance: 0.5380859375,
      planeBounds: {
        left: 0.06341786132300943,
        bottom: -0.02169206718177056,
        right: 0.5327735449269906,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 423.5,
        bottom: 97.5,
        right: 451.5,
        top: 142.5
      }
    },
    {
      unicode: 77,
      advance: 0.873046875,
      planeBounds: {
        left: 0.05911847969322944,
        bottom: -0.02169206718177056,
        right: 0.8134401140567705,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 377.5,
        bottom: 97.5,
        right: 422.5,
        top: 142.5
      }
    },
    {
      unicode: 78,
      advance: 0.712890625,
      planeBounds: {
        left: 0.062365588372511785,
        bottom: -0.02169206718177056,
        right: 0.6490601928774882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 341.5,
        bottom: 97.5,
        right: 376.5,
        top: 142.5
      }
    },
    {
      unicode: 79,
      advance: 0.6875,
      planeBounds: {
        left: 0.033395854136655315,
        bottom: -0.030073418674698794,
        right: 0.6536158646133446,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 416.5,
        bottom: 144.5,
        right: 453.5,
        top: 190.5
      }
    },
    {
      unicode: 80,
      advance: 0.630859375,
      planeBounds: {
        left: 0.061550166358368255,
        bottom: -0.02169206718177056,
        right: 0.6147193648916317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 273.5,
        bottom: 97.5,
        right: 306.5,
        top: 142.5
      }
    },
    {
      unicode: 81,
      advance: 0.6875,
      planeBounds: {
        left: 0.030466166636655315,
        bottom: -0.14391866037519643,
        right: 0.6506861771133446,
        top: 0.7445045978751964
      },
      atlasBounds: {
        left: 214.5,
        bottom: 202.5,
        right: 251.5,
        top: 255.5
      }
    },
    {
      unicode: 82,
      advance: 0.61572265625,
      planeBounds: {
        left: 0.06350329135836826,
        bottom: -0.02169206718177056,
        right: 0.6166724898916317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 186.5,
        bottom: 97.5,
        right: 219.5,
        top: 142.5
      }
    },
    {
      unicode: 83,
      advance: 0.59326171875,
      planeBounds: {
        left: 0.020778681983368255,
        bottom: -0.030073418674698794,
        right: 0.5739478805166317,
        top: 0.7410109186746989
      },
      atlasBounds: {
        left: 454.5,
        bottom: 144.5,
        right: 487.5,
        top: 190.5
      }
    },
    {
      unicode: 84,
      advance: 0.5966796875,
      planeBounds: {
        left: 0.005480822747511787,
        bottom: -0.02169206718177056,
        right: 0.5921754272524882,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 112.5,
        bottom: 97.5,
        right: 147.5,
        top: 142.5
      }
    },
    {
      unicode: 85,
      advance: 0.6484375,
      planeBounds: {
        left: 0.049098994483368255,
        bottom: -0.02657487968177056,
        right: 0.6022681930166317,
        top: 0.7277467546817705
      },
      atlasBounds: {
        left: 78.5,
        bottom: 97.5,
        right: 111.5,
        top: 142.5
      }
    },
    {
      unicode: 86,
      advance: 0.63623046875,
      planeBounds: {
        left: -0.008269192599201152,
        bottom: -0.02169206718177056,
        right: 0.6454762238492011,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 38.5,
        bottom: 97.5,
        right: 77.5,
        top: 142.5
      }
    },
    {
      unicode: 87,
      advance: 0.88720703125,
      planeBounds: {
        left: 0.011923628617731797,
        bottom: -0.02169206718177056,
        right: 0.8835841838822683,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 220.5,
        bottom: 97.5,
        right: 272.5,
        top: 142.5
      }
    },
    {
      unicode: 88,
      advance: 0.626953125,
      planeBounds: {
        left: 0.004098979136655316,
        bottom: -0.02169206718177056,
        right: 0.6243189896133446,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 0.5,
        bottom: 97.5,
        right: 37.5,
        top: 142.5
      }
    },
    {
      unicode: 89,
      advance: 0.6005859375,
      planeBounds: {
        left: -0.010793598988344685,
        bottom: -0.02169206718177056,
        right: 0.6094264114883446,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 148.5,
        bottom: 97.5,
        right: 185.5,
        top: 142.5
      }
    },
    {
      unicode: 90,
      advance: 0.5986328125,
      planeBounds: {
        left: 0.024196650733368255,
        bottom: -0.02169206718177056,
        right: 0.5773658492666317,
        top: 0.7326295671817705
      },
      atlasBounds: {
        left: 307.5,
        bottom: 97.5,
        right: 340.5,
        top: 142.5
      }
    },
    {
      unicode: 91,
      advance: 0.26513671875,
      planeBounds: {
        left: 0.05437250871693295,
        bottom: -0.17280296457569408,
        right: 0.27228764753306706,
        top: 0.8329592145756942
      },
      atlasBounds: {
        left: 59.5,
        bottom: 195.5,
        right: 72.5,
        top: 255.5
      }
    },
    {
      unicode: 92,
      advance: 0.41015625,
      planeBounds: {
        left: 0.0014037126767941326,
        bottom: -0.08573505127848349,
        right: 0.4204712873232059,
        top: 0.7356373950284835
      },
      atlasBounds: {
        left: 278.5,
        bottom: 206.5,
        right: 303.5,
        top: 255.5
      }
    },
    {
      unicode: 93,
      advance: 0.26513671875,
      planeBounds: {
        left: -0.020659233400995285,
        bottom: -0.17280296457569408,
        right: 0.2140186084009953,
        top: 0.8329592145756942
      },
      atlasBounds: {
        left: 94.5,
        bottom: 195.5,
        right: 108.5,
        top: 255.5
      }
    },
    {
      unicode: 94,
      advance: 0.41796875,
      planeBounds: {
        left: 0.006855376669722368,
        bottom: 0.33229482979472236,
        right: 0.40916024833027764,
        top: 0.7345997014552776
      },
      atlasBounds: {
        left: 486.5,
        bottom: 231.5,
        right: 510.5,
        top: 255.5
      }
    },
    {
      unicode: 95,
      advance: 0.451171875,
      planeBounds: {
        left: -0.017473255794918804,
        bottom: -0.09553469482549765,
        right: 0.4686451307949188,
        top: 0.021804226075497646
      },
      atlasBounds: { left: 70.5, bottom: 7.5, right: 99.5, top: 14.5 }
    },
    {
      unicode: 96,
      advance: 0.30908203125,
      planeBounds: {
        left: 0.00391839948107648,
        bottom: 0.5860277898277895,
        right: 0.2553589442689235,
        top: 0.7704175226722105
      },
      atlasBounds: { left: 36.5, bottom: 3.5, right: 51.5, top: 14.5 }
    },
    {
      unicode: 97,
      advance: 0.5439453125,
      planeBounds: {
        left: 0.028181041080081196,
        bottom: -0.029187146002488215,
        right: 0.5142994276699189,
        top: 0.5575074585024882
      },
      atlasBounds: {
        left: 30.5,
        bottom: 15.5,
        right: 59.5,
        top: 50.5
      }
    },
    {
      unicode: 98,
      advance: 0.56103515625,
      planeBounds: {
        left: 0.048932994205081196,
        bottom: -0.032187684160555265,
        right: 0.5350513807949189,
        top: 0.7724220591605554
      },
      atlasBounds: {
        left: 304.5,
        bottom: 207.5,
        right: 333.5,
        top: 255.5
      }
    },
    {
      unicode: 99,
      advance: 0.5234375,
      planeBounds: {
        left: 0.024518931705081196,
        bottom: -0.029187146002488215,
        right: 0.5106373182949189,
        top: 0.5575074585024882
      },
      atlasBounds: { left: 0.5, bottom: 15.5, right: 29.5, top: 50.5 }
    },
    {
      unicode: 100,
      advance: 0.56396484375,
      planeBounds: {
        left: 0.026227916080081196,
        bottom: -0.032187684160555265,
        right: 0.5123463026699189,
        top: 0.7724220591605554
      },
      atlasBounds: {
        left: 334.5,
        bottom: 207.5,
        right: 363.5,
        top: 255.5
      }
    },
    {
      unicode: 101,
      advance: 0.52978515625,
      planeBounds: {
        left: 0.026472056705081196,
        bottom: -0.029187146002488215,
        right: 0.5125904432949189,
        top: 0.5575074585024882
      },
      atlasBounds: {
        left: 468.5,
        bottom: 61.5,
        right: 497.5,
        top: 96.5
      }
    },
    {
      unicode: 102,
      advance: 0.34716796875,
      planeBounds: {
        left: 0.004575110905578838,
        bottom: -0.022177918535555265,
        right: 0.3733545765944212,
        top: 0.7824318247855554
      },
      atlasBounds: {
        left: 364.5,
        bottom: 207.5,
        right: 386.5,
        top: 255.5
      }
    },
    {
      unicode: 103,
      advance: 0.56103515625,
      planeBounds: {
        left: 0.026960337955081196,
        bottom: -0.22888445766762702,
        right: 0.5130787245449189,
        top: 0.558962582667627
      },
      atlasBounds: {
        left: 28.5,
        bottom: 143.5,
        right: 57.5,
        top: 190.5
      }
    },
    {
      unicode: 104,
      advance: 0.55078125,
      planeBounds: {
        left: 0.049826556565937666,
        bottom: -0.01892352016762703,
        right: 0.5024195371840624,
        top: 0.768923520167627
      },
      atlasBounds: {
        left: 0.5,
        bottom: 143.5,
        right: 27.5,
        top: 190.5
      }
    },
    {
      unicode: 105,
      advance: 0.24267578125,
      planeBounds: {
        left: 0.046882289688645884,
        bottom: -0.01680925468177056,
        right: 0.19774661656135412,
        top: 0.7375123796817705
      },
      atlasBounds: {
        left: 498.5,
        bottom: 145.5,
        right: 507.5,
        top: 190.5
      }
    },
    {
      unicode: 106,
      advance: 0.23876953125,
      planeBounds: {
        left: -0.048979545900995285,
        bottom: -0.2324562772148376,
        right: 0.1856982959009953,
        top: 0.7397804959648377
      },
      atlasBounds: {
        left: 140.5,
        bottom: 197.5,
        right: 154.5,
        top: 255.5
      }
    },
    {
      unicode: 107,
      advance: 0.5068359375,
      planeBounds: {
        left: 0.044294322330081196,
        bottom: -0.01892352016762703,
        right: 0.5304127089199189,
        top: 0.768923520167627
      },
      atlasBounds: {
        left: 58.5,
        bottom: 143.5,
        right: 87.5,
        top: 190.5
      }
    },
    {
      unicode: 108,
      advance: 0.24267578125,
      planeBounds: {
        left: 0.05428707868157412,
        bottom: -0.01892352016762703,
        right: 0.18838870256842588,
        top: 0.768923520167627
      },
      atlasBounds: {
        left: 477.5,
        bottom: 208.5,
        right: 485.5,
        top: 255.5
      }
    },
    {
      unicode: 109,
      advance: 0.87646484375,
      planeBounds: {
        left: 0.04430890170737297,
        bottom: -0.024304333502488215,
        right: 0.832155942042627,
        top: 0.5623902710024882
      },
      atlasBounds: {
        left: 116.5,
        bottom: 15.5,
        right: 163.5,
        top: 50.5
      }
    },
    {
      unicode: 110,
      advance: 0.5517578125,
      planeBounds: {
        left: 0.049826556565937666,
        bottom: -0.024304333502488215,
        right: 0.5024195371840624,
        top: 0.5623902710024882
      },
      atlasBounds: {
        left: 60.5,
        bottom: 15.5,
        right: 87.5,
        top: 50.5
      }
    },
    {
      unicode: 111,
      advance: 0.5703125,
      planeBounds: {
        left: 0.025090213094224725,
        bottom: -0.029187146002488215,
        right: 0.5447340056557752,
        top: 0.5575074585024882
      },
      atlasBounds: {
        left: 193.5,
        bottom: 15.5,
        right: 224.5,
        top: 50.5
      }
    },
    {
      unicode: 112,
      advance: 0.56103515625,
      planeBounds: {
        left: 0.048444712955081196,
        bottom: -0.22644305141762702,
        right: 0.5345630995449189,
        top: 0.561403988917627
      },
      atlasBounds: {
        left: 447.5,
        bottom: 208.5,
        right: 476.5,
        top: 255.5
      }
    },
    {
      unicode: 113,
      advance: 0.568359375,
      planeBounds: {
        left: 0.025983775455081196,
        bottom: -0.22644305141762702,
        right: 0.5121021620449189,
        top: 0.561403988917627
      },
      atlasBounds: {
        left: 417.5,
        bottom: 208.5,
        right: 446.5,
        top: 255.5
      }
    },
    {
      unicode: 114,
      advance: 0.33837890625,
      planeBounds: {
        left: 0.045180595002291775,
        bottom: -0.024304333502488215,
        right: 0.34690924874770823,
        top: 0.5623902710024882
      },
      atlasBounds: {
        left: 449.5,
        bottom: 61.5,
        right: 467.5,
        top: 96.5
      }
    },
    {
      unicode: 115,
      advance: 0.515625,
      planeBounds: {
        left: 0.021669814448009427,
        bottom: -0.029187146002488215,
        right: 0.4910254980519906,
        top: 0.5575074585024882
      },
      atlasBounds: {
        left: 164.5,
        bottom: 15.5,
        right: 192.5,
        top: 50.5
      }
    },
    {
      unicode: 116,
      advance: 0.32666015625,
      planeBounds: {
        left: -0.019433670483564695,
        bottom: -0.02877457520298586,
        right: 0.3158203892335647,
        top: 0.675258950202986
      },
      atlasBounds: {
        left: 418.5,
        bottom: 54.5,
        right: 438.5,
        top: 96.5
      }
    },
    {
      unicode: 117,
      advance: 0.55126953125,
      planeBounds: {
        left: 0.048117572190937666,
        bottom: -0.034069958502488215,
        right: 0.5007105528090624,
        top: 0.5526246460024882
      },
      atlasBounds: {
        left: 88.5,
        bottom: 15.5,
        right: 115.5,
        top: 50.5
      }
    },
    {
      unicode: 118,
      advance: 0.484375,
      planeBounds: {
        left: -0.002092396419918806,
        bottom: -0.02080579450955998,
        right: 0.4840259901699188,
        top: 0.5491261070095601
      },
      atlasBounds: {
        left: 331.5,
        bottom: 16.5,
        right: 360.5,
        top: 50.5
      }
    },
    {
      unicode: 119,
      advance: 0.75146484375,
      planeBounds: {
        left: -0.002649098431770561,
        bottom: -0.02080579450955998,
        right: 0.7516725359317705,
        top: 0.5491261070095601
      },
      atlasBounds: {
        left: 225.5,
        bottom: 16.5,
        right: 270.5,
        top: 50.5
      }
    },
    {
      unicode: 120,
      advance: 0.49560546875,
      planeBounds: {
        left: -0.0046143729128470395,
        bottom: -0.02080579450955998,
        right: 0.4982667166628471,
        top: 0.5491261070095601
      },
      atlasBounds: {
        left: 300.5,
        bottom: 16.5,
        right: 330.5,
        top: 50.5
      }
    },
    {
      unicode: 121,
      advance: 0.47314453125,
      planeBounds: {
        left: -0.007219349544918806,
        bottom: -0.23645281704262702,
        right: 0.4788990370449188,
        top: 0.551394223292627
      },
      atlasBounds: {
        left: 387.5,
        bottom: 208.5,
        right: 416.5,
        top: 255.5
      }
    },
    {
      unicode: 122,
      advance: 0.49560546875,
      planeBounds: {
        left: 0.018007705073009427,
        bottom: -0.02080579450955998,
        right: 0.4873633886769906,
        top: 0.5491261070095601
      },
      atlasBounds: {
        left: 271.5,
        bottom: 16.5,
        right: 299.5,
        top: 50.5
      }
    },
    {
      unicode: 123,
      advance: 0.33837890625,
      planeBounds: {
        left: 0.011572188891435306,
        bottom: -0.20234398020069408,
        right: 0.3468262486085647,
        top: 0.8034181989506942
      },
      atlasBounds: {
        left: 73.5,
        bottom: 195.5,
        right: 93.5,
        top: 255.5
      }
    },
    {
      unicode: 124,
      advance: 0.24365234375,
      planeBounds: {
        left: 0.06315671142450235,
        bottom: -0.15466084787519643,
        right: 0.18049563232549765,
        top: 0.7337624103751964
      },
      atlasBounds: {
        left: 206.5,
        bottom: 202.5,
        right: 213.5,
        top: 255.5
      }
    },
    {
      unicode: 125,
      advance: 0.33837890625,
      planeBounds: {
        left: -0.010156326733564695,
        bottom: -0.20234398020069408,
        right: 0.3250977329835647,
        top: 0.8034181989506942
      },
      atlasBounds: {
        left: 38.5,
        bottom: 195.5,
        right: 58.5,
        top: 255.5
      }
    },
    {
      unicode: 126,
      advance: 0.68017578125,
      planeBounds: {
        left: 0.046984728997511785,
        bottom: 0.1766063915990047,
        right: 0.6336793335024882,
        top: 0.4112842334009953
      },
      atlasBounds: { left: 0.5, bottom: 0.5, right: 35.5, top: 14.5 }
    }
  ],
  kerning: []
}, ai = {
  name: "untitled connectome",
  nodeColormap: "warm",
  nodeColormapNegative: "winter",
  nodeMinColor: 0,
  nodeMaxColor: 4,
  nodeScale: 3,
  edgeColormap: "warm",
  edgeColormapNegative: "winter",
  edgeMin: 2,
  edgeMax: 6,
  edgeScale: 1,
  legendLineThickness: 0,
  showLegend: !0
}, oi = class gn extends Ae {
  constructor(t, i) {
    super(new Float32Array([]), new Uint32Array([]), i.name, new Uint8Array([]), 1, !0, t, i), I(this, "gl"), I(this, "nodesChanged"), this.gl = t, this.type = "connectome", this.nodes && this.updateLabels(), this.nodesChanged = new EventTarget();
  }
  static convertLegacyConnectome(t) {
    const i = { nodes: [], edges: [], ...ai };
    for (const r in t)
      if (r in ai) {
        const a = r;
        i[a] = t[a];
      }
    const s = t.nodes;
    for (let r = 0; r < s.names.length; r++)
      i.nodes.push({
        name: s.names[r],
        x: s.X[r],
        y: s.Y[r],
        z: s.Z[r],
        colorValue: s.Color[r],
        sizeValue: s.Size[r]
      });
    for (let r = 0; r < s.names.length - 1; r++)
      for (let a = r + 1; a < s.names.length; a++) {
        const n = t.edges[r * s.names.length + a];
        i.edges.push({
          first: r,
          second: a,
          colorValue: n
        });
      }
    return i;
  }
  static convertFreeSurferConnectome(t, i = "warm") {
    let s = !0;
    if ("data_type" in t ? t.data_type !== "fs_pointset" && (s = !1) : s = !1, "points" in t || (s = !1), !s)
      throw Error("not a valid FreeSurfer json pointset");
    const r = t.points.map((n) => ({
      name: Array.isArray(n.comments) && n.comments.length > 0 && "text" in n.comments[0] ? n.comments[0].text : "",
      x: n.coordinates.x,
      y: n.coordinates.y,
      z: n.coordinates.z,
      colorValue: 1,
      sizeValue: 1,
      metadata: n.comments
    }));
    return {
      ...ai,
      nodeColormap: i,
      edgeColormap: i,
      nodes: r,
      edges: []
    };
  }
  updateLabels() {
    const t = this.nodes;
    if (t && t.length > 0) {
      const i = t.reduce((c, h) => c.sizeValue > h.sizeValue ? c : h).sizeValue;
      let s, r;
      if (typeof this.nodeMinColor < "u" && isFinite(this.nodeMinColor))
        s = this.nodeMinColor;
      else {
        s = t[0].colorValue;
        for (let c = 1; c < t.length; c++)
          t[c].colorValue < s && (s = t[c].colorValue);
      }
      if (typeof this.nodeMaxColor < "u" && isFinite(this.nodeMaxColor))
        r = this.nodeMaxColor;
      else {
        r = t[0].colorValue;
        for (let c = 1; c < t.length; c++)
          t[c].colorValue > r && (r = t[c].colorValue);
      }
      const a = rt.colormap(this.nodeColormap, this.colormapInvert), n = rt.colormap(this.nodeColormapNegative, this.colormapInvert), o = "nodeColormapNegative" in this;
      let l = this.legendLineThickness ? this.legendLineThickness : 0;
      this.showLegend === !1 && (l = 0);
      for (let c = 0; c < t.length; c++) {
        let h = t[c].colorValue, f = !1;
        if (o && h < 0 && (f = !0, h = -h), s < r) {
          if (h < s) {
            V.warn("color value lower than min");
            continue;
          }
          h = (h - s) / (r - s);
        } else
          h = 1;
        h = Math.round(Math.max(Math.min(255, h * 255))) * 4;
        let d = [a[h], a[h + 1], a[h + 2], 255];
        f && (d = [n[h], n[h + 1], n[h + 2], 255]), d = d.map((u) => u / 255), V.debug("adding label for ", t[c]), t[c].label = new Es(
          t[c].name,
          {
            textColor: d,
            bulletScale: t[c].sizeValue / i,
            bulletColor: d,
            lineWidth: l,
            lineColor: d,
            textScale: 1,
            textAlignment: "left",
            lineTerminator: "none"
            /* NONE */
          },
          [t[c].x, t[c].y, t[c].z]
        ), V.debug("label for node:", t[c].label);
      }
    }
  }
  addConnectomeNode(t) {
    if (V.debug("adding node", t), !this.nodes)
      throw new Error("nodes not defined");
    this.nodes.push(t), this.updateLabels(), this.nodesChanged.dispatchEvent(new CustomEvent("nodeAdded", { detail: { node: t } }));
  }
  deleteConnectomeNode(t) {
    const i = this.nodes.indexOf(t), s = this.edges;
    s && (this.edges = s.filter((r) => r.first !== i && r.second !== i)), this.nodes = this.nodes.filter((r) => r !== t), this.updateLabels(), this.updateConnectome(this.gl), this.nodesChanged.dispatchEvent(new CustomEvent("nodeDeleted", { detail: { node: t } }));
  }
  updateConnectomeNodeByIndex(t, i) {
    this.nodes[t] = i, this.updateLabels(), this.updateConnectome(this.gl), this.nodesChanged.dispatchEvent(new CustomEvent("nodeChanged", { detail: { node: i } }));
  }
  updateConnectomeNodeByPoint(t, i) {
    const s = this.nodes;
    if (!s)
      throw new Error("Node to update does not exist");
    const r = s.find((n) => H.arraysAreEqual([n.x, n.y, n.z], t));
    if (!r)
      throw new Error(`Node with point ${t} to update does not exist`);
    const a = s.findIndex((n) => n === r);
    this.updateConnectomeNodeByIndex(a, i);
  }
  addConnectomeEdge(t, i, s) {
    const r = this.edges;
    let a = r.find((n) => (n.first === t || n.second === t) && n.first + n.second === t + i);
    return a || (a = { first: t, second: i, colorValue: s }, r.push(a), this.updateConnectome(this.gl), a);
  }
  deleteConnectomeEdge(t, i) {
    const s = this.edges, r = s.find((a) => (a.first === t || a.first === i) && a.first + a.second === t + i);
    if (r)
      this.edges = s.filter((a) => a !== r);
    else
      throw new Error(`edge between ${t} and ${i} not found`);
    return this.updateConnectome(this.gl), r;
  }
  findClosestConnectomeNode(t, i) {
    const s = this.nodes;
    if (!s || s.length === 0)
      return null;
    const r = s.map((a, n) => ({
      node: a,
      distance: Math.sqrt(Math.pow(a.x - t[0], 2) + Math.pow(a.y - t[1], 2) + Math.pow(a.z - t[2], 2)),
      index: n
    })).filter((a) => a.distance < i).sort((a, n) => a.distance - n.distance);
    return r.length > 0 ? r[0].node : null;
  }
  updateConnectome(t) {
    const i = [], s = [], r = [];
    let a = rt.colormap(this.nodeColormap, this.colormapInvert), n = rt.colormap(this.nodeColormapNegative, this.colormapInvert), o = "nodeColormapNegative" in this;
    this.nodeMinColor === void 0 && (this.nodeMinColor = NaN), this.nodeMaxColor === void 0 && (this.nodeMaxColor = NaN), this.edgeMin === void 0 && (this.edgeMin = NaN), this.edgeMax === void 0 && (this.edgeMax = NaN);
    let l = this.nodeMinColor, c = this.nodeMaxColor;
    if (!isFinite(l) || !isFinite(l)) {
      const A = this.nodes;
      l = A[0].colorValue, c = A[0].colorValue;
      for (let x = 0; x < A.length; x++)
        l = Math.min(l, A[x].colorValue), c = Math.max(c, A[x].colorValue);
    }
    const h = this.nodes, f = h.length;
    for (let A = 0; A < f; A++) {
      const x = h[A].sizeValue * this.nodeScale;
      if (x <= 0)
        continue;
      let w = h[A].colorValue, v = !1;
      if (o && w < 0 && (v = !0, w = -w), l < c) {
        if (w < l)
          continue;
        w = (w - l) / (c - l);
      } else
        w = 1;
      w = Math.round(Math.max(Math.min(255, w * 255))) * 4;
      let F = [a[w], a[w + 1], a[w + 2], 255];
      v && (F = [n[w], n[w + 1], n[w + 2], 255]);
      const C = O(h[A].x, h[A].y, h[A].z);
      he.makeColoredSphere(s, i, r, x, C, F);
    }
    a = rt.colormap(this.edgeColormap, this.colormapInvert), n = rt.colormap(this.edgeColormapNegative, this.colormapInvert), o = "edgeColormapNegative" in this;
    const d = this.edges;
    if (d !== void 0 && d.length > 0) {
      if (l = this.edgeMin, c = this.edgeMax, !isFinite(l) || !isFinite(l)) {
        l = d[0].colorValue, c = d[0].colorValue;
        for (let A = 0; A < d.length; A++)
          l = Math.min(l, d[A].colorValue), c = Math.max(c, d[A].colorValue);
      }
      for (const A of d) {
        let x = A.colorValue;
        const w = o && x < 0;
        w && (x = -x);
        const v = x * this.edgeScale;
        if (v <= 0)
          continue;
        if (l < c) {
          if (x < l)
            continue;
          x = (x - l) / (c - l);
        } else
          x = 1;
        x = Math.round(Math.max(Math.min(255, x * 255))) * 4;
        let F = [a[x], a[x + 1], a[x + 2], 255];
        w && (F = [n[x], n[x + 1], n[x + 2], 255]);
        const C = O(h[A.first].x, h[A.first].y, h[A.first].z), b = O(h[A.second].x, h[A.second].y, h[A.second].z);
        he.makeColoredCylinder(s, i, r, C, b, v, F);
      }
    }
    const u = new Float32Array(s), m = new Uint32Array(i), g = ne.getExtents(u);
    this.furthestVertexFromOrigin = g.mxDx, this.extentsMin = g.extentsMin, this.extentsMax = g.extentsMax;
    const p = this.generatePosNormClr(u, m, new Uint8Array(r));
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, Uint32Array.from(m), t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, Float32Array.from(p), t.STATIC_DRAW), this.indexCount = i.length;
  }
  updateMesh(t) {
    this.updateConnectome(t), this.updateLabels();
  }
  json() {
    const t = {};
    for (const i in this)
      (i in ai || i === "nodes" || i === "edges") && (t[i] = this[i]);
    return t;
  }
  /**
   * Factory method to create connectome from options
   */
  static async loadConnectomeFromUrl(t, i) {
    const r = await (await fetch(i)).json();
    return new gn(t, r);
  }
};
function rc(e, t, i) {
  if (!e.dimsRAS || !e.matRAS || !e.pixDimsRAS || !e.vox2mm)
    throw new Error("Cannot create NiivueObject3D: Missing required RAS properties or vox2mm access on NVImage.");
  const s = e.dimsRAS, r = e.matRAS, a = e.pixDimsRAS, n = -0.5, o = -0.5, l = -0.5, c = s[1] - 1 + 0.5, h = s[2] - 1 + 0.5, f = s[3] - 1 + 0.5, d = e.vox2mm, u = d.call(e, [n, o, l], r), m = d.call(e, [n, h, l], r), g = d.call(e, [n, o, f], r), p = d.call(e, [n, h, f], r), A = d.call(e, [c, o, l], r), x = d.call(e, [c, h, l], r), w = d.call(e, [c, o, f], r), v = d.call(e, [c, h, f], r), F = [
    // Superior face vertices (Indices 0-3)
    ...g,
    0,
    0,
    1,
    // 0
    ...w,
    1,
    0,
    1,
    // 1
    ...v,
    1,
    1,
    1,
    // 2
    ...p,
    0,
    1,
    1,
    // 3
    // Inferior face vertices (Indices 4-7)
    ...u,
    0,
    0,
    0,
    // 4
    ...m,
    0,
    1,
    0,
    // 5
    ...x,
    1,
    1,
    0,
    // 6
    ...A,
    1,
    0,
    0
    // 7
  ], C = i.createBuffer();
  if (!C)
    throw new Error("Failed to create GL index buffer");
  i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, C);
  const b = [
    0,
    3,
    2,
    2,
    1,
    0,
    // Top
    4,
    7,
    6,
    6,
    5,
    4,
    // Bottom
    5,
    6,
    2,
    2,
    3,
    5,
    // Front -> Corresponds to LAI(5), RAI(6), RAS(2) / RAS(2), LAS(3), LAI(5)
    4,
    0,
    1,
    1,
    7,
    4,
    // Back -> Corresponds to LPI(4), LPS(0), RPS(1) / RPS(1), RPI(7), LPI(4)
    7,
    1,
    2,
    2,
    6,
    7,
    // Right -> Corresponds to RPI(7), RPS(1), RAS(2) / RAS(2), RAI(6), RPI(7)
    4,
    5,
    3,
    3,
    0,
    4
    // Left -> Corresponds to LPI(4), LAI(5), LAS(3) / LAS(3), LPS(0), LPI(4)
  ];
  i.bufferData(i.ELEMENT_ARRAY_BUFFER, new Uint16Array(b), i.STATIC_DRAW);
  const y = i.createBuffer();
  if (!y)
    throw new Error("Failed to create GL vertex buffer");
  i.bindBuffer(i.ARRAY_BUFFER, y), i.bufferData(i.ARRAY_BUFFER, new Float32Array(F), i.STATIC_DRAW);
  const E = i.createVertexArray();
  if (!E)
    throw new Error("Failed to create GL VAO");
  i.bindVertexArray(E), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, C), i.bindBuffer(i.ARRAY_BUFFER, y);
  const S = 24;
  i.enableVertexAttribArray(0), i.vertexAttribPointer(0, 3, i.FLOAT, !1, S, 0), i.enableVertexAttribArray(1), i.vertexAttribPointer(1, 3, i.FLOAT, !1, S, 12), i.bindVertexArray(null);
  const D = new he(t, y, i.TRIANGLES, b.length, C, E), M = [...g, ...w, ...v, ...p, ...u, ...m, ...x, ...A], B = ql(M);
  return D.extentsMin = B.min.slice(), D.extentsMax = B.max.slice(), D.furthestVertexFromOrigin = B.furthestVertexFromOrigin, D.originNegate = Ot(B.origin), Wn(D.originNegate, D.originNegate), D.fieldOfViewDeObliqueMM = [s[1] * a[1], s[2] * a[2], s[3] * a[3]], D;
}
function nc(e) {
  const t = e.length;
  let i = 0;
  const s = new Uint8Array(t + Math.ceil(0.01 * t)), r = new Int8Array(s.buffer);
  let a = 0;
  for (; i < t; ) {
    let n = e[i];
    i++;
    let o = 1;
    for (; o < 129 && i < t && e[i] === n; )
      i++, o++;
    if (o > 1) {
      r[a] = -o + 1, a++, s[a] = n, a++;
      continue;
    }
    for (; i < t && !(o > 127 || i + 2 < t && n !== e[i] && e[i + 2] === e[i] && e[i + 1] === e[i]); )
      n = e[i], i++, o++;
    s[a] = o - 1, a++;
    for (let l = 0; l < o; l++)
      s[a] = e[i - o + l], a++;
  }
  return V.debug("PackBits " + t + " -> " + a + " bytes (x" + t / a + ")"), s.slice(0, a);
}
function cs(e, t) {
  const i = new Uint8Array(e.buffer), s = new Int8Array(i.buffer);
  let r = 0;
  const a = new Uint8Array(t);
  let n = 0;
  for (; r < i.length; ) {
    const o = s[r];
    if (r++, o < 0) {
      const l = s[r];
      r++;
      for (let c = 0; c < 1 - o; c++)
        a[n] = l, n++;
    } else
      for (let l = 0; l < o + 1; l++)
        a[n] = s[r], r++, n++;
  }
  return a;
}
var ac = ({
  drawUndoBitmaps: e,
  currentDrawUndoBitmap: t,
  drawBitmap: i
}) => {
  const s = e.length;
  if (s < 1) {
    V.debug("undo bitmaps not loaded");
    return;
  }
  if (t--, t < 0 && (t = s - 1), t >= s && (t = 0), e[t].length < 2) {
    V.debug("drawUndo is misbehaving");
    return;
  }
  return i = cs(e[t], i.length), { drawBitmap: i, currentDrawUndoBitmap: t };
};
function oc(e, t, i) {
  const { dimX: s, dimY: r, dimZ: a } = i;
  let n;
  if (e === 0)
    n = a;
  else if (e === 1)
    n = r;
  else if (e === 2)
    n = s;
  else
    return null;
  let o = -1, l = -1;
  for (let c = 0; c < n; c++) {
    let h = !1;
    if (e === 0) {
      const f = c * s * r;
      for (let d = 0; d < s * r; d++)
        if (t[f + d] > 0) {
          h = !0;
          break;
        }
    } else if (e === 1)
      for (let f = 0; f < a; f++) {
        for (let d = 0; d < s; d++) {
          const u = d + c * s + f * s * r;
          if (t[u] > 0) {
            h = !0;
            break;
          }
        }
        if (h)
          break;
      }
    else if (e === 2)
      for (let f = 0; f < a; f++) {
        for (let d = 0; d < r; d++) {
          const u = c + d * s + f * s * r;
          if (t[u] > 0) {
            h = !0;
            break;
          }
        }
        if (h)
          break;
      }
    h && (o === -1 && (o = c), l = c);
  }
  return o === -1 || l === -1 ? null : { first: o, last: l };
}
function Gi(e, t, i, s) {
  const { dimX: r, dimY: a, dimZ: n } = s;
  let o;
  if (t === 0) {
    o = new Float32Array(r * a);
    const l = e * r * a;
    for (let c = 0; c < r * a; c++)
      o[c] = i[l + c];
  } else if (t === 1) {
    o = new Float32Array(r * n);
    for (let l = 0; l < n; l++)
      for (let c = 0; c < r; c++) {
        const h = c + e * r + l * r * a, f = c + l * r;
        o[f] = i[h];
      }
  } else if (t === 2) {
    o = new Float32Array(a * n);
    for (let l = 0; l < n; l++)
      for (let c = 0; c < a; c++) {
        const h = e + c * r + l * r * a, f = c + l * a;
        o[f] = i[h];
      }
  } else
    throw new Error("Invalid slice type");
  return o;
}
function Yi(e, t, i, s, r) {
  const { dimX: a, dimY: n, dimZ: o } = s;
  let l;
  if (t === 0) {
    l = new Float32Array(a * n);
    const c = e * a * n;
    for (let h = 0; h < a * n; h++)
      l[h] = i[c + h] / r;
  } else if (t === 1) {
    l = new Float32Array(a * o);
    for (let c = 0; c < o; c++)
      for (let h = 0; h < a; h++) {
        const f = h + e * a + c * a * n, d = h + c * a;
        l[d] = i[f] / r;
      }
  } else if (t === 2) {
    l = new Float32Array(n * o);
    for (let c = 0; c < o; c++)
      for (let h = 0; h < n; h++) {
        const f = e + h * a + c * a * n, d = h + c * n;
        l[d] = i[f] / r;
      }
  } else
    throw new Error("Invalid slice type");
  return l;
}
function lc(e, t, i, s, r, a, n) {
  const { dimX: o, dimY: l, dimZ: c } = r;
  if (i === 0) {
    const h = t * o * l;
    for (let f = 0; f < e.length; f++)
      e[f] >= a && (s[h + f] = n);
  } else if (i === 1)
    for (let h = 0; h < c; h++)
      for (let f = 0; f < o; f++) {
        const d = f + h * o, u = f + t * o + h * o * l;
        e[d] >= a && (s[u] = n);
      }
  else if (i === 2)
    for (let h = 0; h < c; h++)
      for (let f = 0; f < l; f++) {
        const d = f + h * l, u = t + f * o + h * o * l;
        e[d] >= a && (s[u] = n);
      }
  else
    throw new Error("Invalid slice type");
}
function hr(e, t, i) {
  if (t < 3 || i < 3)
    return;
  const s = new Float32Array(e.length);
  for (let r = 0; r < i; r++)
    for (let a = 0; a < t; a++) {
      const n = a + r * t;
      a === 0 || a === t - 1 ? s[n] = e[n] : s[n] = (e[n - 1] + 2 * e[n] + e[n + 1]) * 0.25;
    }
  for (let r = 0; r < i; r++)
    for (let a = 0; a < t; a++) {
      const n = a + r * t;
      r === 0 || r === i - 1 ? e[n] = s[n] : e[n] = (s[n - t] + 2 * s[n] + s[n + t]) * 0.25;
    }
}
function cc(e, t, i, s) {
  const r = Math.abs(i - e), a = Math.abs(i - t), n = Math.exp(-r * r / (2 * s * s)), o = Math.exp(-a * a / (2 * s * s)), l = n + o;
  return l < 1e-6 ? 0.5 : n / l;
}
function hc(e, t, i, s, r, a) {
  const n = (i - s) / (r - s), o = 1 - n;
  for (let l = 0; l < e.length; l++)
    a[l] = e[l] * o + t[l] * n;
}
function fc(e, t, i, s, r, a, n, o, l, c) {
  const h = (i - s) / (r - s), f = 1 - h;
  for (let d = 0; d < e.length; d++)
    if (e[d] > 0 || t[d] > 0) {
      const u = cc(
        o[d],
        l[d],
        c[d],
        n.intensitySigma
      ), m = n.intensityWeight, g = m * u + (1 - m) * f, p = 1 - g;
      a[d] = e[d] * g + t[d] * p;
    } else
      a[d] = e[d] * f + t[d] * h;
}
function dc(e, t, i, s, r, a, n, o) {
  const { dimX: l, dimY: c, dimZ: h } = t, f = n.sliceType ?? 0;
  let d, u, m;
  if (f === 0)
    d = l, u = c, m = h - 1;
  else if (f === 1)
    d = l, u = h, m = c - 1;
  else if (f === 2)
    d = c, u = h, m = l - 1;
  else
    throw new Error("Invalid slice type. Must be AXIAL, CORONAL, or SAGITTAL");
  const g = {
    intensityWeight: n.intensityWeight ?? 0.7,
    binaryThreshold: n.binaryThreshold ?? 0.375,
    intensitySigma: n.intensitySigma ?? 0.1,
    applySmoothingToSlices: n.applySmoothingToSlices ?? !0,
    useIntensityGuided: n.useIntensityGuided ?? !0
  };
  if (r !== void 0 && a !== void 0) {
    if (r >= a)
      throw new Error("Low slice index must be less than high slice index");
    if (r < 0 || a > m)
      throw new Error(`Slice indices out of bounds [0, ${m}]`);
  }
  const p = /* @__PURE__ */ new Map();
  for (let A = 0; A <= m; A++) {
    const x = Gi(A, f, e, t);
    for (let w = 0; w < x.length; w++) {
      const v = x[w];
      if (v > 0)
        if (!p.has(v))
          p.set(v, { min: A, max: A });
        else {
          const F = p.get(v);
          F.min = Math.min(F.min, A), F.max = Math.max(F.max, A);
        }
    }
  }
  for (const [A, x] of p) {
    const w = r !== void 0 ? Math.max(r, x.min) : x.min, v = a !== void 0 ? Math.min(a, x.max) : x.max;
    if (w >= v || v - w < 2)
      continue;
    const F = Gi(w, f, e, t), C = Gi(v, f, e, t), b = new Float32Array(F.length), y = new Float32Array(C.length);
    for (let E = 0; E < F.length; E++)
      b[E] = F[E] === A ? 1 : 0, y[E] = C[E] === A ? 1 : 0;
    g.applySmoothingToSlices && (hr(b, d, u), hr(y, d, u));
    for (let E = w + 1; E < v; E++) {
      const S = new Float32Array(d * u);
      if (g.useIntensityGuided && i) {
        const D = Yi(w, f, i, t, s), M = Yi(v, f, i, t, s), B = Yi(E, f, i, t, s);
        fc(
          b,
          y,
          E,
          w,
          v,
          S,
          g,
          D,
          M,
          B
        );
      } else
        hc(b, y, E, w, v, S);
      lc(S, E, f, e, t, g.binaryThreshold, A);
    }
  }
  o();
}
var Me = `#version 300 es
#line 4
layout(location=0) in vec3 pos;
layout(location=1) in vec3 texCoords;
uniform mat4 mvpMtx;
out vec3 vColor;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vColor = texCoords;
}`, Ds = `
	vec4 drawColor(float scalar, float drawOpacity) {
		float nlayer = float(textureSize(colormap, 0).y);
		float layer = (nlayer - 0.5) / nlayer;
		vec4 dcolor = texture(colormap, vec2((scalar * 255.0)/256.0 + 0.5/256.0, layer)).rgba;
		dcolor.a *= drawOpacity;
		return dcolor;
}`, ti = `vec3 GetBackPosition(vec3 startPositionTex) {
	vec3 startPosition = startPositionTex * volScale;
	vec3 invR = 1.0 / rayDir;
	vec3 tbot = invR * (vec3(0.0)-startPosition);
	vec3 ttop = invR * (volScale-startPosition);
	vec3 tmax = max(ttop, tbot);
	vec2 t = min(tmax.xx, tmax.yz);
	vec3 endPosition = startPosition + (rayDir * min(t.x, t.y));
	//convert world position back to texture position:
	endPosition = endPosition / volScale;
	return endPosition;
}

float distance2Plane(in vec4 samplePos, in vec4 clipPlane) {
	// treat clipPlane.a > 1 as "no clip" sentinel (keeps existing behavior)
	if (clipPlane.a > 1.0) {
			return 1000.0; // sentinel large distance
	}
	vec3 n = clipPlane.xyz;
	const float EPS = 1e-6;
	float nlen = length(n);
	if (nlen < EPS) {
			return 1000.0; // invalid plane normal
	}
	// signed plane value: dot(n, p-0.5) + a
	float signedDist = dot(n, samplePos.xyz - 0.5) + clipPlane.a;
	// perpendicular (Euclidean) distance is |signedDist| / |n|
	return abs(signedDist) / nlen;
}

// see if clip plane trims ray sampling range sampleStartEnd.x..y
void clipSampleRange(in vec3 dir, in vec4 rayStart, in vec4 clipPlane, inout vec2 sampleStartEnd, inout bool hasClip) {
	const float CSR_EPS = 1e-6;
	// quick exit: no clip plane
	if (clipPlane.a > 1.0)
			return;
	hasClip = true;
	// quick exit: empty range
	if ((sampleStartEnd.y - sampleStartEnd.x) <= CSR_EPS)
			return;
	// Which side does the ray start on? (plane eqn: dot(n, p-0.5) + a = 0)
	float sampleSide = dot(clipPlane.xyz, rayStart.xyz - 0.5) + clipPlane.a;
	bool startsFront = (sampleSide < 0.0);
	float dis = - 1.0;
	// plane normal dot ray direction
	float cdot = dot(dir, clipPlane.xyz);
	// avoid division by 0 for near-parallel plne
	if (abs(cdot) >= CSR_EPS)
		dis = (-clipPlane.a - dot(clipPlane.xyz, rayStart.xyz - 0.5)) / cdot;
	if (dis < 0.0 || dis > sampleStartEnd.y + CSR_EPS) {
			if (startsFront)
				sampleStartEnd = vec2(0.0, 0.0);
			return;
	}
	bool frontface = (cdot > 0.0);
	if (frontface)
		sampleStartEnd.x = max(sampleStartEnd.x, dis);
	else
		sampleStartEnd.y = min(sampleStartEnd.y, dis);
	// if nothing remains, mark empty
	if (sampleStartEnd.y - sampleStartEnd.x <= CSR_EPS)
		sampleStartEnd = vec2(0.0, 0.0);
}

bool skipSample (float pos, vec2 sampleRange) {
	return (pos < sampleRange.x || pos > sampleRange.y);
}

float frac2ndc(vec3 frac) {
//https://stackoverflow.com/questions/7777913/how-to-render-depth-linearly-in-modern-opengl-with-gl-fragcoord-z-in-fragment-sh
	vec4 pos = vec4(frac.xyz, 1.0); //fraction
	vec4 dim = vec4(vec3(textureSize(volume, 0)), 1.0);
	pos = pos * dim;
	vec4 shim = vec4(-0.5, -0.5, -0.5, 0.0);
	pos += shim;
	vec4 mm = transpose(matRAS) * pos;
	float z_ndc = (mvpMtx * vec4(mm.xyz, 1.0)).z;
	return (z_ndc + 1.0) / 2.0;
}` + Ds, Ss = `void main() {
	if (fColor.x > 2.0) {
		fColor = vec4(1.0, 0.0, 0.0, 0.5);
		return;
	}
	fColor = vec4(0.0,0.0,0.0,0.0);
	vec4 clipPlaneColorX = clipPlaneColor;
	//if (clipPlaneColor.a < 0.0)
	//	clipPlaneColorX.a = - 1.0;
	bool isColorPlaneInVolume = false;
	if (clipPlaneColorX.a < 0.0) {
		isColorPlaneInVolume = true;
		clipPlaneColorX.a = 0.0;
	}
	//fColor = vec4(vColor.rgb, 1.0); return;
	vec3 start = vColor;
	gl_FragDepth = 1.0;
	vec3 backPosition = GetBackPosition(start);
	// fColor = vec4(backPosition, 1.0); return;
	vec3 dir = normalize(backPosition - start);
	//clipVolumeStart(start, backPosition);
	dir = normalize(dir);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays
		return;
	}
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	vec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position

	vec2 sampleRange = vec2(0.0, len);
	bool hasClip = false;
	for (int i = 0; i < MAX_CLIP_PLANES; i++)
		clipSampleRange(dir, samplePos, clipPlanes[i], sampleRange, hasClip);
	bool isClip = (sampleRange.x > 0.0) || ((sampleRange.y < len) && (sampleRange.y > 0.0));
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	if ((isClipCutaway) && (sampleRange.x <= 0.0) && (sampleRange.y >= len)) {
		//completely clipped, but ray does not intersect plane
		if (hasClip)
			samplePos.a = len + 1.0;
		else
			sampleRange = vec2(0.0, 0.0);
	}
	if ((!isClipCutaway) && (sampleRange.x >= sampleRange.y))
		samplePos.a = len + 1.0;
	while (samplePos.a <= len) {
		if (skipSample(samplePos.a, sampleRange) ^^ isClipCutaway) {
			samplePos += deltaDirFast;
			continue;
		}
		float val = texture(volume, samplePos.xyz).a;
		if (val > 0.01)
			break;
		samplePos += deltaDirFast; //advance ray position
	}
	float drawOpacityA = renderDrawAmbientOcclusionXY.y;
	if ((samplePos.a >= len) && (((overlays < 1.0) && (drawOpacityA <= 0.0) ) || (backgroundMasksOverlays > 0)))  {
		if (isClip)
			fColor += clipPlaneColorX;
		return;
	}
	fColor = vec4(1.0, 1.0, 1.0, 1.0);
	//gl_FragDepth = frac2ndc(samplePos.xyz); //crude due to fast pass resolution
	if (samplePos.a > deltaDirFast.a )
		samplePos -= deltaDirFast;
	//end: fast pass
	vec4 colAcc = vec4(0.0,0.0,0.0,0.0);
	vec4 firstHit = vec4(0.0,0.0,0.0,2.0 * len);
	const float earlyTermination = 0.95;
	float backNearest = len; //assume no hit
	float ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
	// clip planes create steep gradients: reduce aliasing with more jitter
	if (isClip)
		samplePos += deltaDir * ran * 1.41; //jitter ray
	else
		samplePos += deltaDir * ran; //jitter ray
`, Ti = `
	if (firstHit.a < len) {
		gl_FragDepth = frac2ndc(firstHit.xyz);
		vec4 paqdSample = texture(paqd, samplePos.xyz);
		if (paqdSample.a > 0.0) {
			//colAcc.rgb = paqdSample.rgb;
			float a = max(abs(paqdUniforms[2]), abs(paqdUniforms[3]));
			colAcc.rgb = mix(colAcc.rgb, paqdSample.rgb, 0.5 * paqdSample.a * a);
		}
		if (isClip) {
			//shade voxels with clip color
			if (clipPlaneColor.a < 0.0) {
					float thresh = 4.0 * sliceSize;
					float firstHit1 = firstHit.a + deltaDir.a;
				if (isClipCutaway) {
					float min1 = abs(firstHit1 - sampleRange.y);
					float dx = samplePos.a - firstHit1;
					if (min1 < thresh)
						colAcc.rgb = mix(colAcc.rgb, clipPlaneColorX.rgb, abs(clipPlaneColor.a));
					else if (( colAcc.a > earlyTermination ) && (dx > thresh)) {
						min1 = abs(firstHit1 - sampleRange.x);
						if (min1 < (thresh * 0.5)) {
							colAcc.rgb = mix(colAcc.rgb , clipPlaneColorX.rgb, abs(clipPlaneColor.a)*0.5);
						}
							
					}
				} else {
					if (abs(firstHit1 - sampleRange.x) < thresh)
						colAcc.rgb = mix(colAcc.rgb, clipPlaneColorX.rgb, abs(clipPlaneColor.a));
				} // clipPlaneColor.a < 0.0
			}
			//ambient occlusion: make creases dark
			float min1 = 1000.0;
			float min2 = 1000.0;
			// find smallest and second-smallest distances
			vec4 firstHit1 = firstHit - deltaDir;
			for (int i = 0; i < MAX_CLIP_PLANES; i++) {
				float d = distance2Plane(firstHit1, clipPlanes[i]);
				if (d < min1) {
						min2 = min1;
						min1 = d;
				} else if (d < min2) {
						min2 = d;
				}
			}
			float thresh = 1.2 * sliceSize;
			if ((isClipCutaway) && (min2 < thresh) && (sampleRange.x > 0.0)) {
				if ((abs(sampleRange.x - firstHit.a) > ( 2.0 * thresh)) && ((abs(sampleRange.y - firstHit.a) > (2.0 * thresh))))
					min2 = thresh; 
			}
			// if second is 0 -> factor 0 (black), if second >= sliceSize -> factor 1 (unchanged)
			const float aoFrac = 0.5;
			float factor = (1.0 - aoFrac) + aoFrac * clamp(min2 / thresh, 0.0, 1.0);
			// linear darkening: multiply color by factor (or use mix(vec3(0), colAcc.rgb, factor))
			colAcc.rgb *= factor;
		}
	}
	colAcc.a = (colAcc.a / earlyTermination) * backOpacity;
	fColor = colAcc;
	float renderDrawAmbientOcclusionX = renderDrawAmbientOcclusionXY.x;
	float drawOpacity = renderDrawAmbientOcclusionXY.y;
	if ((overlays < 1.0) && (drawOpacity <= 0.0))
		return;
	//overlay pass
	samplePos = vec4(start.xyz, 0.0); //ray position
	//start: OPTIONAL fast pass: rapid traversal until first hit
	stepSizeFast = sliceSize * 1.0;
	deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(overlay, samplePos.xyz).a;
		if (drawOpacity > 0.0)
			val = max(val, texture(drawing, samplePos.xyz).r);
		if (val > 0.001)
			break;
		samplePos += deltaDirFast; //advance ray position
	}
	if (samplePos.a >= len) {
		if (isClip && (fColor.a == 0.0))
				fColor += clipPlaneColorX;
			return;
	}
	samplePos -= deltaDirFast;
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	//end: fast pass
	float overFarthest = len;
	colAcc = vec4(0.0, 0.0, 0.0, 0.0);

	samplePos += deltaDir * ran; //jitter ray
	vec4 overFirstHit = vec4(0.0,0.0,0.0,2.0 * len);
	if (backgroundMasksOverlays > 0)
		samplePos = firstHit;
	bool firstDraw = true;
	while (samplePos.a <= len) {
		vec4 colorSample = texture(overlay, samplePos.xyz);
		if ((colorSample.a < 0.01) && (drawOpacity > 0.0)) {
			float val = texture(drawing, samplePos.xyz).r;
			vec4 draw = drawColor(val, drawOpacity);
			if ((draw.a > 0.0) && (firstDraw)) {
				firstDraw = false;
				float sum = 0.0;
				const float mn = 1.0 / 256.0;
				const float sampleRadius = 1.1;
				float dx = sliceSize * sampleRadius;
				vec3 center = samplePos.xyz;
				//six neighbors that share a face
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,0.0), dir)).r, mn);
				//float proportion = (sum / mn) / 6.0;
				
				//12 neighbors that share an edge
				dx = sliceSize * sampleRadius * sqrt(2.0) * 0.5;
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,+dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,-dx,0.0), dir)).r, mn);

				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,-dx,0.0), dir)).r, mn);
				
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,+dx,0.0), dir)).r, mn);
				float proportion = (sum / mn) / 18.0; //proportion of six neighbors is non-zero
				
				//a high proportion of hits means crevice
				//since the AO term adds shadows that darken most voxels, it will result in dark surfaces
				//the term brighten adds a little illumination to balance this
				// without brighten, only the most extreme ridges will not be darker
				const float brighten = 1.2;
				vec3 ao = draw.rgb * (1.0 - proportion) * brighten;
				draw.rgb = mix (draw.rgb, ao , renderDrawAmbientOcclusionX);
			}
			colorSample = draw;
		}
		samplePos += deltaDir; //advance ray position
		if (colorSample.a >= 0.01) {
			if (overFirstHit.a > len)
				overFirstHit = samplePos;
			colorSample.a *= renderOverlayBlend;
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			overFarthest = samplePos.a;
			if ( colAcc.a > earlyTermination )
				break;
		}
	}
	//if (samplePos.a >= len) {
	if (colAcc.a <= 0.0) {
		if (isClip && (fColor.a == 0.0))
			fColor += clipPlaneColorX;
		return;
	}
	if (overFirstHit.a < firstHit.a)
		gl_FragDepth = frac2ndc(overFirstHit.xyz);
	float overMix = colAcc.a;
	float overlayDepth = 0.3;
	if (fColor.a <= 0.0)
		overMix = 1.0;
	else if (((overFarthest) > backNearest)) {
		float dx = (overFarthest - backNearest)/1.73;
		dx = fColor.a * pow(dx, overlayDepth);
		overMix *= 1.0 - dx;
	}
	fColor.rgb = mix(fColor.rgb, colAcc.rgb, overMix);
	fColor.a = max(fColor.a, colAcc.a);
}`, uc = `#version 300 es
#line 215
#define MAX_CLIP_PLANES 6
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform vec4 clipPlanes[MAX_CLIP_PLANES];
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform float overlays;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform vec2 renderDrawAmbientOcclusionXY;
in vec3 vColor;
out vec4 fColor;
` + ti + `
	void main() {
	vec3 start = vColor;
	gl_FragDepth = 1.0;
	vec3 backPosition = GetBackPosition(start);
	vec3 dir = normalize(backPosition - start);
	//clipVolumeStart(start, backPosition);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays
		fColor = vec4(0.0,0.0,0.0,0.0);
		return;
	}
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	vec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	vec4 colAcc = vec4(0.0,0.0,0.0,0.0);
	vec4 firstHit = vec4(0.0,0.0,0.0,2.0 * len);
	const float earlyTermination = 0.95;
	float backNearest = len; //assume no hit
	float dis = len;
	//check if axial plane is closest
	vec4 aClip = vec4(0.0, 0.0, 1.0, (1.0- clipPlane.z) - 0.5);
	float adis = (-aClip.a - dot(aClip.xyz, samplePos.xyz-0.5)) / dot(dir,aClip.xyz);
	if (adis > 0.0)
		dis = min(adis, dis);
	//check of coronal plane is closest
	vec4 cClip = vec4(0.0, 1.0, 0.0, (1.0- clipPlane.y) - 0.5);
	float cdis = (-cClip.a - dot(cClip.xyz, samplePos.xyz-0.5)) / dot(dir,cClip.xyz);
	if (cdis > 0.0)
		dis = min(cdis, dis);
	//check if coronal slice is closest
	vec4 sClip = vec4(1.0, 0.0, 0.0, (1.0- clipPlane.x) - 0.5);
	float sdis = (-sClip.a - dot(sClip.xyz, samplePos.xyz-0.5)) / dot(dir,sClip.xyz);
	if (sdis > 0.0)
		dis = min(sdis, dis);
	if ((dis > 0.0) && (dis < len)) {
		samplePos = vec4(samplePos.xyz+dir * dis, dis);
		colAcc = texture(volume, samplePos.xyz);
		colAcc.a = earlyTermination;
		firstHit = samplePos;
		backNearest = min(backNearest, samplePos.a);
	}
	//the following are only used by overlays
	vec4 clipPlaneColorX = clipPlaneColor;
	bool isColorPlaneInVolume = false;
	bool isClip = false;
	bool isClipCutaway = false;
	vec2 sampleRange;
	// vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
	samplePos += deltaDir * ran; //jitter ray
` + Ti, mc = `#version 300 es
#line 215
#define MAX_CLIP_PLANES 6
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform vec4 clipPlanes[MAX_CLIP_PLANES];
uniform bool isClipCutaway;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform float overlays;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform vec2 renderDrawAmbientOcclusionXY;
in vec3 vColor;
out vec4 fColor;
` + ti + Ss + `while (samplePos.a <= len) {
		if (skipSample(samplePos.a, sampleRange) ^^ isClipCutaway) {
			samplePos += deltaDirFast;
			continue;
		}
		vec4 colorSample = texture(volume, samplePos.xyz);
		samplePos += deltaDir; //advance ray position
		if (colorSample.a >= 0.01) {
			if (firstHit.a > len)
				firstHit = samplePos;
			// backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
	}
	if (firstHit.a < len)
		backNearest = firstHit.a;
` + Ti, Ne = 192, pn = `#version 300 es
#line 215
#define MAX_CLIP_PLANES 6
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform vec4 clipPlanes[MAX_CLIP_PLANES];
uniform bool isClipCutaway;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform float overlays;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 normMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing, gradient;
uniform highp sampler2D colormap;
uniform highp sampler2D matCap;
uniform vec2 renderDrawAmbientOcclusionXY;
uniform float gradientAmount;
uniform float silhouettePower;
uniform float gradientOpacity[${Ne}];
in vec3 vColor;
out vec4 fColor;
`, gc = pn + ti + Ss + `
	float startPos = samplePos.a;
	float clipCloseThresh = 5.0 * deltaDir.a;
	float clipClose = sampleRange.x;
	if (isClipCutaway)
		clipClose = sampleRange.y;
	if (!isClip)
		clipClose = -1.0;
	float brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25
	//vec4 prevGrad = vec4(0.0);
	float silhouetteThreshold = 1.0 - silhouettePower;
	while (samplePos.a <= len) {
		if (skipSample(samplePos.a, sampleRange) ^^ isClipCutaway) {
			samplePos += deltaDirFast;
			continue;
		}
		vec4 colorSample = texture(volume, samplePos.xyz);
		if (colorSample.a >= 0.0) {
			vec4 grad = texture(gradient, samplePos.xyz);
			grad.rgb = normalize(grad.rgb*2.0 - 1.0);
			//if (grad.a < prevGrad.a)
			//	grad.rgb = prevGrad.rgb;
			//prevGrad = grad;
			vec3 n = mat3(normMtx) * grad.rgb;
			n.y = - n.y;
			vec4 mc = vec4(texture(matCap, n.xy * 0.5 + 0.5).rgb, 1.0) * brighten;
			mc = mix(vec4(1.0), mc, gradientAmount);
			if (abs(samplePos.a - clipClose) > clipCloseThresh)
				colorSample.rgb *= mc.rgb;
			if (firstHit.a > len)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			int gradIdx = int(grad.a * ${Ne}.0);
			colorSample.a *= gradientOpacity[gradIdx];
			float lightNormDot = dot(grad.rgb, rayDir);
			// n.b. "lightNormDor" is cosTheta, "silhouettePower" is Fresnel effect exponent
 			colorSample.a *= pow(1.0 - abs(lightNormDot), silhouettePower);
 			float viewAlign = abs(lightNormDot); // 0 = perpendicular, 1 = aligned
 			// linearly map silhouettePower (0..1) to a threshold range, e.g., [1.0, 0.0]
 			// Cull voxels that are too aligned with the view direction
 			if (viewAlign > silhouetteThreshold)
 				colorSample.a = 0.0;
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
		samplePos += deltaDir; //advance ray position
	}
` + Ti, pc = pn + ti + Ss + `
	float startPos = samplePos.a;
	//float clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane
	float brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25
	//vec4 prevGrad = vec4(0.0);
	while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		if (colorSample.a >= 0.0) {
			vec4 grad = texture(gradient, samplePos.xyz);
			colorSample.rgb = abs(normalize(grad.rgb*2.0 - 1.0));
			if (firstHit.a > len)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
		samplePos += deltaDir; //advance ray position
	}
` + Ti, li = `#version 300 es
#line 392
layout(location=0) in vec3 pos;
uniform int axCorSag;
uniform mat4 mvpMtx;
uniform mat4 frac2mm;
uniform float slice;
out vec3 texPos;
void main(void) {
	texPos = vec3(pos.x, pos.y, slice);
	if (axCorSag > 1)
		texPos = vec3(slice, pos.x, pos.y);
	else if (axCorSag > 0)
		texPos = vec3(pos.x, slice, pos.y);
	vec4 mm = frac2mm * vec4(texPos, 1.0);
	gl_Position = mvpMtx * mm;
}`, An = `#version 300 es
#line 411
precision highp int;
precision highp float;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform int backgroundMasksOverlays;
uniform float overlayOutlineWidth;
uniform float overlayAlphaShader;
uniform int axCorSag;
uniform float overlays;
uniform float opacity;
uniform float drawOpacity;
uniform float drawRimOpacity;
uniform bool isAlphaClipDark;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
in vec3 texPos;
out vec4 color;
` + Ds + `
vec4 blendRGBA(vec4 foreground, vec4 background) {
  float alphaOut = foreground.a + background.a * (1.0 - foreground.a);
  vec3 colorOut = (foreground.rgb * foreground.a + background.rgb * background.a * (1.0 - foreground.a)) / alphaOut;
  return vec4(colorOut, alphaOut);
}
float paqdEaseAlpha(float alpha) {
  // t are alpha transitions
  // <t0 -> y0
  // t0..t1  -> mix between y0..y1
  // t1..t2 -> mix between y1..y2
  // >t2 -> y2
  float t0 = paqdUniforms[0]; // 0.3;
  float t1 = 0.5 * (paqdUniforms[0] + paqdUniforms[1]); // 0.4;
  float t2 = paqdUniforms[1]; // 0.9;
  float y0 = 0.0;
  float y1 = abs(paqdUniforms[2]); // 1.0;
  float y2 = abs(paqdUniforms[3]); //0.25;
  if (alpha <= t0) {
    return y0;
  } else if (alpha <= t1) {
    return mix(y0, y1, (alpha - t0) / (t1 - t0)); // LERP 0.0  1.0
  } else if (alpha <= t2) {
    return mix(y1, y2, (alpha - t1) / (t2 - t1)); // LERP 1.0  0.2
  } else {
    return y2;
  }
}

void main() {
	//color = vec4(1.0, 0.0, 1.0, 1.0);return;
	vec4 background = texture(volume, texPos);
	color = vec4(background.rgb, opacity);
	if ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range
	vec4 ocolor = vec4(0.0);
	float overlayAlpha = overlayAlphaShader;
	if (overlays > 0.0) {
		ocolor = texture(overlay, texPos);
		//dFdx for "boxing" issue 435 has aliasing on some implementations (coarse vs fine)
		//however, this only identifies 50% of the edges due to aliasing effects
		// http://www.aclockworkberry.com/shader-derivative-functions/
		// https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b
		//if ((ocolor.a >= 1.0) && ((dFdx(ocolor.a) != 0.0) || (dFdy(ocolor.a) != 0.0)  ))
		//	ocolor.rbg = vec3(0.0, 0.0, 0.0);
		bool isOutlineBelowNotAboveThreshold = true;
		if (isOutlineBelowNotAboveThreshold) {
			if ((overlayOutlineWidth > 0.0) && (ocolor.a < 1.0)) { //check voxel neighbors for edge
				vec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));
				//6 voxel neighbors that share a face
				vec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);
				vec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);
				vec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);
				vec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);
				vec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);
				vec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);
				float a = 0.0;
				if (axCorSag != 2) {
					a = max(a, texture(overlay, vxR).a);
					a = max(a, texture(overlay, vxL).a);
				}
				if (axCorSag != 1) {
					a = max(a, texture(overlay, vxA).a);
					a = max(a, texture(overlay, vxP).a);
				}
				if (axCorSag != 0) {
					a = max(a, texture(overlay, vxS).a);
					a = max(a, texture(overlay, vxI).a);
				}
				bool isCheckCorners = true;
				if (isCheckCorners) {
					//12 voxel neighbors that share an edge
					vec3 vxRA = vec3(texPos.x+vx.x, texPos.y+vx.y, texPos.z);
					vec3 vxLA = vec3(texPos.x-vx.x, texPos.y+vx.y, texPos.z);
					vec3 vxRP = vec3(texPos.x+vx.x, texPos.y-vx.y, texPos.z);
					vec3 vxLP = vec3(texPos.x-vx.x, texPos.y-vx.y, texPos.z);
					vec3 vxRS = vec3(texPos.x+vx.x, texPos.y, texPos.z+vx.z);
					vec3 vxLS = vec3(texPos.x-vx.x, texPos.y, texPos.z+vx.z);
					vec3 vxRI = vec3(texPos.x+vx.x, texPos.y, texPos.z-vx.z);
					vec3 vxLI = vec3(texPos.x-vx.x, texPos.y, texPos.z-vx.z);
					vec3 vxAS = vec3(texPos.x, texPos.y+vx.y, texPos.z+vx.z);
					vec3 vxPS = vec3(texPos.x, texPos.y-vx.y, texPos.z+vx.z);
					vec3 vxAI = vec3(texPos.x, texPos.y+vx.y, texPos.z-vx.z);
					vec3 vxPI = vec3(texPos.x, texPos.y-vx.y, texPos.z-vx.z);

					if (axCorSag == 0) { //axial corners
						a = max(a, texture(overlay, vxRA).a);
						a = max(a, texture(overlay, vxLA).a);
						a = max(a, texture(overlay, vxRP).a);
						a = max(a, texture(overlay, vxLP).a);
					}
					if (axCorSag == 1) { //coronal corners
						a = max(a, texture(overlay, vxRS).a);
						a = max(a, texture(overlay, vxLS).a);
						a = max(a, texture(overlay, vxRI).a);
						a = max(a, texture(overlay, vxLI).a);
					}
					if (axCorSag == 2) { //sagittal corners
						a = max(a, texture(overlay, vxAS).a);
						a = max(a, texture(overlay, vxPS).a);
						a = max(a, texture(overlay, vxAI).a);
						a = max(a, texture(overlay, vxPI).a);
					}
				}
				if (a >= 1.0) {
					ocolor = vec4(0.0, 0.0, 0.0, 1.0);
					overlayAlpha = 1.0;
				}
			}

		} else {
			if ((overlayOutlineWidth > 0.0) && (ocolor.a >= 1.0)) { //check voxel neighbors for edge
				vec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));
				vec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);
				vec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);
				vec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);
				vec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);
				vec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);
				vec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);
				float a = 1.0;
				if (axCorSag != 2) {
					a = min(a, texture(overlay, vxR).a);
					a = min(a, texture(overlay, vxL).a);
				}
				if (axCorSag != 1) {
					a = min(a, texture(overlay, vxA).a);
					a = min(a, texture(overlay, vxP).a);
				}
				if (axCorSag != 0) {
					a = min(a, texture(overlay, vxS).a);
					a = min(a, texture(overlay, vxI).a);
				}
				if (a < 1.0) {
					ocolor = vec4(0.0, 0.0, 0.0, 1.0);
					overlayAlpha = 1.0;
				}
			}
		} //outline above threshold
	}

`, Ac = `#version 300 es
#line 411
precision highp int;
precision highp float;
uniform highp sampler2D volume, overlay;
uniform int backgroundMasksOverlays;
uniform float overlayOutlineWidth;
uniform float overlayAlphaShader;
uniform int axCorSag;
uniform float overlays;
uniform float opacity;
uniform float drawOpacity;
uniform bool isAlphaClipDark;
uniform highp sampler2D drawing;
uniform highp sampler2D colormap;
in vec3 texPos;
out vec4 color;` + Ds + `void main() {
	//color = vec4(1.0, 0.0, 1.0, 1.0);return;
	vec4 background = texture(volume, texPos.xy);
	color = vec4(background.rgb, opacity);
	if ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range
	vec4 dcolor = drawColor(texture(drawing, texPos.xy).r, drawOpacity);
	if (dcolor.a > 0.0) {
		color.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);
		color.a = max(drawOpacity, color.a);
	}
}`, xn = `	ocolor.a *= overlayAlpha;
	float drawV = texture(drawing, texPos).r;
	vec4 dcolor = drawColor(drawV, drawOpacity);
	if (dcolor.a > 0.0) {
		if (drawRimOpacity >= 0.0) {
			vec3 vx = 1.0 / vec3(textureSize(drawing, 0));
			//6 voxel neighbors that share a face
			vec3 offsetX = dFdx(texPos); // left-right spacing
			vec3 offsetY = dFdy(texPos); // up-down spacing
			float L = texture(drawing, texPos - offsetX).r;
			float R = texture(drawing, texPos + offsetX).r;
			float T = texture(drawing, texPos - offsetY).r;
			float B = texture(drawing, texPos + offsetY).r;
			if (L != drawV || R != drawV || T != drawV || B != drawV)
				dcolor.a = drawRimOpacity;
		}
		color.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);
		color.a = max(drawOpacity, color.a);
	}
	vec4 pcolor = texture(paqd, texPos);
	if (pcolor.a > 0.0) {
		pcolor.a = paqdEaseAlpha(pcolor.a);
		if (pcolor.a > 0.0) {
			if (paqdUniforms[3] < 0.0)
				ocolor = blendRGBA(pcolor, ocolor);
			else
				ocolor = blendRGBA(ocolor, pcolor);
		}
	}
	if ((backgroundMasksOverlays > 0) && (background.a == 0.0))
		return;
	float a = color.a + ocolor.a * (1.0 - color.a); // premultiplied alpha
	if (a == 0.0) return;
	color.rgb = mix(color.rgb, ocolor.rgb, ocolor.a / a);
	color.a = a;
}`, xc = An + xn, vc = An + `	if (ocolor.a > 0.0) {
		//https://gamedev.stackexchange.com/questions/102889/is-it-possible-to-convert-vec4-to-int-in-glsl-using-opengl-es
		uint alpha = uint(ocolor.a * 255.0);
		vec3 xyzFlip = vec3(float((uint(1) & alpha) > uint(0)), float((uint(2) & alpha) > uint(0)), float((uint(4) & alpha) > uint(0)));
		//convert from 0 and 1 to -1 and 1
		xyzFlip = (xyzFlip * 2.0) - 1.0;
		//https://math.stackexchange.com/questions/1905533/find-perpendicular-distance-from-point-to-line-in-3d
		//v1 principle direction of tensor for this voxel
		vec3 v1 = ocolor.rgb;
		//flips encode polarity to convert from 0..1 to -1..1 (27 bits vs 24 bit precision)
		v1 = normalize( v1 * xyzFlip);
		vec3 vxl = fract(texPos * vec3(textureSize(volume, 0))) - 0.5;
		//vxl coordinates now -0.5..+0.5 so 0,0,0 is origin
		vxl.x = -vxl.x;
		float t = dot(vxl,v1);
		vec3 P = t * v1;
		float dx = length(P-vxl);
		ocolor.a = 1.0 - smoothstep(0.2,0.25, dx);
		//if modulation was applied, use that to scale alpha not color:
		ocolor.a *= length(ocolor.rgb);
		ocolor.rgb = normalize(ocolor.rgb);
		//compute distance one half voxel closer to viewer:
		float pan = 0.5;
		if (axCorSag == 0)
			vxl.z -= pan;
		if (axCorSag == 1)
			vxl.y -= pan;
		if (axCorSag == 2)
			vxl.x += pan;
		t = dot(vxl,v1);
		P = t * v1;
		float dx2 = length(P-vxl);
		ocolor.rgb += (dx2-dx-(0.5 * pan)) * 1.0;
	}
` + xn, Wi = `#version 300 es
#line 480
precision highp int;
precision highp float;
uniform vec4 lineColor;
out vec4 color;
void main() {
	color = lineColor;
}`, wc = `#version 300 es
#line 723
precision highp int;
precision highp float;

uniform vec4 lineColor;
uniform vec4 leftTopWidthHeight;
uniform float thickness; // line thickness in pixels
uniform vec2 canvasWidthHeight;

out vec4 color;

void main() {
    // fragment position in screen coordinates
    vec2 fragCoord = gl_FragCoord.xy;

    // canvas height
    float canvasHeight = canvasWidthHeight.y;

    // 'top' and 'bottom' to match gl_FragCoord.y coordinate system
    float top = canvasHeight - leftTopWidthHeight.y;
    float bottom = top - leftTopWidthHeight.w;

    // left and right edges
    float left = leftTopWidthHeight.x;
    float right = left + leftTopWidthHeight.z;

    bool withinLeft = fragCoord.x >= left && fragCoord.x <= left + thickness;
    bool withinRight = fragCoord.x <= right && fragCoord.x >= right - thickness;
    bool withinTop = fragCoord.y <= top && fragCoord.y >= top - thickness;
    bool withinBottom = fragCoord.y >= bottom && fragCoord.y <= bottom + thickness;

    bool isOutline = withinLeft || withinRight || withinTop || withinBottom;

    if (isOutline) {
        color = lineColor;
    } else {
        discard; 
    }
}`, bc = `#version 300 es
#line 490
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
out vec2 vColor;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vColor = pos.xy;
}`, yc = `#version 300 es
#line 506
precision highp int;
precision highp float;
uniform highp sampler2D colormap;
uniform float layer;
in vec2 vColor;
out vec4 color;
void main() {
	float nlayer = float(textureSize(colormap, 0).y);
	float fmap = (0.5 + layer) / nlayer;
	color = vec4(texture(colormap, vec2(vColor.x, fmap)).rgb, 1.0);
}`, fr = `#version 300 es
#line 520
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
}`, Cc = `#version 300 es
#line 534
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform float thickness;
uniform vec4 startXYendXY;
void main(void) {
	vec2 posXY = mix(startXYendXY.xy, startXYendXY.zw, pos.x);
	vec2 dir = normalize(startXYendXY.xy - startXYendXY.zw);
	posXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);
	posXY.x = (posXY.x) / canvasWidthHeight.x; //0..1
	posXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0
	gl_Position = vec4((posXY * 2.0) - 1.0, 0.0, 1.0);
}`, Fc = `#version 300 es
#line 534
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform float thickness;
uniform vec2 startXY;
uniform vec3 endXYZ; // transformed XYZ point
void main(void) {	
	vec2 posXY = mix(startXY.xy, endXYZ.xy, pos.x);
	vec2 startDiff = endXYZ.xy - startXY.xy;
	float startDistance = length(startDiff);
	vec2 diff = endXYZ.xy - posXY;
	float currentDistance = length(diff);
	vec2 dir = normalize(startXY.xy - endXYZ.xy);
	posXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);
	posXY.x = (posXY.x) / canvasWidthHeight.x; //0..1
	posXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0	
	float z = endXYZ.z * ( 1.0 - abs(currentDistance/startDistance)); 
	gl_Position = vec4((posXY * 2.0) - 1.0, z, 1.0);
}`, Mc = `#version 300 es
#line 549
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = vec2(pos.x, 1.0 - pos.y);
}`, Ec = `#version 300 es
#line 565
precision highp int;
precision highp float;
uniform highp sampler2D bmpTexture;
in vec2 vUV;
out vec4 color;
void main() {
	color = texture(bmpTexture, vUV);
}`, Dc = `#version 300 es
#line 576
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
uniform vec4 uvLeftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = vec2(uvLeftTopWidthHeight.x + (pos.x * uvLeftTopWidthHeight.z), uvLeftTopWidthHeight.y  + ((1.0 - pos.y) * uvLeftTopWidthHeight.w) );
}`, Sc = `#version 300 es
#line 593
precision highp int;
precision highp float;
uniform highp sampler2D fontTexture;
uniform vec4 fontColor;
uniform float screenPxRange;
in vec2 vUV;
out vec4 color;
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
void main() {
	vec3 msd = texture(fontTexture, vUV).rgb;
	float sd = median(msd.r, msd.g, msd.b);
	float screenPxDistance = screenPxRange*(sd - 0.5);
	float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);
	color = vec4(fontColor.rgb , fontColor.a * opacity);
}`, Ic = `#version 300 es
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
uniform vec4 uvLeftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = pos.xy;
}`, Tc = `#version 300 es
precision highp int;
precision highp float;
uniform vec4 circleColor;
uniform float fillPercent;
in vec2 vUV;
out vec4 color;
void main() {
	/* Check if the pixel is inside the circle
		 and color it with a gradient. Otherwise, color it 
		 transparent   */
	float distance = length(vUV-vec2(0.5,0.5));
	if ( distance < 0.5 && distance >= (1.0 - fillPercent) / 2.0){
			color = vec4(circleColor.r,circleColor.g,circleColor.b,circleColor.a) ;			
	}else{
			color = vec4(0.0,0.0,0.0,0.0);
	}
}
`, te = `#version 300 es
#line 613
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	gl_Position = vec4( (vPos.xy-vec2(0.5,0.5)) * 2.0, 0.0, 1.0);
}`, ci = `#version 300 es
uniform highp usampler3D intensityVol;
`, dr = `#version 300 es
uniform highp isampler3D intensityVol;
`, Vc = `#version 300 es
uniform highp sampler3D intensityVol;
`, ur = `#line 1042
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform bool isAdditiveBlend;
uniform float coordZ;
uniform float layer;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform uint activeIndex;
uniform vec4 xyzaFrac;
uniform mat4 mtx;
float textureWidth;
float nlayer;
float layerY;

vec4 scalar2color(uint idx) {
	float fx = (float(idx) + 0.5) / textureWidth;
	vec4 clr = texture(colormap, vec2(fx, layerY)).rgba;
	if (clr.a > 0.0)
		clr.a = 1.0;
	clr.a *= opacity;
	return clr;
}
void main(void) {
	vec4 vx = vec4(TexCoord.x, TexCoord.y, coordZ, 1.0) * mtx;
	uint idx = uint(texture(intensityVol, vx.xyz).r);
	if (idx == uint(0)) {
		if (layer < 1.0) {
			FragColor = vec4(0.0, 0.0, 0.0, 0.0);
			return;
		}
		FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
		return;
	}
	textureWidth = float(textureSize(colormap, 0).x);
	nlayer = float(textureSize(colormap, 0).y);
	layerY = ((2.0 * layer) + 1.5) / nlayer;
	//idx = ((idx - uint(1)) % uint(100))+uint(1);
	FragColor = scalar2color(idx);
	bool isBorder = false;
	vx = vec4(TexCoord.x+xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;
	uint R = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x-xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;
	uint L = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x, TexCoord.y+xyzaFrac.y, coordZ, 1.0) * mtx;
	uint A = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x, TexCoord.y-xyzaFrac.y, coordZ, 1.0) * mtx;
	uint P = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x, TexCoord.y, coordZ+xyzaFrac.z, 1.0) * mtx;
	uint S = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x, TexCoord.y, coordZ-xyzaFrac.z, 1.0) * mtx;
	uint I = uint(texture(intensityVol, vx.xyz).r);
	vec4 centerColor = FragColor;
	FragColor.a += scalar2color(R).a;
	FragColor.a += scalar2color(L).a;
	FragColor.a += scalar2color(A).a;
	FragColor.a += scalar2color(P).a;
	FragColor.a += scalar2color(S).a;
	FragColor.a += scalar2color(I).a;
	FragColor.a /= 7.0;
	if ((!isBorder) &&(idx == activeIndex)) {
		if (centerColor.a > 0.5)
			FragColor.a *= 0.4;
		else
			FragColor.a =0.8;
	}
	if (xyzaFrac.a != 0.0) { //outline
		if ((idx != R) || (idx != L) || (idx != A) || (idx != P) || (idx != S) || (idx != I)) {
			isBorder = true;
			if (xyzaFrac.a > 0.0)
				FragColor.a = xyzaFrac.a;
			else
				FragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}
	if (layer < 1.0) return;
		vec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
		// https://en.wikipedia.org/wiki/Alpha_compositing
		float aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;
		if (aout <= 0.0) return;
		if (isAdditiveBlend)
			FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a)) / aout;
		else
			FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;
		FragColor.a = aout;
}`, Ki = `#line 691
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform float cal_maxNeg;
uniform float cal_minNeg;
uniform bool isAlphaThreshold;
uniform bool isColorbarFromZero;
uniform bool isAdditiveBlend;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform int modulation;
uniform highp sampler3D modulationVol;
uniform float opacity;
uniform mat4 mtx;
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	if ((vx.x < 0.0) || (vx.x > 1.0) || (vx.y < 0.0) || (vx.y > 1.0) || (vx.z < 0.0) || (vx.z > 1.0)) {
		//set transparent if out of range
		//https://webglfundamentals.org/webgl/webgl-3d-textures-repeat-clamp.html
		FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
		return;
	}
	float f = (scl_slope * float(texture(intensityVol, vx.xyz).r)) + scl_inter;
	float mn = cal_min;
	float mx = cal_max;
	if ((isAlphaThreshold) || (isColorbarFromZero))
		mn = 0.0;
	float r = max(0.00001, abs(mx - mn));
	mn = min(mn, mx);
	float txl = mix(0.0, 1.0, (f - mn) / r);
	if (f > mn) { //issue1139: survives threshold, so round up to opaque voxel
		txl = max(txl, 2.0/256.0);
	}
	//https://stackoverflow.com/questions/5879403/opengl-texture-coordinates-in-pixel-space
	float nlayer = float(textureSize(colormap, 0).y);
	//each volume has two color maps:
	// (layer*2) = negative and (layer * 2) + 1 = positive
	float y = ((2.0 * layer) + 1.5)/nlayer;
	FragColor = texture(colormap, vec2(txl, y)).rgba;
	//negative colors
	mn = cal_minNeg;
	mx = cal_maxNeg;
	if ((isAlphaThreshold) || (isColorbarFromZero))
		mx = 0.0;
	//if ((!isnan(cal_minNeg)) && ( f < mx)) {
	if ((cal_minNeg < cal_maxNeg) && ( f < mx)) {
		r = max(0.00001, abs(mx - mn));
		mn = min(mn, mx);
		txl = 1.0 - mix(0.0, 1.0, (f - mn) / r);
		//issue1139: survives threshold, so round up to opaque voxel
		txl = max(txl, 2.0/256.0);
		y = ((2.0 * layer) + 0.5)/nlayer;
		FragColor = texture(colormap, vec2(txl, y));
	}
	if (layer > 0.7)
		FragColor.a = step(0.00001, FragColor.a);
	//if (modulation > 10)
	//	FragColor.a *= texture(modulationVol, vx.xyz).r;
	//	FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	if (isAlphaThreshold) {
		if ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))
			FragColor.a = pow(-f / -cal_maxNeg, 2.0);
		else if ((f > 0.0) && (cal_min > 0.0))
			FragColor.a *= pow(f / cal_min, 2.0); //issue435:  A = (V/X)**2
		//FragColor.g = 0.0;
	} else if (isColorbarFromZero) {
		if ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))
			FragColor.a = 0.0;
		else if ((f > 0.0) && (cal_min > 0.0) && (f < cal_min))
			FragColor.a *= 0.0;

	}
	if (modulation == 1) {
		FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	} else if (modulation == 2) {
		FragColor.a = texture(modulationVol, vx.xyz).r;
	}
	FragColor.a *= opacity;
	if (layer < 1.0) return;
	vec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
	// https://en.wikipedia.org/wiki/Alpha_compositing
	float aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;
	if (aout <= 0.0) return;
	if (isAdditiveBlend)
		FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a)) / aout;
	else
		FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;
	FragColor.a = aout;
}`, Bc = `#line 773
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform mat4 mtx;
uniform bool hasAlpha;
uniform int modulation;
uniform highp sampler3D modulationVol;
float textureWidth;
float nlayer;
float layerY;

vec4 scalar2color(uint idx) {
	float fx = (float(idx) + 0.5) / textureWidth;
	vec4 clr = texture(colormap, vec2(fx, layerY)).rgba;
	if (clr.a > 0.0)
		clr.a = 1.0;
	clr.a *= opacity;
	return clr;
}

vec4 paqd2color(uvec4 rgba) {
  // paqd r: max prob index, g: 2nd index, b: max prob a: 2nd prob
  float prob1 = float(rgba.b)/255.0;
  float prob2 = float(rgba.a)/255.0;
  vec4 clr1 = scalar2color(rgba.r);
  vec4 clr2 = scalar2color(rgba.g);
  float total = prob1 + prob2;
  vec4 clr = vec4(clr1.rgb, total);
  // vec4 clr = vec4(clr1.rgb, prob1);
  if (total > 0.0) {
    clr.rgb = mix(clr2.rgb, clr1.rgb, prob1 / total);
  }
  return clr;
}
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	ivec3 voxelCoord = ivec3(vx.xyz * vec3(textureSize(intensityVol, 0)));
	uvec4 rgba = texelFetch(intensityVol, voxelCoord, 0);
	FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	if (rgba.r > uint(0)) {
		textureWidth = float(textureSize(colormap, 0).x);
		nlayer = float(textureSize(colormap, 0).y);
		layerY = ((2.0 * layer) + 1.5) / nlayer;
		FragColor = paqd2color(rgba);
		return;
	}
	// if (layer > 2.0) return;
	// FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
}`, Uc = `#line 773
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform mat4 mtx;
uniform bool hasAlpha;
uniform int modulation;
uniform highp sampler3D modulationVol;
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	uvec4 aColor = texture(intensityVol, vx.xyz);
	FragColor = vec4(float(aColor.r) / 255.0, float(aColor.g) / 255.0, float(aColor.b) / 255.0, float(aColor.a) / 255.0);
	if (modulation == 1)
		FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	if (!hasAlpha) {
		FragColor.a = (FragColor.r * 0.21 + FragColor.g * 0.72 + FragColor.b * 0.07);
		//next line: we could binarize alpha, but see rendering of visible human
		//FragColor.a = step(0.01, FragColor.a);
	}
	if (modulation == 2)
		FragColor.a = texture(modulationVol, vx.xyz).r;
	FragColor.a *= opacity;
	if (layer < 1.0) return;
	vec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
	// https://en.wikipedia.org/wiki/Alpha_compositing
	float aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;
	if (aout <= 0.0) return;
	FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;
	FragColor.a = aout;
}`, Rc = `#version 300 es
#line 808
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	gl_Position = vec4((vPos.x - 0.5) * 2.0, (vPos.y - 0.5) * 2.0, 0.0, 1.0);
}`, Pc = `#version 300 es
#line 829
	precision highp float;
	precision highp int;
	precision highp isampler3D;
	layout(location = 0) out int label;
	layout(location = 1) out int strength;
	in vec2 TexCoord;
	uniform int finalPass;
	uniform float coordZ;
	uniform lowp sampler3D in3D;
	uniform highp isampler3D backTex; // background
	uniform highp isampler3D labelTex; // label
	uniform highp isampler3D strengthTex; // strength
void main(void) {
	vec3 interpolatedTextureCoordinate = vec3(TexCoord.xy, coordZ);
	ivec3 size = textureSize(backTex, 0);
	ivec3 texelIndex = ivec3(floor(interpolatedTextureCoordinate * vec3(size)));
	int background = texelFetch(backTex, texelIndex, 0).r;
	label = texelFetch(labelTex, texelIndex, 0).r;
	strength = texelFetch(strengthTex, texelIndex, 0).r;
	for (int k = -1; k <= 1; k++) {
		for (int j = -1; j <= 1; j++) {
			for (int i = -1; i <= 1; i++) {
				if (i != 0 && j != 0 && k != 0) {
					ivec3 neighborIndex = texelIndex + ivec3(i,j,k);
					int neighborBackground = texelFetch(backTex, neighborIndex, 0).r;
					int neighborStrength = texelFetch(strengthTex, neighborIndex, 0).r;
					int strengthCost = abs(neighborBackground - background);
					int takeoverStrength = neighborStrength - strengthCost;
					if (takeoverStrength > strength) {
						strength = takeoverStrength;
						label = texelFetch(labelTex, neighborIndex, 0).r;
					}
				}
			}
		}
	}
	if (finalPass < 1)
		return;
	int ok = 1;
	ivec4 labelCount = ivec4(0,0,0,0);
	for (int k = -1; k <= 1; k++)
		for (int j = -1; j <= 1; j++)
			for (int i = -1; i <= 1; i++) {
				ivec3 neighborIndex = texelIndex + ivec3(i,j,k);
				int ilabel = texelFetch(labelTex, neighborIndex, 0).r;
				if ((ilabel < 0) || (ilabel > 3))
					ok = 0;
				else
					labelCount[ilabel]++;
			}
	if (ok != 1) {
		return;
	}
	int maxIdx = 0;
	for (int i = 1; i < 4; i++) {
		if (labelCount[i] > labelCount[maxIdx])
			maxIdx = i;
	}
	label = maxIdx;
}`, Nc = `#version 300 es
layout(location=0) in vec3 pos;
uniform mat4 mvpMtx;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
}`, Lc = `#version 300 es
precision highp int;
precision highp float;
uniform vec4 surfaceColor;
out vec4 color;
void main() {
	color = surfaceColor;
}`, kc = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 clr;
out vec4 vClr;
uniform mat4 mvpMtx;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vClr = clr;
}`, Oc = `#version 300 es
precision highp int;
precision highp float;
in vec4 vClr;
out vec4 color;
uniform float opacity;
void main() {
	color = vec4(vClr.rgb, opacity);
}`, Xi = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 norm;
layout(location=2) in vec4 clr;
uniform mat4 mvpMtx;
//uniform mat4 modelMtx;
uniform mat4 normMtx;
out vec4 vClr;
out vec3 vN;
out vec4 vP;
out vec4 vPc;
void main(void) {
	vec3 lightPosition = vec3(0.0, 0.0, -10.0);
	vP = vec4(pos, 1.0);
	vPc = mvpMtx * vec4(pos, 1.0);
	gl_Position = vPc;
	vN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);
	//vV = -vec3(modelMtx*vec4(pos,1.0));
	vClr = clr;
}`, zc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
out vec4 color;
vec4 packFloatToVec4i(const float value) {
	const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
	const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
	vec4 res = fract(value * bitSh);
	res -= res.xxyz * bitMsk;
	return res;
}
void main() {
	color = packFloatToVec4i(gl_FragCoord.z);
}`, Gc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
float stepmix(float edge0, float edge1, float E, float x){
	float T = clamp(0.5 * (x - edge0 + E) / E, 0.0, 1.0);
	return mix(edge0, edge1, T);
}
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0);
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.5;
	float shininess = 50.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float df = max(0.0, dot(n, l));
	float sf = pow(max(dot(reflect(l, n), r), 0.0), shininess);
	const float A = 0.1;
	const float B = 0.3;
	const float C = 0.6;
	const float D = 1.0;
	float E = fwidth(df);
	if (df > A - E && df < A + E) df = stepmix(A, B, E, df);
	else if (df > B - E && df < B + E) df = stepmix(B, C, E, df);
	else if (df > C - E && df < C + E) df = stepmix(C, D, E, df);
	else if (df < A) df = 0.0;
	else if (df < B) df = B;
	else if (df < C) df = C;
	else df = D;
	E = fwidth(sf);
	if (sf > 0.5 - E && sf < 0.5 + E)
		sf = smoothstep(0.5 - E, 0.5 + E, sf);
	else
		sf = step(0.5, sf);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(df, 0.0) * vClr.rgb * diffuse;
	color.rgb = a + d + (specular * sf);
	color.a = opacity;
}`, Yc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.25;
	float shininess = 10.0;
	float PenWidth = 0.6;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	float view = abs(dot(n,r)); //with respect to viewer
	if (PenWidth < view) discard;
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color.rgb = a + d + s;
	color.a = opacity;
}`, Wc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	const float thresh = 0.4;
	const vec3 viewDir = vec3(0.0, 0.0, -1.0);
	vec3 n = normalize(vN);
	// use abs() for two-sided lighting, max() for one sided
	float cosTheta = abs(dot(n, viewDir));
	// float cosTheta = max(dot(n, viewDir), 0.0);
	// optional fresnel equation - adjust exponent
	// cosTheta = 1.0 - pow(1.0 - cosTheta, 2.0);
	// use step for binary edges, smoothstep for feathered edges
	// vec3 d = step(thresh, cosTheta) * vClr.rgb;
	vec3 d = smoothstep(thresh - 0.05, thresh + 0.05, cosTheta) * vClr.rgb;
	color = vec4(d, opacity);
}`, Kc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
  const float edge0 = 0.1;
  const float edge1 = 0.25;
  const vec3 viewDir = vec3(0.0, 0.0, -1.0);
  vec3 n = normalize(vN);
  float cosTheta = abs(dot(n, viewDir));
  float alpha = 1.0 - smoothstep(edge0, edge1, cosTheta);
  if (alpha <= 0.0) {
    discard;
  }
  color = vec4(0.0, 0.0, 0.0, opacity * alpha);
}`, Xc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float diffuse = 1.0;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 0.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = max(dot(n, l), 0.0);
	vec3 d = lightNormDot * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(d + s, opacity);
}`, qc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float diffuse = 1.4;
	vec3 l = vec3(0.0, 0.0, -1.0);
	float lightNormDot = max(dot(normalize(vN), l), 0.0);
	color = vec4(lightNormDot * vClr.rgb * diffuse, opacity);
}`, Hc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float specularRGB = 0.7;
	float specularWhite = 0.3;
	float shininess = 10.0;
	float diffuse = 1.0;
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	vec3 n = normalize(vN);
	vec3 l = vec3(0.0, 0.0, -1.0);
	float lightNormDot = max(dot(n, l), 0.0);
	vec3 d3 = lightNormDot * vClr.rgb * diffuse;
	float s = pow(max(dot(reflect(l, n), r), 0.0), shininess);
	vec3 s3 = specularRGB * s * vClr.rgb;
	s *= specularWhite;
	color = vec4(d3 + s3 + s, opacity);
}`, _c = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
in vec4 vPc;
out vec4 color;
void main() {
	vec3 n = normalize(vN);
	// Compute curvature
	vec3 dx = dFdx(n);
	vec3 dy = dFdy(n);
	vec3 xneg = n - dx;
	vec3 xpos = n + dx;
	vec3 yneg = n - dy;
	vec3 ypos = n + dy;
	float depth = length(vPc.xyz);
	float curv = (cross(xneg, xpos).y - cross(yneg, ypos).x) / depth;
	//at this stage 0.5 for flat, with valleys dark and ridges bright
	curv = 1.0 - (curv + 0.5);
	//clamp
	curv =  min(max(curv, 0.0), 1.0);
	// easing function
	curv = pow(curv, 0.5);
	//modulate ambient and diffuse with curvature
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.6;
	float diffuse = 0.6;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 lightPosition = vec3(0.0, 10.0, -2.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient * curv;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`, Qc = `#version 300 es
precision highp int;
precision highp float;
uniform vec4 sliceMM;
uniform float thickMM ;
in vec4 vClr;
in vec4 vP;  // vertex position in mm
out vec4 color;
void main() {
    const float LINE_WIDTH_PX = 4.0;   // target thickness in pixels
    //const float LINE_THRESH_MM = 1.5;   // target thickness in pixels
    const float TILT_STRENGTH = 1.0;   // >0 shrinks ribbon for oblique triangles
    // --- signed distances to each orthogonal plane (object space) ---
    vec3 d = vP.xyz - sliceMM.xyz;
    vec3 ad = abs(d);
    // --- derivatives to get pixel-consistent widths (per-axis) ---
    vec3 fd = fwidth(vP.xyz);
    //minDist is in mm not pixels
    float minDist = min(ad.x, min(ad.y, ad.z));
    if (minDist >  sliceMM.w) discard;
    // --- per-plane obliqueness: use the two in-plane components' fwidth ---
    float tiltX = length(fd.yz); // for plane with normal X
    float tiltY = length(fd.xz); // for plane with normal Y
    float tiltZ = length(fd.xy); // for plane with normal Z
    float tfX = clamp(1.0 / (1.0 + TILT_STRENGTH * tiltX), 0.0, 1.0);
    float tfY = clamp(1.0 / (1.0 + TILT_STRENGTH * tiltY), 0.0, 1.0);
    float tfZ = clamp(1.0 / (1.0 + TILT_STRENGTH * tiltZ), 0.0, 1.0);
    // --- half-widths for each plane (apply per-axis tilt factor) ---
    vec3 halfWidth;
    halfWidth.x = (LINE_WIDTH_PX * 0.5) * fd.x * tfX;
    halfWidth.y = (LINE_WIDTH_PX * 0.5) * fd.y * tfY;
    halfWidth.z = (LINE_WIDTH_PX * 0.5) * fd.z * tfZ;
    // --- smooth alpha for each plane ---
    vec3 edgeA = 1.0 - smoothstep(vec3(0.0), halfWidth, ad);
    // combine planes (max of X,Y,Z ribbons)
    float edgeAlpha = max(edgeA.x, max(edgeA.y, edgeA.z));
    if (edgeAlpha <= 1e-4) discard; // outside ribbons
    color = vec4(vClr.rgb, vClr.a * edgeAlpha);
}`, jc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`, Zc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
uniform sampler2D matCap;
out vec4 color;
void main() {
	vec3 n = normalize(vN);
	vec2 uv = n.xy * 0.5 + 0.5;
	uv.y = 1.0 - uv.y;
	vec3 clr = texture(matCap,uv.xy).rgb * vClr.rgb;
	color = vec4(clr, opacity);
}`, Jc = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float ambient = 0.35;
	float diffuse = 0.6;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	color = vec4(a + d, opacity);
}`, $c = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 up = vec3(0.0, 1.0, 0.0);
	float ax = dot(n, up) * 0.5 + 0.5;  //Shreiner et al. (2013) OpenGL Programming Guide, 8th Ed., p 388. ISBN-10: 0321773039
	vec3 upClr = vec3(1.0, 1.0, 0.95);
	vec3 downClr = vec3(0.4, 0.4, 0.6);
	vec3 a = vClr.rgb * ambient;
	a *= mix(downClr, upClr, ax);
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`, th = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
//Spherical harmonics constants
const float C1 = 0.429043;
const float C2 = 0.511664;
const float C3 = 0.743125;
const float C4 = 0.886227;
const float C5 = 0.247708;
//Spherical harmonics coefficients
// Ramamoorthi, R., and P. Hanrahan. 2001b. "An Efficient Representation for Irradiance Environment Maps." In Proceedings of SIGGRAPH 2001, pp. 497500.
// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl
// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl
// Constants for Eucalyptus Grove lighting
const vec3 L00  = vec3( 0.3783264,  0.4260425,  0.4504587);
const vec3 L1m1 = vec3( 0.2887813,  0.3586803,  0.4147053);
const vec3 L10  = vec3( 0.0379030,  0.0295216,  0.0098567);
const vec3 L11  = vec3(-0.1033028, -0.1031690, -0.0884924);
const vec3 L2m2 = vec3(-0.0621750, -0.0554432, -0.0396779);
const vec3 L2m1 = vec3( 0.0077820, -0.0148312, -0.0471301);
const vec3 L20  = vec3(-0.0935561, -0.1254260, -0.1525629);
const vec3 L21  = vec3(-0.0572703, -0.0502192, -0.0363410);
const vec3 L22  = vec3( 0.0203348, -0.0044201, -0.0452180);
vec3 SH(vec3 vNormal) {
	vNormal = vec3(vNormal.x,vNormal.z,vNormal.y);
	vec3 diffuseColor = C1 * L22 * (vNormal.x * vNormal.x - vNormal.y * vNormal.y) +
	C3 * L20 * vNormal.z * vNormal.z +
	C4 * L00 -
	C5 * L20 +
	2.0 * C1 * L2m2 * vNormal.x * vNormal.y +
	2.0 * C1 * L21  * vNormal.x * vNormal.z +
	2.0 * C1 * L2m1 * vNormal.y * vNormal.z +
	2.0 * C2 * L11  * vNormal.x +
	2.0 * C2 * L1m1 * vNormal.y +
	2.0 * C2 * L10  * vNormal.z;
	return diffuseColor;
}
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.1;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	vec3 a = vClr.rgb * ambient;
	vec3 d = vClr.rgb * diffuse * SH(-reflect(n, vec3(l.x, l.y, -l.z)) );
	color = vec4(a + d + s, opacity);
}`, eh = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 norm;
layout(location=2) in vec4 clr;
uniform mat4 mvpMtx;
//uniform mat4 modelMtx;
uniform mat4 normMtx;
out vec4 vClr;
flat out vec3 vN;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);
	//vV = -vec3(modelMtx*vec4(pos,1.0));
	vClr = clr;
}`, mr = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
flat in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`, ih = `#version 300 es
#line 1260
#define MAX_CLIP_PLANES 6
//precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 volScale;
uniform vec3 texVox;
uniform vec4 clipPlane;
uniform vec4 clipPlanes[MAX_CLIP_PLANES];
uniform bool isClipCutaway;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform float overlays;
uniform mat4 matRAS;
uniform mat4 mvpMtx;
uniform float drawOpacity, renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform int backgroundMasksOverlays;
in vec3 vColor;
out vec4 fColor;
` + ti + `
void main() {
	int id = 254;
	vec3 start = vColor;
	gl_FragDepth = 1.0;
	fColor = vec4(0.0, 0.0, 0.0, 0.0); //assume no hit: ID = 0
	float fid = float(id & 255)/ 255.0;
	vec3 backPosition = GetBackPosition(start);
	vec3 dir = normalize(backPosition - start);
	//clipVolumeStart(start, backPosition);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) return;//discard; //length limit for parallel rays
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	dir = normalize(dir);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	bool hasClip = false;
	vec2 sampleRange = vec2(0.0, len);
	for (int i = 0; i < MAX_CLIP_PLANES; i++)
		clipSampleRange(dir, samplePos, clipPlanes[i], sampleRange, hasClip);
	bool isClip = (sampleRange.x > 0.0) || ((sampleRange.y < len) && (sampleRange.y > 0.0));
	//vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	if (isClip) fColor = vec4(samplePos.xyz, 253.0 / 255.0); //assume no hit: ID = 0
	if ((isClipCutaway) && (sampleRange.x <= 0.0) && (sampleRange.y >= len)) {
		//completely clipped, but ray does not intersect plane
		if (hasClip)
			samplePos.a = len + 1.0;
		else
			sampleRange = vec2(0.0, 0.0);
	}
	//start: OPTIONAL fast pass: rapid traversal until first hit
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		if (skipSample(samplePos.a, sampleRange) ^^ isClipCutaway) {
			samplePos += deltaDirFast;
			continue;
		}
		float val = texture(volume, samplePos.xyz).a;
		if (val > 0.01) {
			fColor = vec4(samplePos.rgb, fid);
			gl_FragDepth = frac2ndc(samplePos.xyz);
			break;
		}
		samplePos += deltaDirFast; //advance ray position
	}
	//end: fast pass
	if ((overlays < 1.0) || (backgroundMasksOverlays > 0)) {
		return; //background hit, no overlays
	}
	//overlay pass
	len = min(len, samplePos.a); //only find overlay closer than background
	samplePos = vec4(start.xyz, 0.0); //ray position
	while (samplePos.a <= len) {
		float val = texture(overlay, samplePos.xyz).a;
		if (val > 0.01) {
			fColor = vec4(samplePos.rgb, fid);
			gl_FragDepth = frac2ndc(samplePos.xyz);
			return;
		}
		samplePos += deltaDirFast; //advance ray position
	}
	//if (fColor.a == 0.0) discard; //no hit in either background or overlays
	//you only get here if there is a hit with the background that is closer than any overlay
}`, sh = `#version 300 es
// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
layout(location=0)  in vec3 a_position;
layout(location=1)  in vec3 a_color;
// A matrix to transform the positions by
uniform mat4 u_matrix;
out vec3 vColor;
// all shaders have a main function
void main() {
	// Multiply the position by the matrix.
	vec4 pos = vec4(a_position, 1.0);
	gl_Position = u_matrix * vec4(pos);
	vColor = a_color;
}
`, rh = `#version 300 es
precision highp float;
uniform vec4 u_color;
in vec3 vColor;
out vec4 outColor;
void main() {
	outColor = vec4(vColor, 1.0);
}`, nh = `#version 300 es
#line 1359
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	vec2 viewCoord = (vPos.xy - 0.5) * 2.0;
	gl_Position = vec4((vPos.xy - 0.5) * 2.0, 0.0, 1.0);
}`, ah = `#version 300 es
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform lowp sampler3D in3D;
void main(void) {
 FragColor = texture(in3D, vec3(TexCoord.xy, coordZ));
}`, hi = `#version 300 es
#line 286
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
    TexCoord = vPos.xy;
    gl_Position = vec4( (vPos.xy-vec2(0.5,0.5))* 2.0, 0.0, 1.0);
}`, oh = `#version 300 es
#line 298
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
 vec3 vx = vec3(TexCoord.xy, coordZ);
 vec4 samp = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
 samp += texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
 samp += texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
 samp += texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
 samp += texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
 samp += texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
 samp += texture(intensityVol,vx+vec3(-dX,-dY,+dZ));
 samp += texture(intensityVol,vx+vec3(-dX,-dY,-dZ));
 FragColor = samp*0.125;
}`, lh = `#version 300 es
#line 298
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
 vec3 vx = vec3(TexCoord.xy, coordZ);
 vec4 XYZ = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
 vec4 OYZ = texture(intensityVol,vx+vec3(0.0,+dY,+dZ));
 vec4 xYZ = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
 vec4 XOZ = texture(intensityVol,vx+vec3(+dX,0.0,+dZ));
 vec4 OOZ = texture(intensityVol,vx+vec3(0.0,0.0,+dZ));
 vec4 xOZ = texture(intensityVol,vx+vec3(-dX,0.0,+dZ));
 vec4 XyZ = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
 vec4 OyZ = texture(intensityVol,vx+vec3(0.0,-dY,+dZ));
 vec4 xyZ = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));

 vec4 XYO = texture(intensityVol,vx+vec3(+dX,+dY,0.0));
 vec4 OYO = texture(intensityVol,vx+vec3(0.0,+dY,0.0));
 vec4 xYO = texture(intensityVol,vx+vec3(-dX,+dY,0.0));
 vec4 XOO = texture(intensityVol,vx+vec3(+dX,0.0,0.0));
 vec4 OOO = texture(intensityVol,vx+vec3(0.0,0.0,0.0));
 vec4 xOO = texture(intensityVol,vx+vec3(-dX,0.0,0.0));
 vec4 XyO = texture(intensityVol,vx+vec3(+dX,-dY,0.0));
 vec4 OyO = texture(intensityVol,vx+vec3(0.0,-dY,0.0));
 vec4 xyO = texture(intensityVol,vx+vec3(-dX,-dY,0.0));

 vec4 XYz = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
 vec4 OYz = texture(intensityVol,vx+vec3(0.0,+dY,-dZ));
 vec4 xYz = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
 vec4 XOz = texture(intensityVol,vx+vec3(+dX,0.0,-dZ));
 vec4 OOz = texture(intensityVol,vx+vec3(0.0,0.0,-dZ));
 vec4 xOz = texture(intensityVol,vx+vec3(-dX,0.0,-dZ));
 vec4 Xyz = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
 vec4 Oyz = texture(intensityVol,vx+vec3(0.0,-dY,-dZ));
 vec4 xyz = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));

 vec4 blurred = vec4 (0.0, 0.0, 0.0, 0.0);
 blurred.r = 2.0*(xOz.r +xOZ.r +xyO.r +xYO.r +xOO.r +XOz.r +XOZ.r +XyO.r +XYO.r +XOO.r) +xyz.r +xyZ.r +xYz.r +xYZ.r +Xyz.r +XyZ.r +XYz.r +XYZ.r;
 blurred.g = 2.0*(Oyz.r +OyZ.r +xyO.r +XyO.r +OyO.r +OYz.r +OYZ.r +xYO.r +XYO.r +OYO.r) +xyz.r +Xyz.r +xyZ.r +XyZ.r +xYz.r +XYz.r +xYZ.r +XYZ.r;
 blurred.b = 2.0*(Oyz.r +OYz.r +xOz.r +XOz.r +OOz.r +OyZ.r +OYZ.r +xOZ.r +XOZ.r +OOZ.r) +xyz.r +Xyz.r +xYz.r +XYz.r +xyZ.r +XyZ.r +XyZ.r +XYZ.r;
 blurred.a = 0.32*(abs(blurred.r)+abs(blurred.g)+abs(blurred.b));
 // 0.0357 = 1/28 to account for weights, rescale to 2**16,
 FragColor = 0.0357*blurred;
}`, vn = `
  gradientSample.a = log2(gradientSample.r*gradientSample.r + gradientSample.g*gradientSample.g + gradientSample.b*gradientSample.b + 1.922337562475971e-06) + 18.988706873717717;
`, ch = `#version 300 es
#line 323
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
  vec3 vx = vec3(TexCoord.xy, coordZ);
  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft
  float TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ)).r;
  float TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ)).r;
  float TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ)).r;
  float TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ)).r;
  float BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ)).r;
  float BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ)).r;
  float BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ)).r;
  float BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ)).r;
  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);
  gradientSample.r = BAR+BAL+BPR+BPL -TAR-TAL-TPR-TPL;
  gradientSample.g = TPR+TPL+BPR+BPL -TAR-TAL-BAR-BAL;
  gradientSample.b = TAL+TPL+BAL+BPL -TAR-TPR-BAR-BPR;
${vn}
	// 0.04242020977371934 = 1/(log2(3*8) - log2(1/(255**2*8))) // 3*8 -> max for 1st order gradient
	gradientSample.a *= 0.04242020977371934;
  gradientSample.rgb = normalize(gradientSample.rgb);
  gradientSample.rgb = (gradientSample.rgb * 0.5)+0.5;
  FragColor = gradientSample;
}`, hh = `#version 300 es
#line 323
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform float dX2;
uniform float dY2;
uniform float dZ2;
uniform highp sampler3D intensityVol;
void main(void) {
  vec3 vx = vec3(TexCoord.xy, coordZ);
  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft
  vec4 TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
  vec4 TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
  vec4 TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
  vec4 TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
  vec4 BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
  vec4 BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
  vec4 BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));
  vec4 BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));
  vec4 T = texture(intensityVol,vx+vec3(+dX2,0.0,0.0));
  vec4 A = texture(intensityVol,vx+vec3(0.0,+dY2,0.0));
  vec4 R = texture(intensityVol,vx+vec3(0.0,0.0,+dZ2));
  vec4 B = texture(intensityVol,vx+vec3(-dX2,0.0,0.0));
  vec4 P = texture(intensityVol,vx+vec3(0.0,-dY2,0.0));
  vec4 L = texture(intensityVol,vx+vec3(0.0,0.0,-dZ2));
  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);
  gradientSample.r = -4.0*B.r +8.0*(BAR.r+BAL.r+BPR.r+BPL.r) -8.0*(TAR.r+TAL.r+TPR.r+TPL.r) +4.0*T.r;
  gradientSample.g = -4.0*P.g +8.0*(TPR.g+TPL.g+BPR.g+BPL.g) -8.0*(TAR.g+TAL.g+BAR.g+BAL.g) +4.0*A.g;
  gradientSample.b = -4.0*L.b +8.0*(TAL.b+TPL.b+BAL.b+BPL.b) -8.0*(TAR.b+TPR.b+BAR.b+BPR.b) +4.0*R.b;
${vn}
	gradientSample.a *= 0.0325;
  gradientSample.rgb = normalize(gradientSample.rgb);
  gradientSample.rgb =  (gradientSample.rgb * 0.5)+0.5;
  FragColor = gradientSample;
}`, fh = function(e, t, i) {
  const s = e.createShader(e.VERTEX_SHADER);
  e.shaderSource(s, t), e.compileShader(s);
  const r = e.createShader(e.FRAGMENT_SHADER);
  e.shaderSource(r, i), e.compileShader(r);
  const a = e.createProgram();
  if (e.attachShader(a, s), e.attachShader(a, r), e.linkProgram(a), !e.getProgramParameter(a, e.LINK_STATUS))
    throw console.log(e.getProgramInfoLog(a)), e.getShaderParameter(s, e.COMPILE_STATUS) || console.log("Vertex shader compilation error:", e.getShaderInfoLog(s)), e.getShaderParameter(r, e.COMPILE_STATUS) || console.log("Fragment shader compilation error:", e.getShaderInfoLog(r)), V.error(e.getProgramInfoLog(a)), new Error("Shader failed to link, see console for log");
  return a;
}, et = class {
  constructor(e, t, i) {
    I(this, "program"), I(this, "uniforms", {}), I(this, "isMatcap"), I(this, "isCrosscut"), this.program = fh(e, t, i);
    const s = /uniform[^;]+[ ](\w+);/g, r = /uniform[^;]+[ ](\w+);/, a = t.match(s), n = i.match(s);
    a && a.forEach((o) => {
      const l = o.match(r);
      this.uniforms[l[1]] = -1;
    }), n && n.forEach((o) => {
      const l = o.match(r);
      this.uniforms[l[1]] = -1;
    });
    for (const o in this.uniforms)
      this.uniforms[o] = e.getUniformLocation(this.program, o);
  }
  use(e) {
    e.useProgram(this.program);
  }
}, gr = (e, t) => {
  const i = Math.floor(Math.log(e) / Math.log(10)), s = e / Math.pow(10, i);
  let r;
  return t ? s < 1.5 ? r = 1 : s < 3 ? r = 2 : s < 7 ? r = 5 : r = 10 : s <= 1 ? r = 1 : s <= 2 ? r = 2 : s <= 5 ? r = 5 : r = 10, r * Math.pow(10, i);
};
function dh(e) {
  return new Promise((t, i) => {
    let s;
    e instanceof File ? s = Promise.resolve(e) : s = new Promise((r, a) => {
      e.file(r, a);
    }), s.then((r) => {
      const a = new FileReader();
      a.onload = () => {
        typeof a.result == "string" ? t(a.result) : i(new Error("Expected a string from FileReader.result"));
      }, a.onerror = () => {
        i(a.error ?? new Error("Unknown FileReader error"));
      }, a.readAsDataURL(r);
    }).catch((r) => i(r));
  });
}
function uh(e) {
  const t = e.hdr.dims, i = e.permRAS, s = t[1] * t[2] * t[3], r = new Int16Array(s), a = [0, 0, 0];
  for (let u = 0; u < 3; u++)
    for (let m = 0; m < 3; m++)
      Math.abs(i[u]) - 1 === m && (a[m] = u * Math.sign(i[u]));
  let n = 1;
  const o = [1, 1, 1], l = [!1, !1, !1];
  for (let u = 0; u < a.length; u++)
    for (let m = 0; m < a.length; m++)
      Math.abs(a[m]) === u && (o[m] = n, (a[m] < 0 || Object.is(a[m], -0)) && (l[m] = !0), n *= t[m + 1]);
  let c = H.range(0, t[1] - 1, 1);
  l[0] && (c = H.range(t[1] - 1, 0, -1));
  for (let u = 0; u < t[1]; u++)
    c[u] *= o[0];
  let h = H.range(0, t[2] - 1, 1);
  l[1] && (h = H.range(t[2] - 1, 0, -1));
  for (let u = 0; u < t[2]; u++)
    h[u] *= o[1];
  let f = H.range(0, t[3] - 1, 1);
  l[2] && (f = H.range(t[3] - 1, 0, -1));
  for (let u = 0; u < t[3]; u++)
    f[u] *= o[2];
  let d = 0;
  for (let u = 0; u < t[3]; u++)
    for (let m = 0; m < t[2]; m++)
      for (let g = 0; g < t[1]; g++)
        r[c[g] + h[m] + f[u]] = e.img[d], d++;
  return r;
}
function mh(e) {
  const t = [5960464477539063e-23, 152587890625e-16, 390625e-8, 1];
  return (e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]) / 255;
}
function pr(e, t) {
  return e.scl_slope === 0 && (e.scl_slope = 1), t * e.scl_slope + e.scl_inter;
}
function Ee(e, t, i = 4) {
  const s = gr(t - e, !1), r = gr(s / (i - 1), !0), a = Math.floor(e / r) * r, n = Math.ceil(t / r) * r;
  return [r, a, n, a === e && n === t];
}
function Ar(e, t) {
  let i = Ee(e, t, 3);
  return i[3] || (i = Ee(e, t, 5)), i[3] || (i = Ee(e, t, 4)), i[3] || (i = Ee(e, t, 3)), i[3] || (i = Ee(e, t, 5)), [i[0], i[1], i[2]];
}
function Xt(e) {
  return e * (Math.PI / 180);
}
function qi(e, t, i, s) {
  let r = -e, a = -t;
  return isFinite(i) && isFinite(s) && (r = i, a = s), r > a && ([r, a] = [a, r]), [r, a];
}
function Hi(e, t, i) {
  return Math.min(Math.max(e, t), i);
}
function dt(e, t = [0, 1, 2]) {
  const i = nt();
  return i[0] = e[t[0]], i[1] = e[t[1]], i[2] = e[t[2]], i;
}
function gh(e) {
  const t = ht(1, 0, 0, 0), i = Wt();
  return Ct(i, t, e), i[0];
}
function ph(e, t, i, s) {
  const r = ht(e, t, i, 1), a = mt(s);
  Vt(a, a), r[0] = r[0] * 2 - 1, r[1] = r[1] * 2 - 1, r[2] = r[2] * 2 - 1;
  const n = Wt();
  return Ct(n, r, a), n[3] === 0 || (n[0] /= n[3], n[1] /= n[3], n[2] /= n[3]), n;
}
var { version: xr } = Fo, ee = [
  "ASC",
  "BYU",
  "DFS",
  "FSM",
  "PIAL",
  "ORIG",
  "INFLATED",
  "SMOOTHWM",
  "SPHERE",
  "WHITE",
  "G",
  "GEO",
  "GII",
  "ICO",
  "MZ3",
  "NV",
  "OBJ",
  "OFF",
  "PLY",
  "SRF",
  "STL",
  "TCK",
  "TRACT",
  "TRI",
  "TRK",
  "TT",
  "TRX",
  "VTK",
  "WRL",
  "X3D",
  "JCON",
  "JSON"
], De = 0, _i = 1, Qi = 2, ie = 33984, Se = 33985, fi = 33986, vr = 33987, Ah = 33988, ji = 33989, di = 33990, qt = 33991, ue = 33992, wr = 33992, br = 33993, yr = 33994, xh = 33995, vh = 33996, wh = 33997, bh = 33998, yh = 33999, Cr = {
  filename: "",
  isSaveDrawing: !1,
  volumeByIndex: 0
}, se, Ch = class {
  /**
   * @param options  - options object to set modifiable Niivue properties
   */
  constructor(e = kt) {
    I(this, "loaders", {}), I(this, "dicomLoader", null), I(this, "canvas", null), I(this, "_gl", null), I(this, "isBusy", !1), I(this, "needsRefresh", !1), I(this, "colormapTexture", null), I(this, "colormapLists", []), I(this, "volumeTexture", null), I(this, "gradientTexture", null), I(this, "gradientTextureAmount", 0), I(this, "useCustomGradientTexture", !1), I(this, "renderGradientValues", !1), I(this, "drawTexture", null), I(this, "paqdTexture", null), I(this, "drawUndoBitmaps", []), I(this, "drawLut", rt.makeDrawLut("$itksnap")), I(this, "drawOpacity", 0.8), I(this, "drawRimOpacity", -1), I(this, "clickToSegmentIsGrowing", !1), I(this, "clickToSegmentGrowingBitmap", null), I(this, "clickToSegmentXY", [0, 0]), I(this, "renderDrawAmbientOcclusion", 0.4), I(this, "colorbarHeight", 0), I(this, "drawPenLocation", [NaN, NaN, NaN]), I(this, "drawPenAxCorSag", -1), I(this, "drawFillOverwrites", !0), I(this, "drawPenFillPts", []), I(this, "drawShapeStartLocation", [NaN, NaN, NaN]), I(this, "drawShapePreviewBitmap", null), I(this, "overlayTexture", null), I(this, "overlayTextureID", null), I(this, "sliceMMShader"), I(this, "slice2DShader"), I(this, "sliceV1Shader"), I(this, "orientCubeShader"), I(this, "orientCubeShaderVAO", null), I(this, "rectShader"), I(this, "rectOutlineShader"), I(this, "renderShader"), I(this, "lineShader"), I(this, "line3DShader"), I(this, "passThroughShader"), I(this, "renderGradientShader"), I(this, "renderGradientValuesShader"), I(this, "renderSliceShader"), I(this, "renderVolumeShader"), I(this, "pickingMeshShader"), I(this, "pickingImageShader"), I(this, "colorbarShader"), I(this, "customSliceShader", null), I(this, "fontShader", null), I(this, "fiberShader"), I(this, "fontTexture", null), I(this, "circleShader"), I(this, "matCapTexture", null), I(this, "bmpShader", null), I(this, "bmpTexture", null), I(this, "thumbnailVisible", !1), I(this, "bmpTextureWH", 1), I(this, "growCutShader"), I(this, "orientShaderAtlasU", null), I(this, "orientShaderAtlasI", null), I(this, "orientShaderU", null), I(this, "orientShaderI", null), I(this, "orientShaderF", null), I(this, "orientShaderRGBU", null), I(this, "orientShaderPAQD", null), I(this, "surfaceShader", null), I(this, "blurShader", null), I(this, "sobelBlurShader", null), I(this, "sobelFirstOrderShader", null), I(this, "sobelSecondOrderShader", null), I(this, "genericVAO", null), I(this, "unusedVAO", null), I(this, "crosshairs3D", null), I(this, "DEFAULT_FONT_GLYPH_SHEET", lr), I(this, "DEFAULT_FONT_METRICS", cr), I(this, "fontMetrics"), I(this, "fontMets", null), I(this, "fontPx", 12), I(this, "legendFontScaling", 1), I(this, "backgroundMasksOverlays", 0), I(this, "overlayOutlineWidth", 0), I(this, "overlayAlphaShader", 1), I(this, "position"), I(this, "extentsMin"), I(this, "extentsMax"), I(this, "resizeObserver", null), I(this, "resizeEventListener", null), I(this, "canvasObserver", null), I(this, "syncOpts", {
      "3d": !1,
      // legacy option
      "2d": !1,
      // legacy option
      zoomPan: !1,
      cal_min: !1,
      cal_max: !1,
      clipPlane: !1,
      gamma: !1,
      sliceType: !1,
      crosshair: !1
    }), I(this, "readyForSync", !1), I(this, "uiData", {
      mousedown: !1,
      touchdown: !1,
      mouseButtonLeftDown: !1,
      mouseButtonCenterDown: !1,
      mouseButtonRightDown: !1,
      mouseDepthPicker: !1,
      clickedTile: -1,
      pan2DxyzmmAtMouseDown: [0, 0, 0, 1],
      prevX: 0,
      prevY: 0,
      currX: 0,
      currY: 0,
      currentTouchTime: 0,
      lastTouchTime: 0,
      touchTimer: null,
      doubleTouch: !1,
      isDragging: !1,
      dragStart: [0, 0],
      dragEnd: [0, 0],
      dragClipPlaneStartDepthAziElev: [0, 0, 0],
      lastTwoTouchDistance: 0,
      multiTouchGesture: !1,
      windowX: 0,
      windowY: 0,
      activeDragMode: null,
      activeDragButton: null,
      angleFirstLine: [0, 0, 0, 0],
      angleState: "none",
      activeClipPlaneIndex: 0
    }), ge(this, se, null), I(this, "back", null), I(this, "overlays", []), I(this, "deferredVolumes", []), I(this, "deferredMeshes", []), I(this, "furthestVertexFromOrigin", 100), I(this, "volScale", []), I(this, "vox", []), I(this, "mousePos", [0, 0]), I(this, "screenSlices", []), I(this, "cuboidVertexBuffer"), I(this, "otherNV", null), I(this, "volumeObject3D", null), I(this, "pivot3D", [0, 0, 0]), I(this, "furthestFromPivot", 10), I(this, "currentClipPlaneIndex", 0), I(this, "lastCalled", (/* @__PURE__ */ new Date()).getTime()), I(this, "selectedObjectId", -1), I(this, "CLIP_PLANE_ID", 1), I(this, "VOLUME_ID", 254), I(this, "DISTANCE_FROM_CAMERA", -0.54), I(this, "graph", {
      LTWH: [0, 0, 640, 480],
      opacity: 0,
      vols: [0],
      // e.g. timeline for background volume only, e.g. [0,2] for first and third volumes
      autoSizeMultiplanar: !1,
      normalizeValues: !1,
      isRangeCalMinMax: !1
    }), I(this, "customLayout", []), I(this, "meshShaders", [
      {
        Name: "Phong",
        Frag: jc
      },
      {
        Name: "Matte",
        Frag: Jc
      },
      {
        Name: "Harmonic",
        Frag: th
      },
      {
        Name: "Hemispheric",
        Frag: $c
      },
      {
        Name: "Crevice",
        Frag: _c
      },
      {
        Name: "Edge",
        Frag: Xc
      },
      {
        Name: "Diffuse",
        Frag: qc
      },
      {
        Name: "Outline",
        Frag: Yc
      },
      {
        Name: "Specular",
        Frag: Hc
      },
      {
        Name: "Toon",
        Frag: Gc
      },
      {
        Name: "Flat",
        Frag: mr
      },
      {
        Name: "Matcap",
        Frag: Zc
      },
      {
        Name: "Rim",
        Frag: Wc
      },
      {
        Name: "Silhouette",
        Frag: Kc
      },
      {
        Name: "Crosscut",
        Frag: Qc
      }
    ]), I(this, "dragModes", {
      contrast: 1,
      measurement: 2,
      angle: 7,
      none: 0,
      pan: 3,
      slicer3D: 4,
      callbackOnly: 5
      /* callbackOnly */
    }), I(
      this,
      "sliceTypeAxial",
      0
      /* AXIAL */
    ), I(
      this,
      "sliceTypeCoronal",
      1
      /* CORONAL */
    ), I(
      this,
      "sliceTypeSagittal",
      2
      /* SAGITTAL */
    ), I(
      this,
      "sliceTypeMultiplanar",
      3
      /* MULTIPLANAR */
    ), I(
      this,
      "sliceTypeRender",
      4
      /* RENDER */
    ), I(this, "onDragRelease", () => {
    }), I(this, "onMouseUp", () => {
    }), I(this, "onLocationChange", () => {
    }), I(this, "onIntensityChange", () => {
    }), I(this, "onClickToSegment", () => {
    }), I(this, "onImageLoaded", () => {
    }), I(this, "onMeshLoaded", () => {
    }), I(this, "onFrameChange", () => {
    }), I(this, "onError", () => {
    }), I(this, "onColormapChange", () => {
    }), I(this, "onInfo", () => {
    }), I(this, "onWarn", () => {
    }), I(this, "onDebug", () => {
    }), I(this, "onVolumeAddedFromUrl", () => {
    }), I(this, "onVolumeWithUrlRemoved", () => {
    }), I(this, "onVolumeUpdated", () => {
    }), I(this, "onMeshAddedFromUrl", () => {
    }), I(this, "onMeshAdded", () => {
    }), I(this, "onMeshWithUrlRemoved", () => {
    }), I(this, "onZoom3DChange", () => {
    }), I(this, "onAzimuthElevationChange", () => {
    }), I(this, "onClipPlaneChange", () => {
    }), I(this, "onCustomMeshShaderAdded", () => {
    }), I(this, "onMeshShaderChanged", () => {
    }), I(this, "onMeshPropertyChanged", () => {
    }), I(this, "onDicomLoaderFinishedWithImages", () => {
    }), I(this, "onDocumentLoaded", () => {
    }), I(this, "onOptsChange", () => {
    }), I(this, "document", new zi()), I(this, "mediaUrlMap", /* @__PURE__ */ new Map()), I(this, "initialized", !1), I(this, "currentDrawUndoBitmap");
    for (const t in e)
      typeof e[t] == "function" ? this[t] = e[t] : this.opts[t] = kt[t] === void 0 ? kt[t] : e[t];
    this.opts.forceDevicePixelRatio === 0 ? this.uiData.dpr = window.devicePixelRatio || 1 : this.opts.forceDevicePixelRatio < 0 ? this.uiData.dpr = 1 : this.uiData.dpr = this.opts.forceDevicePixelRatio, this.currentDrawUndoBitmap = this.opts.maxDrawUndoBitmaps, this.opts.drawingEnabled && this.createEmptyDrawing(), this.opts.thumbnail.length > 0 && (this.thumbnailVisible = !0), V.setLogLevel(this.opts.logLevel), this.document.setOptsChangeCallback((t, i, s) => {
      this.onOptsChange(t, i, s);
    });
  }
  /** Get the current scene configuration. */
  get scene() {
    return this.document.scene;
  }
  /** Get the current visualization options. */
  get opts() {
    return this.document.opts;
  }
  /** Get the slice mosaic layout string. */
  get sliceMosaicString() {
    return this.document.opts.sliceMosaicString || "";
  }
  /** Set the slice mosaic layout string. */
  set sliceMosaicString(e) {
    this.document.opts.sliceMosaicString = e;
  }
  /**
   * Get whether voxels below minimum intensity are drawn as dark or transparent.
   * @returns {boolean} True if dark voxels are opaque, false if transparent.
   */
  get isAlphaClipDark() {
    return this.document.opts.isAlphaClipDark;
  }
  /**
   * Set whether voxels below minimum intensity are drawn as dark or transparent.
   * @param {boolean} newVal - True to make dark voxels opaque, false for transparent.
   * @see {@link https://niivue.com/demos/features/segment.html | live demo usage}
   */
  set isAlphaClipDark(e) {
    this.document.opts.isAlphaClipDark = e;
  }
  /**
   * Clean up event listeners and observers
   * Call this when the Niivue instance is no longer needed.
   * This will be called when the canvas is detached from the DOM
   * @example niivue.cleanup();
   */
  cleanup() {
    this.resizeEventListener && (window.removeEventListener("resize", this.resizeEventListener), this.resizeEventListener = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.canvasObserver && (this.canvasObserver.disconnect(), this.canvasObserver = null), X(this, se) && (X(this, se).abort(), _t(this, se, null)), this.document.removeOptsChangeCallback();
  }
  get volumes() {
    return this.document.volumes;
  }
  set volumes(e) {
    this.document.volumes = e;
  }
  get meshes() {
    return this.document.meshes;
  }
  set meshes(e) {
    this.document.meshes = e;
  }
  get drawBitmap() {
    return this.document.drawBitmap;
  }
  set drawBitmap(e) {
    this.document.drawBitmap = e;
  }
  get volScaleMultiplier() {
    return this.scene.volScaleMultiplier;
  }
  set volScaleMultiplier(e) {
    this.setScale(e);
  }
  /**
   * save webgl2 canvas as png format bitmap
   * @param filename - filename for screen capture
   * @example niivue.saveScene('test.png');
   * @see {@link https://niivue.com/demos/features/ui.html | live demo usage}
   */
  async saveScene(e = "niivue.png") {
    function t(s, r) {
      const a = document.createElement("a");
      document.body.appendChild(a), a.style.display = "none";
      const n = window.URL.createObjectURL(s);
      a.href = n, a.download = r, a.click(), a.remove();
    }
    const i = this.canvas;
    if (!i)
      throw new Error("canvas not defined");
    this.drawScene(), i.toBlob((s) => {
      s && (e === "" && (e = `niivue-screenshot-${(/* @__PURE__ */ new Date()).toString()}.png`, e = e.replace(/\s/g, "_")), t(s, e));
    });
  }
  /**
   * attach the Niivue instance to the webgl2 canvas by element id
   * @param id - the id of an html canvas element
   * @param isAntiAlias - determines if anti-aliasing is requested (if not specified, AA usage depends on hardware)
   * @example niivue = new Niivue().attachTo('gl')
   * @example await niivue.attachTo('gl')
   * @see {@link https://niivue.com/demos/features/basic.multiplanar.html | live demo usage}
   */
  async attachTo(e, t = null) {
    return await this.attachToCanvas(document.getElementById(e), t), V.debug("attached to element with id: ", e), this;
  }
  /**
   * attach the Niivue instance to a canvas element directly
   * @param canvas - the canvas element reference
   * @example
   * niivue = new Niivue()
   * await niivue.attachToCanvas(document.getElementById(id))
   * @see {@link https://niivue.com/demos/features/dsistudio.html | live demo usage}
   */
  async attachToCanvas(e, t = null) {
    return this.canvas = e, t === null && (t = navigator.hardwareConcurrency > 6, V.debug("AntiAlias ", t, " Threads ", navigator.hardwareConcurrency)), this.gl = this.canvas.getContext("webgl2", {
      alpha: !0,
      antialias: t
    }), this.uiData.max2D = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE), this.uiData.max3D = this.gl.getParameter(this.gl.MAX_3D_TEXTURE_SIZE), V.info("NIIVUE VERSION ", xr), V.debug(`Max texture size 2D: ${this.uiData.max2D} 3D: ${this.uiData.max3D}`), this.canvas.parentElement.style.backgroundColor = "black", this.opts.isResizeCanvas && (this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.display = "block", this.canvas.width = this.canvas.offsetWidth, this.canvas.height = this.canvas.offsetHeight, this.resizeEventListener = () => {
      requestAnimationFrame(() => {
        this.resizeListener();
      });
    }, window.addEventListener("resize", this.resizeEventListener), this.resizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        this.resizeListener();
      });
    }), this.resizeObserver.observe(this.canvas.parentElement), this.canvasObserver = new MutationObserver((i) => {
      for (const s of i)
        if (s.type === "childList" && s.removedNodes.length > 0 && Array.from(s.removedNodes).includes(this.canvas)) {
          this.cleanup();
          break;
        }
    }), this.canvasObserver.observe(this.canvas.parentElement, { childList: !0 })), this.opts.interactive && this.registerInteractions(), await this.init(), this.drawScene(), this;
  }
  /**
   * Sync the scene controls (orientation, crosshair location, etc.) from one Niivue instance to another. useful for using one canvas to drive another.
   * @param otherNV - the other Niivue instance that is the main controller
   * @example
   * niivue1 = new Niivue()
   * niivue2 = new Niivue()
   * niivue2.syncWith(niivue1)
   * @deprecated use broadcastTo instead
   * @see {@link https://niivue.com/demos/features/sync.mesh.html | live demo usage}
   */
  syncWith(e, t = { "2d": !0, "3d": !0 }) {
    e instanceof Array || (e = [e]), this.otherNV = e, this.syncOpts = { ...t };
  }
  /**
   * Sync the scene controls (orientation, crosshair location, etc.) from one Niivue instance to others. useful for using one canvas to drive another.
   * @param otherNV - the other Niivue instance(s)
   * @example
   * niivue1 = new Niivue()
   * niivue2 = new Niivue()
   * niivue3 = new Niivue()
   * niivue1.broadcastTo(niivue2)
   * niivue1.broadcastTo([niivue2, niivue3])
   * @see {@link https://niivue.com/demos/features/sync.mesh.html | live demo usage}
   */
  broadcastTo(e, t = { "2d": !0, "3d": !0 }) {
    e instanceof Array || (e = [e]), this.otherNV = e, this.syncOpts = t;
  }
  /**
   * Synchronizes 3D view settings (azimuth, elevation, scale) with another Niivue instance.
   * @internal
   */
  doSync3d(e) {
    e.scene.renderAzimuth = this.scene.renderAzimuth, e.scene.renderElevation = this.scene.renderElevation, e.scene.volScaleMultiplier = this.scene.volScaleMultiplier;
  }
  /**
   * Synchronizes 2D crosshair position and pan settings with another Niivue instance.
   * @internal
   */
  doSync2d(e) {
    const t = this.frac2mm(this.scene.crosshairPos);
    e.scene.crosshairPos = e.mm2frac(t), e.scene.pan2Dxyzmm = Zt(this.scene.pan2Dxyzmm);
  }
  doSyncGamma(e) {
    const t = this.scene.gamma, i = e.scene.gamma;
    t !== i && e.setGamma(t);
  }
  /**
   * Synchronizes gamma correction setting with another Niivue instance.
   * @internal
   */
  doSyncZoomPan(e) {
    e.scene.pan2Dxyzmm = Zt(this.scene.pan2Dxyzmm);
  }
  /**
   * Synchronizes crosshair position with another Niivue instance.
   * @internal
   */
  doSyncCrosshair(e) {
    const t = this.frac2mm(this.scene.crosshairPos);
    e.scene.crosshairPos = e.mm2frac(t);
  }
  /**
   * Synchronizes cal_min with another Niivue instance, updating GPU volume only if needed.
   * @internal
   */
  doSyncCalMin(e) {
    this.volumes[0].cal_min !== e.volumes[0].cal_min && (e.volumes[0].cal_min = this.volumes[0].cal_min, e.updateGLVolume());
  }
  /**
   * Synchronizes cal_max with another Niivue instance, updating GPU volume only if needed.
   * @internal
   */
  doSyncCalMax(e) {
    this.volumes[0].cal_max !== e.volumes[0].cal_max && (e.volumes[0].cal_max = this.volumes[0].cal_max, e.updateGLVolume());
  }
  /**
   * Synchronizes slice view type with another Niivue instance.
   * @internal
   */
  doSyncSliceType(e) {
    e.setSliceType(this.opts.sliceType);
  }
  /**
   * Synchronizes clip plane settings with another Niivue instance.
   * @internal
   */
  doSyncClipPlane(e) {
    e.setClipPlane(this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex]);
  }
  /**
   * Sync the scene controls (orientation, crosshair location, etc.) from one Niivue instance to another. useful for using one canvas to drive another.
   * @internal
   * @example
   * niivue1 = new Niivue()
   * niivue2 = new Niivue()
   * niivue2.syncWith(niivue1)
   * niivue2.sync()
   */
  sync() {
    if (!(!this.gl || !this.otherNV || typeof this.otherNV > "u") && this.gl.canvas.matches(":focus"))
      for (let e = 0; e < this.otherNV.length; e++)
        this.otherNV[e] !== this && (this.syncOpts.gamma && this.doSyncGamma(this.otherNV[e]), this.syncOpts.crosshair && this.doSyncCrosshair(this.otherNV[e]), this.syncOpts.zoomPan && this.doSyncZoomPan(this.otherNV[e]), this.syncOpts.sliceType && this.doSyncSliceType(this.otherNV[e]), this.syncOpts.cal_min && this.doSyncCalMin(this.otherNV[e]), this.syncOpts.cal_max && this.doSyncCalMax(this.otherNV[e]), this.syncOpts.clipPlane && this.doSyncClipPlane(this.otherNV[e]), this.syncOpts["2d"] && this.doSync2d(this.otherNV[e]), this.syncOpts["3d"] && this.doSync3d(this.otherNV[e]), this.otherNV[e].canvas !== this.canvas && this.otherNV[e].drawScene(), this.otherNV[e].createOnLocationChange());
  }
  /** Not documented publicly for now
   * @internal
   * test if two arrays have equal values for each element
   * @param a - the first array
   * @param b - the second array
   * @example Niivue.arrayEquals(a, b)
   *
   * TODO this should maybe just use array-equal from NPM
   */
  arrayEquals(e, t) {
    return Array.isArray(e) && Array.isArray(t) && e.length === t.length && e.every((i, s) => i === t[s]);
  }
  /**
   * @internal
   * Compute point size for screen text that scales with resolution and screen size.
   * - Keeps physical font size consistent across different DPIs.
   * - Uses fontSizeScaling to scale with canvas size above a reference threshold.
   */
  textSizePoints() {
    this.opts.textHeight >= 0 && (V.warn("textHeight is deprecated (use fontMinPx and fontSizeScaling)"), this.opts.fontMinPx = this.opts.textHeight * 217, this.opts.fontSizeScaling = 0.4, this.opts.textHeight = -1);
    const e = this.uiData.dpr || 1, t = this.opts.fontMinPx, i = this.gl.canvas.width / e, s = this.gl.canvas.height / e, r = i * s, a = 800 * 600, n = Math.max(r / a, 1), o = Math.pow(n, this.opts.fontSizeScaling), l = t * o * e;
    this.fontPx = l, V.debug(
      `${i.toFixed(0)}x${s.toFixed(0)} pts (dpi=${e}) => areaScale=${n.toFixed(2)}, scale=${o.toFixed(2)}, minPx=${this.opts.fontMinPx} fontScale=${this.opts.fontSizeScaling} fontPx=${l.toFixed(2)}`
    );
  }
  /**
   * callback function to handle resize window events, redraws the scene.
   * @internal
   */
  resizeListener() {
    if (!(!this.canvas || !this.gl)) {
      if (!this.opts.isResizeCanvas) {
        this.opts.forceDevicePixelRatio >= 0 && V.warn("this.opts.forceDevicePixelRatio requires isResizeCanvas"), this.drawScene();
        return;
      }
      this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.display = "block", this.opts.forceDevicePixelRatio === 0 ? this.uiData.dpr = window.devicePixelRatio || 1 : this.opts.forceDevicePixelRatio < 0 ? this.uiData.dpr = 1 : this.uiData.dpr = this.opts.forceDevicePixelRatio, V.debug("devicePixelRatio: " + this.uiData.dpr), "width" in this.canvas.parentElement ? (this.canvas.width = this.canvas.parentElement.width * this.uiData.dpr, this.canvas.height = this.canvas.parentElement.height * this.uiData.dpr) : (this.canvas.width = this.canvas.offsetWidth * this.uiData.dpr, this.canvas.height = this.canvas.offsetHeight * this.uiData.dpr), this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.textSizePoints(), this.drawScene();
    }
  }
  /**
   * callback to handle mouse move events relative to the canvas
   * @internal
   * @returns the mouse position relative to the canvas
   */
  getRelativeMousePosition(e, t) {
    if (t = t || e.target, !t)
      return;
    const i = t.getBoundingClientRect();
    return {
      x: e.clientX - i.left,
      y: e.clientY - i.top
    };
  }
  /**
   * Returns mouse position relative to the canvas, excluding padding and borders.
   * @internal
   */
  getNoPaddingNoBorderCanvasRelativeMousePosition(e, t) {
    return t = t || e.target, this.getRelativeMousePosition(e, t);
  }
  /**
   * Disables the default context menu to allow custom right-click behavior.
   * @internal
   */
  mouseContextMenuListener(e) {
    e.preventDefault();
  }
  /**
   * Handles mouse down events for interaction, segmentation, and connectome label selection.
   * Routes to appropriate button handler based on click type.
   * @internal
   */
  mouseDownListener(e) {
    if (this.uiData.mousedown = !0, this.eventInBounds(e))
      this.opts.bounds && (this.opts.showBoundsBorder = !0);
    else {
      this.opts.showBoundsBorder = !1, this.drawScene();
      return;
    }
    e.preventDefault(), this.drawPenLocation = [NaN, NaN, NaN], this.drawPenAxCorSag = -1, this.drawShapeStartLocation = [NaN, NaN, NaN];
    const t = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
    if (this.opts.dragMode === 7 && this.uiData.angleState === "drawing_second_line" || (this.setDragStart(t.x, t.y), this.setDragEnd(t.x, t.y)), V.debug("mouse down"), V.debug(e), !t)
      return;
    const [i, s] = [t.x * this.uiData.dpr, t.y * this.uiData.dpr];
    this.opts.clickToSegment && (this.clickToSegmentXY = [i, s]);
    const r = this.getLabelAtPoint([i, s]);
    if (r) {
      if (r.onClick) {
        r.onClick(r, e);
        return;
      }
      for (const a of this.meshes) {
        if (a.type !== "connectome") {
          if (Array.isArray(r.points) && r.points.length === 3 && r.points.every(Number.isFinite)) {
            const [n, o, l] = r.points;
            this.scene.crosshairPos = this.mm2frac([n, o, l]), this.updateGLVolume();
          }
          continue;
        }
        for (const n of a.nodes)
          n.label === r && (this.scene.crosshairPos = this.mm2frac([n.x, n.y, n.z]), this.updateGLVolume());
      }
    }
    this.uiData.clickedTile = this.tileIndex(i, s), e.button === De && e.shiftKey ? (this.uiData.mouseButtonCenterDown = !0, this.setActiveDragMode(De, !0, e.ctrlKey), this.handleMouseAction(this.uiData.activeDragMode, e, t)) : e.button === De ? (this.uiData.mouseButtonLeftDown = !0, this.setActiveDragMode(De, !1, e.ctrlKey), this.handleMouseAction(this.uiData.activeDragMode, e, t)) : e.button === Qi ? (this.uiData.mouseButtonRightDown = !0, this.setActiveDragMode(Qi, e.shiftKey, e.ctrlKey), this.handleMouseAction(this.uiData.activeDragMode, e, t)) : e.button === _i && (this.uiData.mouseButtonCenterDown = !0, this.setActiveDragMode(_i, e.shiftKey, e.ctrlKey), this.handleMouseAction(this.uiData.activeDragMode, e, t)), this.drawScene();
  }
  /**
   * Gets the appropriate drag mode for a mouse button based on configuration.
   * @internal
   */
  getMouseButtonDragMode(e, t, i) {
    const s = this.opts.mouseEventConfig;
    return e === De ? s != null && s.leftButton ? t && s.leftButton.withShift !== void 0 ? s.leftButton.withShift : i && s.leftButton.withCtrl !== void 0 ? s.leftButton.withCtrl : s.leftButton.primary : i ? 8 : this.opts.dragModePrimary : e === Qi ? (s == null ? void 0 : s.rightButton) !== void 0 ? s.rightButton : this.opts.dragMode : e === _i ? (s == null ? void 0 : s.centerButton) !== void 0 ? s.centerButton : this.opts.dragMode : this.opts.dragMode;
  }
  /**
   * Gets the appropriate drag mode for touch events based on configuration.
   * @internal
   */
  getTouchDragMode(e) {
    const t = this.opts.touchEventConfig;
    return e ? (t == null ? void 0 : t.doubleTouch) ?? this.opts.dragMode : (t == null ? void 0 : t.singleTouch) ?? this.opts.dragModePrimary;
  }
  /**
   * Sets the active drag mode for the current interaction.
   * @internal
   */
  setActiveDragMode(e, t, i) {
    this.uiData.activeDragMode = this.getMouseButtonDragMode(e, t, i), this.uiData.activeDragButton = e;
  }
  /**
   * Gets the currently active drag mode, or falls back to configured defaults.
   * @internal
   */
  getCurrentDragMode() {
    return this.uiData.activeDragMode !== null ? this.uiData.activeDragMode : this.opts.dragMode;
  }
  /**
   * Clears the active drag mode.
   * @internal
   */
  clearActiveDragMode() {
    this.uiData.activeDragMode = null, this.uiData.activeDragButton = null;
  }
  /**
   * Unified handler for mouse actions based on drag mode.
   * @internal
   */
  handleMouseAction(e, t, i) {
    if (e === 8)
      this.mouseDown(i.x, i.y), this.mouseClick(i.x, i.y);
    else if (e === 9)
      this.uiData.windowX = t.x, this.uiData.windowY = t.y;
    else {
      if (this.mousePos = [i.x * this.uiData.dpr, i.y * this.uiData.dpr], e === 0)
        return;
      if (e === 7)
        if (this.uiData.angleState === "none")
          this.uiData.angleState = "drawing_first_line";
        else if (this.uiData.angleState === "drawing_second_line") {
          const s = [i.x * this.uiData.dpr, i.y * this.uiData.dpr], r = this.tileIndex(s[0], s[1]);
          let a = { sliceIndex: -1, sliceType: 0, slicePosition: 0 };
          if (r >= 0 && r < this.screenSlices.length) {
            const f = this.screenSlices[r].axCorSag;
            let d = 0;
            f === 0 ? d = this.scene.crosshairPos[2] : f === 1 ? d = this.scene.crosshairPos[1] : f === 2 && (d = this.scene.crosshairPos[0]), a = {
              sliceIndex: r,
              sliceType: f,
              slicePosition: d
            };
          }
          const n = [
            this.uiData.angleFirstLine[2],
            // start from end of first line
            this.uiData.angleFirstLine[3],
            s[0],
            // to final click position
            s[1]
          ], o = this.canvasPos2frac([this.uiData.angleFirstLine[0], this.uiData.angleFirstLine[1]]), l = this.canvasPos2frac([this.uiData.angleFirstLine[2], this.uiData.angleFirstLine[3]]), c = this.canvasPos2frac([n[0], n[1]]), h = this.canvasPos2frac([n[2], n[3]]);
          if (o[0] >= 0 && l[0] >= 0 && c[0] >= 0 && h[0] >= 0) {
            const f = this.frac2mm(o), d = this.frac2mm(l), u = this.frac2mm(c), m = this.frac2mm(h), g = {
              firstLineMM: {
                start: O(f[0], f[1], f[2]),
                end: O(d[0], d[1], d[2])
              },
              secondLineMM: {
                start: O(u[0], u[1], u[2]),
                end: O(m[0], m[1], m[2])
              },
              sliceIndex: a.sliceIndex,
              sliceType: a.sliceType,
              slicePosition: a.slicePosition,
              angle: this.calculateAngleBetweenLines(this.uiData.angleFirstLine, n)
            };
            this.document.completedAngles.push(g);
          }
          this.resetAngleMeasurement(), this.uiData.angleState = "complete", this.drawScene();
          return;
        } else this.uiData.angleState === "complete" && (this.resetAngleMeasurement(), this.uiData.angleState = "drawing_first_line");
      this.setDragStart(i.x, i.y), this.uiData.isDragging || (this.uiData.pan2DxyzmmAtMouseDown = Zt(this.scene.pan2Dxyzmm)), this.uiData.isDragging = !0, this.uiData.dragClipPlaneStartDepthAziElev = this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex];
    }
  }
  /**
   * calculate the the min and max voxel indices from an array of two values (used in selecting intensities with the selection box)
   * @internal
   * @param array - an array of two values
   * @returns an array of two values representing the min and max voxel indices
   */
  calculateMinMaxVoxIdx(e) {
    if (e.length > 2)
      throw new Error("array must not contain more than two values");
    return [Math.floor(Math.min(e[0], e[1])), Math.floor(Math.max(e[0], e[1]))];
  }
  /**
   * Updates cal_min and cal_max based on intensity range within the drag-selected voxel region.
   * Skips if no drag occurred, volume is missing, or selection has no variation.
   * @internal
   */
  calculateNewRange({ volIdx: e = 0 } = {}) {
    if (this.opts.sliceType === 4 && this.sliceMosaicString.length < 1 || this.uiData.dragStart[0] === this.uiData.dragEnd[0] && this.uiData.dragStart[1] === this.uiData.dragEnd[1])
      return;
    let t = this.canvasPos2frac([this.uiData.dragStart[0], this.uiData.dragStart[1]]);
    if (t[0] < 0)
      return;
    const i = this.frac2vox(t, e);
    if (t = this.canvasPos2frac([this.uiData.dragEnd[0], this.uiData.dragEnd[1]]), t[0] < 0)
      return;
    const s = this.frac2vox(t, e);
    let r = -Number.MAX_VALUE, a = Number.MAX_VALUE;
    const n = this.calculateMinMaxVoxIdx([i[0], s[0]]), o = this.calculateMinMaxVoxIdx([i[1], s[1]]), l = this.calculateMinMaxVoxIdx([i[2], s[2]]);
    i[0] - s[0] === 0 ? n[1] = i[0] + 1 : i[1] - s[1] === 0 ? o[1] = i[1] + 1 : i[2] - s[2] === 0 && (l[1] = i[2] + 1);
    const c = this.volumes[e].hdr, h = this.volumes[e].img;
    if (!c || !h)
      return;
    const f = c.dims[1], d = c.dims[2];
    for (let g = l[0]; g < l[1]; g++) {
      const p = g * f * d;
      for (let A = o[0]; A < o[1]; A++) {
        const x = A * f;
        for (let w = n[0]; w < n[1]; w++) {
          const v = p + x + w;
          a > h[v] && (a = h[v]), r < h[v] && (r = h[v]);
        }
      }
    }
    if (a >= r)
      return;
    const u = pr(c, a), m = pr(c, r);
    this.volumes[e].cal_min = u, this.volumes[e].cal_max = m, this.onIntensityChange(this.volumes[e]);
  }
  /**
   * Triggers a drag-release callback with voxel, mm, and tile info from the drag gesture.
   * @internal
   */
  generateMouseUpCallback(e, t) {
    const i = this.tileIndex(this.uiData.dragStart[0], this.uiData.dragStart[1]), s = this.tileIndex(this.uiData.dragEnd[0], this.uiData.dragEnd[1]);
    let r = -1;
    i === s && (r = s);
    let a = -1;
    r >= 0 && (a = this.screenSlices[r].axCorSag);
    const n = this.frac2mm(e), o = this.frac2mm(t), l = nt();
    Os(l, O(n[0], n[1], n[2]), O(o[0], o[1], o[2]));
    const c = Le(l), h = this.frac2vox(e), f = this.frac2vox(t);
    this.onDragRelease({
      fracStart: e,
      fracEnd: t,
      voxStart: h,
      voxEnd: f,
      mmStart: n,
      mmEnd: o,
      mmLength: c,
      tileIdx: r,
      axCorSag: a
    });
  }
  /**
   * Handles mouse up events, finalizing drag actions, invoking callbacks, and updating contrast if needed.
   * @internal
   */
  mouseUpListener() {
    this.uiData.mousedown = !1;
    function e(r) {
      return Object.prototype.toString.call(r).indexOf("Function") > -1;
    }
    const t = {
      mouseButtonRightDown: this.uiData.mouseButtonRightDown,
      mouseButtonCenterDown: this.uiData.mouseButtonCenterDown,
      isDragging: this.uiData.isDragging,
      mousePos: this.mousePos,
      fracPos: this.canvasPos2frac(this.mousePos)
      // xyzMM: this.frac2mm(fracPos),
    };
    this.uiData.mouseButtonRightDown = !1;
    const i = this.uiData.mouseButtonCenterDown;
    this.uiData.mouseButtonCenterDown = !1, this.uiData.mouseButtonLeftDown = !1;
    const s = this.getCurrentDragMode();
    if (this.drawPenFillPts.length > 0 ? this.drawPenFilled() : this.opts.drawingEnabled && !isNaN(this.drawPenLocation[0]) ? this.drawAddUndoBitmap() : this.opts.drawingEnabled && !isNaN(this.drawShapeStartLocation[0]) && (this.opts.penType === 1 || this.opts.penType === 2) && (this.opts.penValue === 0 ? this.drawAddUndoBitmap() : this.drawAddUndoBitmap(this.drawFillOverwrites), this.drawShapePreviewBitmap = null), this.drawPenLocation = [NaN, NaN, NaN], this.drawPenAxCorSag = -1, this.drawShapeStartLocation = [NaN, NaN, NaN], this.drawShapePreviewBitmap && (this.drawBitmap = this.drawShapePreviewBitmap, this.drawShapePreviewBitmap = null, this.refreshDrawing(!0, !1)), e(this.onMouseUp) && this.onMouseUp(t), this.uiData.isDragging) {
      if (this.uiData.isDragging = !1, s === 7) {
        if (this.uiData.angleState === "drawing_first_line") {
          this.uiData.angleFirstLine = [
            this.uiData.dragStart[0],
            this.uiData.dragStart[1],
            this.uiData.dragEnd[0],
            this.uiData.dragEnd[1]
          ], this.uiData.angleState = "drawing_second_line", this.uiData.isDragging = !0, this.drawScene();
          return;
        }
        if (this.uiData.angleState === "drawing_second_line") {
          this.uiData.angleState = "complete", this.clearActiveDragMode(), this.drawScene();
          return;
        }
      }
      s === 5 && this.drawScene();
      const r = this.canvasPos2frac([this.uiData.dragStart[0], this.uiData.dragStart[1]]), a = this.canvasPos2frac([this.uiData.dragEnd[0], this.uiData.dragEnd[1]]);
      if (this.generateMouseUpCallback(r, a), s === 6) {
        this.clearActiveDragMode();
        return;
      }
      if (s === 1) {
        if (i) {
          this.clearActiveDragMode();
          return;
        }
        if (this.uiData.dragStart[0] === this.uiData.dragEnd[0] && this.uiData.dragStart[1] === this.uiData.dragEnd[1]) {
          this.clearActiveDragMode();
          return;
        }
        this.calculateNewRange({ volIdx: 0 }), this.refreshLayers(this.volumes[0], 0);
      }
      if (s === 2) {
        const n = this.getCurrentSliceInfo(), o = this.canvasPos2frac([this.uiData.dragStart[0], this.uiData.dragStart[1]]), l = this.canvasPos2frac([this.uiData.dragEnd[0], this.uiData.dragEnd[1]]);
        if (o[0] >= 0 && l[0] >= 0) {
          const c = this.frac2mm(o), h = this.frac2mm(l);
          this.document.completedMeasurements.push({
            startMM: O(c[0], c[1], c[2]),
            endMM: O(h[0], h[1], h[2]),
            sliceIndex: n.sliceIndex,
            sliceType: n.sliceType,
            slicePosition: n.slicePosition,
            distance: Yn(
              O(c[0], c[1], c[2]),
              O(h[0], h[1], h[2])
            )
          });
        }
        this.clearActiveDragMode(), this.drawScene();
        return;
      }
    }
    this.clearActiveDragMode(), this.drawScene();
  }
  /**
   * Handles initial touch event to simulate mouse click if not in a multi-touch gesture.
   * @internal
   */
  checkMultitouch(e) {
    if (this.uiData.touchdown && !this.uiData.multiTouchGesture) {
      const t = this.canvas.getBoundingClientRect();
      this.mouseDown(e.touches[0].clientX - t.left, e.touches[0].clientY - t.top), this.mouseClick(e.touches[0].clientX - t.left, e.touches[0].clientY - t.top);
    }
  }
  /**
   * Handles touch start events, detecting double taps and preparing for gesture or contrast reset.
   * @internal
   */
  touchStartListener(e) {
    e.preventDefault(), this.uiData.touchTimer || (this.uiData.touchTimer = setTimeout(() => {
      this.resetBriCon(e);
    }, this.opts.longTouchTimeout)), this.uiData.touchdown = !0, this.uiData.currentTouchTime = (/* @__PURE__ */ new Date()).getTime();
    const t = this.uiData.currentTouchTime - this.uiData.lastTouchTime;
    if (t < this.opts.doubleTouchTimeout && t > 0) {
      this.uiData.doubleTouch = !0, this.setDragStart(
        e.targetTouches[0].clientX - e.target.getBoundingClientRect().left,
        e.targetTouches[0].clientY - e.target.getBoundingClientRect().top
      ), this.resetBriCon(e), this.uiData.lastTouchTime = this.uiData.currentTouchTime;
      return;
    } else
      this.uiData.doubleTouch = !1, this.setDragStart(0, 0), this.setDragEnd(0, 0), this.uiData.lastTouchTime = this.uiData.currentTouchTime;
    this.uiData.touchdown && e.touches.length < 2 ? this.uiData.multiTouchGesture = !1 : this.uiData.multiTouchGesture = !0, setTimeout(this.checkMultitouch.bind(this), 1, e);
  }
  /**
   * Handles touch end events, finalizing gestures and contrast adjustments, then triggers mouse up logic.
   * @internal
   */
  touchEndListener(e) {
    if (e.preventDefault(), this.uiData.touchdown = !1, this.uiData.lastTwoTouchDistance = 0, this.uiData.multiTouchGesture = !1, this.uiData.touchTimer && (clearTimeout(this.uiData.touchTimer), this.uiData.touchTimer = null), this.uiData.isDragging) {
      this.uiData.isDragging = !1, this.getCurrentDragMode() === 1 && (this.calculateNewRange(), this.refreshLayers(this.volumes[0], 0));
      const t = this.canvasPos2frac([this.uiData.dragStart[0], this.uiData.dragStart[1]]), i = this.canvasPos2frac([this.uiData.dragEnd[0], this.uiData.dragEnd[1]]);
      this.generateMouseUpCallback(t, i);
    }
    this.mouseUpListener();
  }
  /**
   * Adjusts window/level (cal_min and cal_max) based on mouse or touch drag direction.
   * @internal
   */
  windowingHandler(e, t, i = 0) {
    const s = this.uiData.windowX, r = this.uiData.windowY;
    let a = this.volumes[0].cal_min, n = this.volumes[0].cal_max;
    const o = this.volumes[0].global_min, l = this.volumes[0].global_max;
    t < r ? (a += 1, n += 1) : t > r && (a -= 1, n -= 1), e > s ? (a -= 1, n += 1) : e < s && (a += 1, n -= 1), n - a < 1 && (n = a + 1), a < o && (a = o), n > l && (n = l), a > n && (a = n - 1), this.volumes[i].cal_min = a, this.volumes[i].cal_max = n, this.refreshLayers(this.volumes[i], 0), this.uiData.windowX = e, this.uiData.windowY = t;
  }
  /**
   * Handles mouse leaving the canvas, resetting segmentation, drawing, and drag states.
   * @internal
   */
  mouseLeaveListener() {
    this.clickToSegmentIsGrowing && (V.debug("Mouse left canvas, stopping clickToSegment preview."), this.clickToSegmentIsGrowing = !1, this.refreshDrawing(!0, !1)), this.opts.drawingEnabled && !isNaN(this.drawPenLocation[0]) && (V.debug("Mouse left canvas during drawing, resetting pen state."), this.drawPenLocation = [NaN, NaN, NaN], this.drawPenAxCorSag = -1, this.drawPenFillPts = []), this.opts.drawingEnabled && !isNaN(this.drawShapeStartLocation[0]) && (V.debug("Mouse left canvas during shape drawing, resetting shape state."), this.drawShapeStartLocation = [NaN, NaN, NaN], this.drawShapePreviewBitmap && (this.drawBitmap = this.drawShapePreviewBitmap, this.drawShapePreviewBitmap = null, this.refreshDrawing(!0, !1))), (this.uiData.isDragging || this.uiData.mousedown) && (V.debug("Mouse left canvas during drag, resetting drag state."), this.uiData.isDragging = !1, this.uiData.mouseButtonLeftDown = !1, this.uiData.mouseButtonCenterDown = !1, this.uiData.mouseButtonRightDown = !1, this.uiData.mousedown = !1, this.drawScene()), this.mousePos = [-1, -1];
  }
  /**
   * Handles mouse move events for dragging, crosshair movement, windowing, and click-to-segment preview.
   * @internal
   */
  mouseMoveListener(e) {
    this.uiData.mousedown && this.drawScene();
    const t = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
    if (t) {
      if (!this.eventInBounds(e)) {
        this.updateMousePos(t.x, t.y);
        return;
      }
      if (this.uiData.mousedown) {
        const i = t.x * this.uiData.dpr, s = t.y * this.uiData.dpr;
        if (this.tileIndex(i, s) !== this.uiData.clickedTile)
          return;
        const a = this.getCurrentDragMode();
        if (a === 8) {
          this.mouseMove(t.x, t.y), this.mouseClick(t.x, t.y), this.drawScene(), this.uiData.prevX = this.uiData.currX, this.uiData.prevY = this.uiData.currY;
          return;
        }
        if (a === 9) {
          this.windowingHandler(t.x, t.y), this.drawScene(), this.uiData.prevX = this.uiData.currX, this.uiData.prevY = this.uiData.currY;
          return;
        }
        this.setDragEnd(t.x, t.y), this.drawScene(), this.uiData.prevX = this.uiData.currX, this.uiData.prevY = this.uiData.currY;
      } else if (this.getCurrentDragMode() === 7 && this.uiData.angleState === "drawing_second_line") {
        const i = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
        if (!i)
          return;
        this.setDragEnd(i.x, i.y), this.drawScene();
      } else if (!this.uiData.mousedown && this.opts.clickToSegment) {
        const i = this.getNoPaddingNoBorderCanvasRelativeMousePosition(e, this.gl.canvas);
        if (!i)
          return;
        const s = i.x * this.uiData.dpr, r = i.y * this.uiData.dpr;
        this.mousePos = [s, r];
        const a = this.tileIndex(s, r);
        a >= 0 && this.opts.drawingEnabled && this.screenSlices[a].axCorSag <= 2 && (this.clickToSegmentXY = [s, r], this.clickToSegmentIsGrowing = !0, this.doClickToSegment({
          x: s,
          // Screen X
          y: r,
          // Screen Y
          tileIndex: a
        }));
      }
    }
  }
  /**
   * Resets brightness and contrast to robust min/max unless in render mode or during interaction.
   * @internal
   */
  resetBriCon(e = null) {
    if (this.uiData.isDragging)
      return;
    if (!this.eventInBounds(e)) {
      this.opts.showBoundsBorder = !1;
      return;
    }
    let t = !1;
    this.opts.sliceType === 4 && (t = !0);
    let i = 0, s = 0;
    if (e !== null && ("targetTouches" in e ? (i = e.targetTouches[0].clientX - e.target.getBoundingClientRect().left, s = e.targetTouches[0].clientY - e.target.getBoundingClientRect().top) : (i = e.offsetX, s = e.offsetY), i *= this.uiData.dpr, s *= this.uiData.dpr, this.inRenderTile(i, s) >= 0 && (t = !0)), t) {
      this.uiData.mouseDepthPicker = !0, this.drawScene(), this.drawScene();
      return;
    }
    this.getCurrentDragMode() !== 4 && (this.volumes.length < 1 || this.uiData.doubleTouch || (this.volumes[0].cal_min = this.volumes[0].robust_min, this.volumes[0].cal_max = this.volumes[0].robust_max, this.onIntensityChange(this.volumes[0]), this.refreshLayers(this.volumes[0], 0), this.drawScene()));
  }
  /**
   * Sets the drag start position in canvas coordinates.
   * @internal
   */
  setDragStart(e, t) {
    e *= this.uiData.dpr, t *= this.uiData.dpr, this.uiData.dragStart[0] = e, this.uiData.dragStart[1] = t;
  }
  /**
   * Sets the drag end position in canvas coordinates.
   * @internal
   */
  setDragEnd(e, t) {
    e *= this.uiData.dpr, t *= this.uiData.dpr, this.uiData.dragEnd[0] = e, this.uiData.dragEnd[1] = t;
  }
  /**
   * Handles touch movement for crosshair, windowing, and pinch-to-zoom interactions.
   * @internal
   */
  touchMoveListener(e) {
    if (this.uiData.touchdown && e.touches.length < 2) {
      const t = this.canvas.getBoundingClientRect();
      if (this.uiData.isDragging || (this.uiData.pan2DxyzmmAtMouseDown = Zt(this.scene.pan2Dxyzmm)), this.uiData.isDragging = !0, this.uiData.doubleTouch && this.uiData.isDragging) {
        this.setDragEnd(
          e.targetTouches[0].clientX - e.target.getBoundingClientRect().left,
          e.targetTouches[0].clientY - e.target.getBoundingClientRect().top
        ), this.drawScene();
        return;
      }
      const i = this.getTouchDragMode(!1);
      i === 8 ? (this.mouseClick(e.touches[0].clientX - t.left, e.touches[0].clientY - t.top), this.mouseMove(e.touches[0].clientX - t.left, e.touches[0].clientY - t.top)) : i === 9 && (this.windowingHandler(e.touches[0].pageX, e.touches[0].pageY), this.drawScene());
    } else
      this.handlePinchZoom(e);
  }
  /**
   * Handles pinch-to-zoom gestures for scrolling 2D slices.
   * @internal
   */
  handlePinchZoom(e) {
    if (e.targetTouches.length === 2 && e.changedTouches.length === 2) {
      const t = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY), i = this.canvas.getBoundingClientRect();
      this.mousePos = [e.touches[0].clientX - i.left, e.touches[0].clientY - i.top], t < this.uiData.lastTwoTouchDistance ? this.sliceScroll2D(-0.01, e.touches[0].clientX - i.left, e.touches[0].clientY - i.top) : this.sliceScroll2D(0.01, e.touches[0].clientX - i.left, e.touches[0].clientY - i.top), this.uiData.lastTwoTouchDistance = t;
    }
  }
  /**
   * Cycles active clip plane
   * @internal
   * @returns active clip plane index
   */
  cycleActiveClipPlane() {
    const e = this.scene.clipPlanes.length || 6;
    this.uiData.activeClipPlaneIndex == null ? this.uiData.activeClipPlaneIndex = 0 : this.uiData.activeClipPlaneIndex = (this.uiData.activeClipPlaneIndex + 1) % e;
    const t = this.uiData.activeClipPlaneIndex;
    return this.scene.clipPlanes[t] || (this.scene.clipPlanes[t] = [0, 0, 0, 2]), this.scene.clipPlaneDepthAziElevs[t] || (this.scene.clipPlaneDepthAziElevs[t] = [2, 0, 0]), t;
  }
  /**
   * Handles keyboard shortcuts for toggling clip planes and slice view modes with debounce logic.
   * @internal
   */
  keyUpListener(e) {
    if (!this.cursorInBounds()) {
      this.opts.showBoundsBorder = !1, this.drawScene();
      return;
    }
    const t = (/* @__PURE__ */ new Date()).getTime(), i = t - this.lastCalled;
    if (e.code === this.opts.cycleClipPlaneHotKey && i > this.opts.keyDebounceTime) {
      const s = this.cycleActiveClipPlane();
      console.log("Active clip plane cycled to:", s), console.log("clip planes", this.scene.clipPlanes), this.lastCalled = t;
    }
    if (e.code === this.opts.clipPlaneHotKey) {
      if (i > this.opts.keyDebounceTime) {
        switch (this.currentClipPlaneIndex = (this.currentClipPlaneIndex + 1) % 7, this.currentClipPlaneIndex) {
          case 0:
            this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = [2, 0, 0];
            break;
          case 1:
            this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = [0, 270, 0];
            break;
          case 2:
            this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = [0, 90, 0];
            break;
          case 3:
            this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = [0, 0, 0];
            break;
          case 4:
            this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = [0, 180, 0];
            break;
          case 5:
            this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = [0, 0, -90];
            break;
          case 6:
            this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = [0, 0, 90];
            break;
        }
        this.setClipPlane(this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex]);
      }
      this.lastCalled = t;
    } else if (e.code === this.opts.viewModeHotKey) {
      const s = (/* @__PURE__ */ new Date()).getTime();
      s - this.lastCalled > this.opts.keyDebounceTime && (this.setSliceType((this.opts.sliceType + 1) % 5), this.lastCalled = s);
    }
    this.drawScene();
  }
  /**
   * Handles key down events for navigation, rendering controls, slice movement, and mode switching.
   * @internal
   */
  keyDownListener(e) {
    if (!this.cursorInBounds()) {
      this.opts.showBoundsBorder = !1, this.drawScene();
      return;
    }
    e.code === "KeyH" && this.opts.sliceType === 4 ? this.setRenderAzimuthElevation(this.scene.renderAzimuth - 1, this.scene.renderElevation) : e.code === "KeyL" && this.opts.sliceType === 4 ? this.setRenderAzimuthElevation(this.scene.renderAzimuth + 1, this.scene.renderElevation) : e.code === "KeyJ" && this.opts.sliceType === 4 ? this.setRenderAzimuthElevation(this.scene.renderAzimuth, this.scene.renderElevation + 1) : e.code === "KeyK" && this.opts.sliceType === 4 ? this.setRenderAzimuthElevation(this.scene.renderAzimuth, this.scene.renderElevation - 1) : e.code === "KeyH" && this.opts.sliceType !== 4 ? this.moveCrosshairInVox(-1, 0, 0) : e.code === "KeyL" && this.opts.sliceType !== 4 ? this.moveCrosshairInVox(1, 0, 0) : e.code === "KeyU" && this.opts.sliceType !== 4 && e.ctrlKey ? this.moveCrosshairInVox(0, 0, 1) : e.code === "KeyD" && this.opts.sliceType !== 4 && e.ctrlKey ? this.moveCrosshairInVox(0, 0, -1) : e.code === "KeyJ" && this.opts.sliceType !== 4 ? this.moveCrosshairInVox(0, -1, 0) : e.code === "KeyK" && this.opts.sliceType !== 4 ? this.moveCrosshairInVox(0, 1, 0) : e.code === "KeyM" && this.opts.sliceType !== 4 ? (this.opts.dragMode++, this.opts.dragMode >= 4 && (this.opts.dragMode = 0), V.info("drag mode changed to ", mn[this.opts.dragMode])) : e.code === "ArrowLeft" ? this.setFrame4D(this.volumes[0].id, this.volumes[0].frame4D - 1) : e.code === "ArrowRight" ? this.setFrame4D(this.volumes[0].id, this.volumes[0].frame4D + 1) : e.code === "Slash" && e.shiftKey && alert(`NIIVUE VERSION: ${xr}`), this.drawScene();
  }
  /**
   * Handles scroll wheel events for slice scrolling, ROI box resizing, zooming, or segmentation thresholding.
   * @internal
   */
  wheelListener(e) {
    if (this.thumbnailVisible || this.opts.sliceMosaicString.length > 0)
      return;
    if (this.eventInBounds(e))
      this.opts.bounds && (this.opts.showBoundsBorder = !0);
    else {
      this.opts.showBoundsBorder = !1, this.drawScene();
      return;
    }
    e.preventDefault(), e.stopPropagation();
    const t = this.uiData.dragStart.reduce((l, c) => l + c, 0), i = this.uiData.dragEnd.reduce((l, c) => l + c, 0), s = t > 0 && i > 0;
    if (this.getCurrentDragMode() === 6 && s) {
      const l = e.deltaY > 0 ? 1 : -1;
      this.uiData.dragStart[0] < this.uiData.dragEnd[0] ? (this.uiData.dragStart[0] -= l, this.uiData.dragEnd[0] += l) : (this.uiData.dragStart[0] += l, this.uiData.dragEnd[0] -= l), this.uiData.dragStart[1] < this.uiData.dragEnd[1] ? (this.uiData.dragStart[1] -= l, this.uiData.dragEnd[1] += l) : (this.uiData.dragStart[1] += l, this.uiData.dragEnd[1] -= l), this.uiData.isDragging = !0, this.drawScene(), this.uiData.isDragging = !1;
      const c = this.tileIndex(this.uiData.dragStart[0], this.uiData.dragStart[1]);
      c >= 0 ? this.generateMouseUpCallback(
        this.screenXY2TextureFrac(this.uiData.dragStart[0], this.uiData.dragStart[1], c),
        this.screenXY2TextureFrac(this.uiData.dragEnd[0], this.uiData.dragEnd[1], c)
      ) : V.warn("Could not generate drag release callback for ROI selection: Invalid tile index.");
      return;
    }
    let r = e.deltaY < 0 ? -0.01 : 0.01;
    if (this.opts.invertScrollDirection && (r = -r), this.opts.clickToSegment) {
      r < 0 ? (this.opts.clickToSegmentPercent -= 0.01, this.opts.clickToSegmentPercent = Math.max(this.opts.clickToSegmentPercent, 0)) : (this.opts.clickToSegmentPercent += 0.01, this.opts.clickToSegmentPercent = Math.min(this.opts.clickToSegmentPercent, 1));
      const l = this.clickToSegmentXY[0], c = this.clickToSegmentXY[1], h = this.tileIndex(l, c);
      h >= 0 && this.screenSlices[h].axCorSag <= 2 && (V.debug(`Adjusting clickToSegment threshold: ${this.opts.clickToSegmentPercent.toFixed(3)}`), this.clickToSegmentIsGrowing = !0, this.doClickToSegment({ x: l, y: c, tileIndex: h }));
      return;
    }
    const a = this.canvas.getBoundingClientRect(), n = e.clientX - a.left, o = e.clientY - a.top;
    if (this.getCurrentDragMode() === 3 && this.inRenderTile(this.uiData.dpr * n, this.uiData.dpr * o) === -1) {
      const l = r < 0 ? 1 : -1;
      let c = this.scene.pan2Dxyzmm[3] * (1 + 10 * (0.01 * l));
      c = Math.round(c * 10) / 10;
      const h = this.scene.pan2Dxyzmm[3] - c;
      this.opts.yoke3Dto2DZoom && (this.scene.volScaleMultiplier = c), this.scene.pan2Dxyzmm[3] = c;
      const f = this.frac2mm(this.scene.crosshairPos);
      this.scene.pan2Dxyzmm[0] += h * f[0], this.scene.pan2Dxyzmm[1] += h * f[1], this.scene.pan2Dxyzmm[2] += h * f[2], this.drawScene(), this.canvas.focus(), this.sync();
      return;
    }
    this.sliceScroll2D(r, n, o);
  }
  /**
   * Registers all mouse, touch, keyboard, and drag event listeners for canvas interaction.
   * n.b. any event listeners registered here should also be removed in `cleanup()`
   * @internal
   */
  registerInteractions() {
    if (!this.canvas)
      throw new Error("canvas undefined");
    _t(this, se, new AbortController());
    const { signal: e } = X(this, se);
    this.canvas.addEventListener("mousedown", this.mouseDownListener.bind(this), { signal: e }), this.canvas.addEventListener("mouseup", this.mouseUpListener.bind(this), { signal: e }), this.canvas.addEventListener("mousemove", this.mouseMoveListener.bind(this), { signal: e }), this.canvas.addEventListener("mouseleave", this.mouseLeaveListener.bind(this), { signal: e }), this.canvas.addEventListener("touchstart", this.touchStartListener.bind(this), { signal: e }), this.canvas.addEventListener("touchend", this.touchEndListener.bind(this), { signal: e }), this.canvas.addEventListener("touchmove", this.touchMoveListener.bind(this), { signal: e }), this.canvas.addEventListener("wheel", this.wheelListener.bind(this), { signal: e }), this.canvas.addEventListener("contextmenu", this.mouseContextMenuListener.bind(this), { signal: e }), this.canvas.addEventListener("dblclick", this.resetBriCon.bind(this), { signal: e }), this.canvas.addEventListener("dragenter", this.dragEnterListener.bind(this), { signal: e }), this.canvas.addEventListener("dragover", this.dragOverListener.bind(this), { signal: e }), this.canvas.addEventListener(
      "drop",
      (t) => {
        this.dropListener(t).catch(console.error);
      },
      { signal: e }
    ), this.canvas.setAttribute("tabindex", "0"), this.canvas.addEventListener("keyup", this.keyUpListener.bind(this), { signal: e }), this.canvas.addEventListener("keydown", this.keyDownListener.bind(this), { signal: e });
  }
  /**
   * Prevents default behavior when a dragged item enters the canvas.
   * @internal
   */
  dragEnterListener(e) {
    e.stopPropagation(), e.preventDefault();
  }
  /**
   * Prevents default behavior when a dragged item is over the canvas.
   * @internal
   */
  dragOverListener(e) {
    e.stopPropagation(), e.preventDefault();
  }
  /**
   * Extracts and normalizes the file extension, handling special cases like .gz and .cbor.
   * @internal
   */
  getFileExt(e, t = !0) {
    V.debug("fullname: ", e);
    const i = /(?:\.([^.]+))?$/;
    let s = i.exec(e)[1];
    if (s = s.toUpperCase(), s === "GZ")
      s = i.exec(e.slice(0, -3))[1], s = s.toUpperCase();
    else if (s === "CBOR") {
      const r = s;
      s = i.exec(e.slice(0, -5))[1], s = s.toUpperCase(), s = `${s}.${r}`;
    }
    return t ? s : s.toLowerCase();
  }
  /**
   * Add an image and notify subscribers
   * @see {@link https://niivue.com/demos/features/document.3d.html | live demo usage}
   */
  async addVolumeFromUrl(e) {
    const t = await Mt.loadFromUrl(e);
    return this.document.addImageOptions(t, e), t.onColormapChange = this.onColormapChange, this.mediaUrlMap.set(t, e.url), this.onVolumeAddedFromUrl && this.onVolumeAddedFromUrl(e, t), this.addVolume(t), t;
  }
  async addVolumesFromUrl(e) {
    const t = e.map(async (s) => {
      const r = this.getFileExt(s.name || s.url);
      if (r === "DCM")
        throw new Error("DICOM files must be loaded using useDicomLoader");
      if (this.loaders[r]) {
        let o = s.url;
        const l = this.loaders[r].toExt;
        let c = s.name || s.url;
        if (c = c.split("/").pop(), typeof s.url == "string") {
          const f = s.url;
          try {
            const d = await fetch(f);
            if (!d.ok)
              throw new Error(`Failed to load file: ${d.statusText}`);
            o = await d.arrayBuffer();
          } catch (d) {
            throw new Error(`Failed to load url ${f}: ${d}`);
          }
        }
        const h = await this.loaders[r].loader(o);
        s.url = h, s.name = `${c}.${l}`;
      }
      const a = {
        url: s.url,
        headers: s.headers,
        name: s.name,
        colormap: s.colormap ? s.colormap : s.colorMap,
        colormapNegative: s.colormapNegative ? s.colormapNegative : s.colorMapNegative,
        opacity: s.opacity,
        urlImgData: s.urlImgData,
        cal_min: s.cal_min,
        cal_max: s.cal_max,
        trustCalMinMax: this.opts.trustCalMinMax,
        isManifest: s.isManifest,
        frame4D: s.frame4D,
        limitFrames4D: s.limitFrames4D || this.opts.limitFrames4D,
        colorbarVisible: s.colorbarVisible
      }, n = await Mt.loadFromUrl(a);
      return this.document.addImageOptions(n, a), n.onColormapChange = this.onColormapChange, this.mediaUrlMap.set(n, a.url), this.onVolumeAddedFromUrl && this.onVolumeAddedFromUrl(a, n), n;
    }), i = await Promise.all(t);
    for (let s = 0; s < i.length; s++)
      this.addVolume(i[s]);
    return i;
  }
  /**
   * Returns the media object associated with the given URL, if any.
   * @internal
   */
  getMediaByUrl(e) {
    return [...this.mediaUrlMap.entries()].filter((t) => t[1] === e).map((t) => t[0]).pop();
  }
  /**
   * Remove volume by url
   * @param url - Volume added by url to remove
   * @see {@link https://niivue.com/demos/features/document.3d.html | live demo usage}
   */
  removeVolumeByUrl(e) {
    const t = this.getMediaByUrl(e);
    if (t)
      this.removeVolume(t);
    else
      throw new Error("No volume with URL present");
  }
  /**
   * Recursively traverses a file tree, populating file paths for directory uploads.
   * Adds `_webkitRelativePath` to each file for compatibility with tools like dcm2niix.
   * @internal
   */
  async traverseFileTree(e, t = "", i) {
    return new Promise((s) => {
      if (e.isFile)
        e.file((r) => {
          r.fullPath = t + r.name, r._webkitRelativePath = t + r.name, i.push(r), s(i);
        });
      else if (e.isDirectory) {
        const r = e.createReader(), a = () => {
          r.readEntries((n) => {
            if (n.length > 0) {
              const o = [];
              for (const l of n)
                o.push(this.traverseFileTree(l, t + e.name + "/", i));
              Promise.all(o).then(a).catch((l) => {
                throw l;
              });
            } else
              s(i);
          });
        };
        a();
      }
    });
  }
  /**
   * Recursively reads a directory and logs the File objects contained within.
   * Used for processing dropped folders via drag-and-drop.
   * @internal
   */
  readDirectory(e) {
    const t = e.createReader();
    let i = [];
    const s = async (a) => {
      const n = [], o = async (l) => new Promise((c, h) => l.file(c, h));
      for (let l = 0; l < a.length; l++)
        n.push(await o(a[l]));
      return n;
    }, r = () => {
      t.readEntries((a) => {
        a.length ? (i = i.concat(a), r()) : s(i).then(async () => {
        }).catch((n) => {
          throw n;
        });
      });
    };
    return r(), i;
  }
  /**
   * Returns boolean: true if filename ends with mesh extension (TRK, pial, etc)
   * @param url - filename
   * @internal
   */
  isMeshExt(e) {
    const t = this.getFileExt(e);
    return V.debug("dropped ext"), V.debug(t), ee.includes(t);
  }
  /**
   * Load an image or mesh from an array buffer
   * @param buffer - ArrayBuffer with the entire contents of a mesh or volume
   * @param name - string of filename, extension used to infer type (NIfTI, MGH, MZ3, etc)
   * @see {@link http://192.168.0.150:8080/features/draganddrop.html | live demo usage}
   */
  async loadFromArrayBuffer(e, t) {
    const i = this.getFileExt(t);
    if (ee.includes(i)) {
      await this.addMeshFromUrl({ url: t, buffer: e });
      return;
    }
    const s = wi(t);
    s.buffer = e, s.name = t, await this.addVolumeFromUrl(s);
  }
  /**
   * Load a mesh or image volume from a File object
   * @param file - File object selected by the user (e.g. from an HTML input element)
   * @returns a Promise that resolves when the file has been loaded and added to the scene
   * @see {@link https://niivue.com/demos/features/selectfont.html | live demo usage}
   */
  async loadFromFile(e) {
    const t = this.getFileExt(e.name);
    if (ee.includes(t)) {
      await Ae.loadFromFile({ file: e, gl: this.gl, name: e.name }).then((i) => {
        this.addMesh(i);
      });
      return;
    }
    await Mt.loadFromFile({
      file: e,
      name: e.name
    }).then((i) => {
      this.addVolume(i);
    });
  }
  /**
   * Registers a custom external file loader for handling specific file types in Niivue.
   *
   * This method allows you to define how certain file extensions are handled when loaded into Niivue.
   * The provided `loader` function should return an object containing an `ArrayBuffer` of the file's contents
   * and the file extension (used for inferring how Niivue should process the data).
   *
   * Optionally, `positions` and `indices` can be returned to support loading mesh data (e.g. `.mz3` format).
   *
   * @example
   * const myCustomLoader = async (file) => {
   *   const arrayBuffer = await file.arrayBuffer()
   *   return {
   *     arrayBuffer,
   *     fileExt: 'iwi.cbor',
   *     positions: new Float32Array(...),
   *     indices: new Uint32Array(...)
   *   }
   * }
   *
   * nv.useLoader(myCustomLoader, 'iwi.cbor', 'nii')
   *
   * @param loader - A function that accepts a `File` or `ArrayBuffer` and returns an object with `arrayBuffer` and `fileExt` properties. May also return `positions` and `indices` for meshes.
   * @param fileExt - The original file extension (e.g. 'iwi.cbor') to associate with this loader.
   * @param toExt - The target file extension Niivue should treat the file as (e.g. 'nii' or 'mz3').
   */
  useLoader(e, t, i) {
    this.loaders = {
      ...this.loaders,
      [t.toUpperCase()]: {
        loader: e,
        toExt: i
      }
    };
  }
  /**
   * Set a custom loader for handling DICOM files.
   */
  useDicomLoader(e) {
    this.dicomLoader = e;
  }
  /**
   * Get the currently assigned DICOM loader.
   */
  getDicomLoader() {
    return this.dicomLoader;
  }
  // dicom loading is a special case because it can take a list
  // of files (e.g. from a user supplied DICOM directory) or a single file.
  // Our preferred DICOM loader is the WASM port of dcm2niix (implemented in a separate niivue loader module).
  // useDicomLoader(loader: unknown, toExt: string) {
  //   this.loaders = {
  //     ...this.loaders,
  //     ['DCM']: {
  //       loader,
  //       toExt,
  //     },
  //   }
  // }
  /**
   * Handles file and URL drag-and-drop events on the canvas.
   * Supports loading of volumes, meshes, NVD documents, and DICOM directories.
   * Honors modifier keys (e.g., Shift to replace, Alt for drawing overlays).
   * @internal
   */
  async dropListener(e) {
    if (this.eventInBounds(e))
      this.opts.bounds && (this.opts.showBoundsBorder = !0);
    else {
      this.opts.showBoundsBorder = !1;
      return;
    }
    if (e.stopPropagation(), e.preventDefault(), !this.opts.dragAndDropEnabled)
      return;
    const t = [], i = e.dataTransfer;
    if (!i)
      return;
    const s = i.getData("text/uri-list");
    if (s) {
      const r = wi(s), a = this.getFileExt(s);
      V.debug("dropped ext"), V.debug(a), ee.includes(a) ? this.addMeshFromUrl({ url: s }).catch((n) => {
        throw n;
      }) : a === "NVD" ? this.loadDocumentFromUrl(s).catch((n) => {
        throw n;
      }) : this.addVolumeFromUrl(r).catch((n) => {
        throw n;
      });
    } else {
      const r = i.items;
      if (r.length > 0) {
        !e.shiftKey && !e.altKey && (this.volumes = [], this.overlays = [], this.meshes = []), this.closeDrawing(), this.closePAQD();
        for (const a of Array.from(r)) {
          const n = a.webkitGetAsEntry();
          if (V.debug(n), !n)
            throw new Error("could not get entry from file");
          if (n.isFile) {
            const o = this.getFileExt(n.name);
            let l;
            if (n.name.lastIndexOf("HEAD") !== -1)
              for (const c of Array.from(r)) {
                const h = c.webkitGetAsEntry();
                if (!h)
                  throw new Error("could not get paired entry");
                const f = n.name.substring(0, n.name.lastIndexOf("HEAD")), d = h.name.substring(0, h.name.lastIndexOf("BRIK"));
                f === d && (l = h);
              }
            if (n.name.toUpperCase().lastIndexOf("HDR") !== -1)
              for (const c of Array.from(r)) {
                const h = c.webkitGetAsEntry();
                if (!h)
                  throw new Error("could not get paired entry");
                const f = n.name.substring(0, n.name.toUpperCase().lastIndexOf("HDR")), d = h.name.substring(
                  0,
                  h.name.toUpperCase().lastIndexOf("IMG")
                );
                f === d && (l = h);
              }
            if (n.name.lastIndexOf("BRIK") !== -1 || n.name.toUpperCase().lastIndexOf("IMG") !== -1)
              continue;
            if (this.loaders[o]) {
              const c = await dh(n);
              await this.loadImages([
                {
                  url: c,
                  name: `${n.name}`
                }
              ]);
              continue;
            }
            if (ee.includes(o)) {
              n.file((c) => {
                (async () => {
                  try {
                    const h = await Ae.loadFromFile({
                      file: c,
                      gl: this.gl,
                      name: c.name
                    });
                    this.addMesh(h);
                  } catch (h) {
                    console.error("Error loading mesh:", h);
                  }
                })().catch((h) => console.error(h));
              });
              continue;
            } else if (o === "NVD") {
              n.file((c) => {
                (async () => {
                  try {
                    const h = await zi.loadFromFile(c);
                    await this.loadDocument(h), V.debug("loaded document");
                  } catch (h) {
                    console.error(h);
                  }
                })().catch((h) => console.error(h));
              });
              break;
            }
            n.file((c) => {
              (async () => {
                try {
                  if (l)
                    l.file((h) => {
                      (async () => {
                        try {
                          const f = await Mt.loadFromFile({
                            file: c,
                            urlImgData: h,
                            limitFrames4D: this.opts.limitFrames4D
                          });
                          this.addVolume(f);
                        } catch (f) {
                          console.error(f);
                        }
                      })().catch(console.error);
                    });
                  else {
                    const h = await Mt.loadFromFile({
                      file: c,
                      urlImgData: l,
                      limitFrames4D: this.opts.limitFrames4D
                    });
                    e.altKey ? (V.debug("alt key detected: assuming this is a drawing overlay"), this.drawClearAllUndoBitmaps(), this.loadDrawing(h)) : this.addVolume(h);
                  }
                } catch (h) {
                  console.error(h);
                }
              })().catch(console.error);
            });
          } else n.isDirectory && this.traverseFileTree(n, "", t).then((o) => {
            const l = this.getDicomLoader().loader;
            if (!l)
              throw new Error("No loader for DICOM files");
            l(o).then(async (c) => {
              const h = c.map(
                (f) => Mt.loadFromUrl({
                  url: f.data,
                  name: f.name,
                  limitFrames4D: this.opts.limitFrames4D
                })
              );
              Promise.all(h).then(async (f) => {
                await this.onDicomLoaderFinishedWithImages(f);
              }).catch((f) => {
                throw f;
              });
            }).catch((c) => {
              console.error("Error loading DICOM files:", c);
            });
          }).catch((o) => {
            throw o;
          });
        }
      }
    }
    this.drawScene();
  }
  /**
   * insert a gap between slices of a mutliplanar view.
   * @param pixels - spacing between tiles of multiplanar view
   * @example niivue.setMultiplanarPadPixels(4)
   * @see {@link https://niivue.com/demos/features/atlas.html | live demo usage}
   */
  setMultiplanarPadPixels(e) {
    this.opts.multiplanarPadPixels = e, this.drawScene();
  }
  /**
   * control placement of 2D slices.
   * @param layout - AUTO: 0, COLUMN: 1, GRID: 2, ROW: 3,
   * @example niivue.setMultiplanarLayout(2)
   * @see {@link https://niivue.com/demos/features/layout.html | live demo usage}
   */
  setMultiplanarLayout(e) {
    typeof e == "string" && (e = parseInt(e)), this.opts.multiplanarLayout = e, this.drawScene();
  }
  /**
   * determine if text appears at corner (true) or sides of 2D slice.
   * @param isCornerOrientationText - controls position of text
   * @example niivue.setCornerOrientationText(true)
   * @see {@link https://niivue.com/demos/features/worldspace2.html | live demo usage}
   */
  setCornerOrientationText(e) {
    this.opts.isCornerOrientationText = e, this.updateGLVolume();
  }
  /**
   * Show or hide orientation labels (e.g., L/R, A/P) in 2D slice views
   * @param isOrientationTextVisible - whether orientation text should be displayed
   * @example niivue.setIsOrientationTextVisible(false)
   * @see {@link https://niivue.com/demos/features/basic.multiplanar.html | live demo usage}
   */
  setIsOrientationTextVisible(e) {
    this.opts.isOrientationTextVisible = e, this.drawScene();
  }
  /**
   * Show or hide all four orientation labels (e.g., L/R, A/P, S/I) in 2D slice views
   * @param showAllOrientationMarkers - whether all four orientation markers should be displayed
   * @example niivue.setShowAllOrientationMarkers(true)
   */
  setShowAllOrientationMarkers(e) {
    this.opts.showAllOrientationMarkers = e, this.drawScene();
  }
  /**
   * determine proportion of screen real estate devoted to rendering in multiplanar view.
   * @param fraction - proportion of screen devoted to primary (hero) image (0 to disable)
   * @example niivue.setHeroImage(0.5)
   * @see {@link https://niivue.com/demos/features/layout.html | live demo usage}
   */
  setHeroImage(e) {
    this.opts.heroImageFraction = e, this.drawScene();
  }
  /**
   * Set a custom slice layout. This overrides the built-in layouts.
   * @param layout - Array of layout specifications for each slice view
   * @example
   * niivue.setCustomLayout([
   *     // Left 50% - Sag
   *     {sliceType: 2, position: [0, 0, 0.5, 1.0]},
   *     // Top right - Cor
   *     {sliceType: 1, position: [0.5, 0, 0.5, 0.5]},
   *     // Bottom right - Ax
   *     {sliceType: 0, position: [0.5, 0.5, 0.5, 0.5]}
   *   ])
   *
   * produces:
   * +----------------+----------------+
   * |                |                |
   * |                |     coronal    |
   * |                |                |
   * |                |                |
   * |   sagittal     +----------------+
   * |                |                |
   * |                |     axial      |
   * |                |                |
   * |                |                |
   * +----------------+----------------+
   */
  setCustomLayout(e) {
    for (let t = 0; t < e.length; t++) {
      const [i, s, r, a] = e[t].position, n = i + r, o = s + a;
      for (let l = t + 1; l < e.length; l++) {
        const [c, h, f, d] = e[l].position, u = c + f, m = h + d, g = i < u && n > c, p = s < m && o > h;
        if (g && p)
          throw new Error(`Custom layout is invalid. Tile ${t} overlaps with tile ${l}.`);
      }
    }
    this.customLayout = e, this.drawScene();
  }
  /**
   * Clear custom layout and rely on built-in layouts
   */
  clearCustomLayout() {
    this.customLayout = null, this.drawScene();
  }
  /**
   * Get the current custom layout if set
   * @returns The current custom layout or null if using built-in layouts
   */
  getCustomLayout() {
    return this.customLayout;
  }
  /**
   * control whether 2D slices use radiological or neurological convention.
   * @param isRadiologicalConvention - new display convention
   * @example niivue.setRadiologicalConvention(true)
   * @see {@link https://niivue.com/demos/features/worldspace.html | live demo usage}
   */
  setRadiologicalConvention(e) {
    this.opts.isRadiologicalConvention = e, this.updateGLVolume();
  }
  /**
   * Reset scene to default settings.
   * @param options - @see NiiVueOptions
   * @param resetBriCon - also reset contrast (default false).
   * @example niivue.nv1.setDefaults(opts, true);
   * @see {@link https://niivue.com/demos/features/connectome.html | live demo usage}
   */
  setDefaults(e = {}, t = !1) {
    this.document.opts = { ...kt }, this.scene.sceneData = { ...Be };
    for (const i in e)
      typeof e[i] == "function" ? this[i] = e[i] : this.opts[i] = kt[i] === void 0 ? kt[i] : e[i];
    if (this.scene.pan2Dxyzmm = [0, 0, 0, 1], t && this.volumes && this.volumes.length > 0)
      for (let i = 0; i < this.volumes.length; i++)
        this.volumes[i].cal_min = this.volumes[i].robust_min, this.volumes[i].cal_max = this.volumes[i].robust_max;
    this.updateGLVolume();
  }
  /**
   * Limit visibility of mesh in front of a 2D image. Requires world-space mode.
   * @param meshThicknessOn2D - distance from voxels for clipping mesh. Use Infinity to show entire mesh or 0.0 to hide mesh.
   * @example niivue.setMeshThicknessOn2D(42)
   * @see {@link https://niivue.com/demos/features/worldspace2.html | live demo usage}
   */
  setMeshThicknessOn2D(e) {
    this.opts.meshThicknessOn2D = e, this.updateGLVolume();
  }
  /**
   * Create a custom multi-slice mosaic (aka lightbox, montage) view.
   * @param str - description of mosaic.
   * @example niivue.setSliceMosaicString("A 0 20 C 30 S 42")
   * @see {@link https://niivue.com/demos/features/mosaics.html | live demo usage}
   */
  setSliceMosaicString(e) {
    this.sliceMosaicString = e, this.updateGLVolume();
  }
  /**
   * control 2D slice view mode.
   * @param isSliceMM - control whether 2D slices use world space (true) or voxel space (false). Beware that voxel space mode limits properties like panning, zooming and mesh visibility.
   * @example niivue.setSliceMM(true)
   * @see {@link https://niivue.com/demos/features/worldspace2.html | live demo usage}
   */
  setSliceMM(e) {
    this.opts.isSliceMM = e, this.updateGLVolume();
  }
  /**
   * control whether voxel overlays are combined using additive (emission) or traditional (transmission) blending.
   * @param isAdditiveBlend - emission (true) or transmission (false) mixing
   * @example niivue.isAdditiveBlend(true)
   * @see {@link https://niivue.com/demos/features/additive.voxels.html | live demo usage}
   */
  setAdditiveBlend(e) {
    this.opts.isAdditiveBlend = e, this.updateGLVolume();
  }
  /**
   * Detect if display is using radiological or neurological convention.
   * @returns radiological convention status
   * @example let rc = niivue.getRadiologicalConvention()
   */
  getRadiologicalConvention() {
    return this.opts.isRadiologicalConvention;
  }
  /**
   * Force WebGL canvas to use high resolution display, regardless of browser defaults.
   * @param forceDevicePixelRatio - -1: block high DPI; 0= allow high DPI: >0 use specified pixel ratio
   * @example niivue.setHighResolutionCapable(true);
   * @see {@link https://niivue.com/demos/features/sync.mesh.html | live demo usage}
   */
  setHighResolutionCapable(e) {
    typeof e == "boolean" && (e = e ? 0 : -1), this.opts.forceDevicePixelRatio = e, this.resizeListener(), this.drawScene();
  }
  /**
   * Start watching for changes to configuration options.
   * This is a convenience method that sets up the onOptsChange callback.
   * @param callback - Function to call when any option changes
   * @example
   * niivue.watchOptsChanges((propertyName, newValue, oldValue) => {
   *   console.log(`Option ${propertyName} changed from ${oldValue} to ${newValue}`)
   * })
   * @see {@link https://niivue.com/demos/ | live demo usage}
   */
  watchOptsChanges(e) {
    this.onOptsChange = e;
  }
  /**
   * Stop watching for changes to configuration options.
   * This removes the current onOptsChange callback.
   * @example niivue.unwatchOptsChanges()
   * @see {@link https://niivue.com/demos/ | live demo usage}
   */
  unwatchOptsChanges() {
    this.onOptsChange = () => {
    };
  }
  /**
   * add a new volume to the canvas
   * @param volume - the new volume to add to the canvas
   * @example
   * niivue = new Niivue()
   * niivue.addVolume(NVImage.loadFromUrl({url:'../someURL.nii.gz'}))
   * @see {@link https://niivue.com/demos/features/conform.html | live demo usage}
   */
  addVolume(e) {
    this.volumes.push(e);
    const t = this.volumes.length === 1 ? 0 : this.volumes.length - 1;
    this.setVolume(e, t), this.onImageLoaded(e), V.debug("loaded volume", e.name), V.debug(e);
  }
  /**
   * add a new mesh to the canvas
   * @param mesh - the new mesh to add to the canvas
   * @example
   * niivue = new Niivue()
   * niivue.addMesh(NVMesh.loadFromUrl({url:'../someURL.gii'}))
   * @see {@link https://niivue.com/demos/features/document.3d.html | live demo usage}
   */
  addMesh(e) {
    this.meshes.push(e);
    const t = this.meshes.length === 1 ? 0 : this.meshes.length - 1;
    this.setMesh(e, t), this.onMeshLoaded(e);
  }
  /**
   * get the index of a volume by its unique id. unique ids are assigned to the NVImage.id property when a new NVImage is created.
   * @param id - the id string to search for
   * @example
   * niivue = new Niivue()
   * niivue.getVolumeIndexByID(someVolume.id)
   */
  getVolumeIndexByID(e) {
    const t = this.volumes.length;
    for (let i = 0; i < t; i++)
      if (this.volumes[i].id === e)
        return i;
    return -1;
  }
  /**
   * Saves the current drawing state as an RLE-compressed bitmap for undo history.
   * Uses a circular buffer to limit undo memory usage.
   * @internal
   */
  drawAddUndoBitmap(e = !0) {
    if (!this.drawBitmap || this.drawBitmap.length < 1) {
      V.debug("drawAddUndoBitmap error: No drawing open");
      return;
    }
    if (!e && this.drawUndoBitmaps.length > 0) {
      const t = this.drawBitmap.length, i = cs(this.drawUndoBitmaps[this.currentDrawUndoBitmap], t);
      for (let s = 0; s < t; s++)
        i[s] > 0 && (this.drawBitmap[s] = i[s]);
      this.refreshDrawing(!1);
    }
    this.currentDrawUndoBitmap++, this.currentDrawUndoBitmap >= this.opts.maxDrawUndoBitmaps && (this.currentDrawUndoBitmap = 0), this.drawUndoBitmaps[this.currentDrawUndoBitmap] = nc(this.drawBitmap);
  }
  /**
   * Clears all stored drawing undo bitmaps and resets the undo index.
   * @internal
   */
  drawClearAllUndoBitmaps() {
    if (this.currentDrawUndoBitmap = this.opts.maxDrawUndoBitmaps, !(!this.drawUndoBitmaps || this.drawUndoBitmaps.length < 1))
      for (let e = this.drawUndoBitmaps.length - 1; e >= 0; e--)
        this.drawUndoBitmaps[e] = new Uint8Array();
  }
  /**
   * Restore drawing to previous state
   * @example niivue.drawUndo();
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  drawUndo() {
    const { drawBitmap: e, currentDrawUndoBitmap: t } = ac({
      drawUndoBitmaps: this.drawUndoBitmaps,
      currentDrawUndoBitmap: this.currentDrawUndoBitmap,
      drawBitmap: this.drawBitmap
    });
    this.drawBitmap = e, this.currentDrawUndoBitmap = t, this.refreshDrawing(!0);
  }
  /**
   * Loads a drawing overlay and aligns it with the current background image.
   * Converts the input image to match the background's orientation and stores it as a drawable bitmap.
   * Initializes the undo history and prepares the drawing texture.
   *
   * @param drawingBitmap - A `NVImage` object representing the drawing to load. Must match the dimensions of the background image.
   * @returns `true` if the drawing was successfully loaded and aligned; `false` if dimensions are incompatible.
   */
  loadDrawing(e) {
    if (this.drawBitmap && V.debug("Overwriting open drawing!"), !this.back)
      throw new Error("back undefined");
    this.drawClearAllUndoBitmaps();
    const t = e.hdr.dims;
    if (t[1] !== this.back.hdr.dims[1] || t[2] !== this.back.hdr.dims[2] || t[3] !== this.back.hdr.dims[3])
      return V.debug("drawing dimensions do not match background image"), !1;
    e.img.constructor !== Uint8Array && V.debug("Drawings should be UINT8");
    const i = e.permRAS, s = t[1] * t[2] * t[3];
    this.drawBitmap = new Uint8Array(s), this.opts.is2DSliceShader ? this.drawTexture = this.r8Tex2D(this.drawTexture, qt, this.back.dims, !0) : this.drawTexture = this.r8Tex(this.drawTexture, qt, this.back.dims, !0);
    const r = [0, 0, 0];
    for (let m = 0; m < 3; m++)
      for (let g = 0; g < 3; g++)
        Math.abs(i[m]) - 1 === g && (r[g] = m * Math.sign(i[m]));
    let a = 1;
    const n = [1, 1, 1], o = [!1, !1, !1];
    for (let m = 0; m < r.length; m++)
      for (let g = 0; g < r.length; g++)
        Math.abs(r[g]) === m && (n[g] = a, (r[g] < 0 || Object.is(r[g], -0)) && (o[g] = !0), a *= t[g + 1]);
    let l = H.range(0, t[1] - 1, 1);
    o[0] && (l = H.range(t[1] - 1, 0, -1));
    for (let m = 0; m < t[1]; m++)
      l[m] *= n[0];
    let c = H.range(0, t[2] - 1, 1);
    o[1] && (c = H.range(t[2] - 1, 0, -1));
    for (let m = 0; m < t[2]; m++)
      c[m] *= n[1];
    let h = H.range(0, t[3] - 1, 1);
    o[2] && (h = H.range(t[3] - 1, 0, -1));
    for (let m = 0; m < t[3]; m++)
      h[m] *= n[2];
    const f = e.img, d = this.drawBitmap;
    let u = 0;
    for (let m = 0; m < t[3]; m++)
      for (let g = 0; g < t[2]; g++)
        for (let p = 0; p < t[1]; p++)
          d[l[p] + c[g] + h[m]] = f[u], u++;
    return this.drawAddUndoBitmap(), this.refreshDrawing(!1), this.drawScene(), !0;
  }
  /**
   * Binarize a volume by converting all non-zero voxels to 1
   * @param volume - the image volume to modify in place
   * @see {@link https://niivue.com/demos/features/clusterize.html | live demo usage}
   */
  binarize(e) {
    const t = e.hdr.dims, i = t[1] * t[2] * t[3], s = new Uint8Array(i);
    for (let r = 0; r < i; r++)
      e.img[r] !== 0 && (s[r] = 1);
    e.img = s, e.hdr.datatypeCode = 2, e.hdr.cal_min = 0, e.hdr.cal_max = 1;
  }
  /**
   * Open drawing
   * @param fnm - filename of NIfTI format drawing
   * @param isBinarize - if true will force drawing voxels to be either 0 or 1.
   * @example niivue.loadDrawingFromUrl("../images/lesion.nii.gz");
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  async loadDrawingFromUrl(e, t = !1) {
    this.drawBitmap && V.debug("Overwriting open drawing!"), this.drawClearAllUndoBitmaps();
    let i = !1;
    try {
      const s = await Mt.loadFromUrl(wi(e));
      t && await this.binarize(s), i = this.loadDrawing(s);
    } catch {
      V.error("loadDrawingFromUrl() failed to load " + e), this.drawClearAllUndoBitmaps();
    }
    return i;
  }
  /**
   * Computes one or more Otsu threshold levels for the primary volume.
   * Returns raw intensity values corresponding to bin-based thresholds.
   * @internal
   */
  findOtsu(e = 2) {
    if (this.volumes.length < 1)
      return [];
    const t = this.volumes[0].img, i = t.length;
    if (i < 1)
      return [];
    const s = 256, r = s - 1, a = new Array(s).fill(0), n = this.volumes[0].cal_min, o = this.volumes[0].cal_max;
    if (o <= n)
      return [];
    const l = (o - n) / s;
    function c(A) {
      return A * l + n;
    }
    const h = (s - 1) / Math.abs(o - n), f = this.volumes[0].hdr.scl_inter, d = this.volumes[0].hdr.scl_slope;
    for (let A = 0; A < i; A++) {
      let x = t[A] * d + f;
      x = Math.min(Math.max(x, n), o), x = Math.round((x - n) * h), a[x]++;
    }
    const u = Array(s).fill(0).map(() => Array(s).fill(0)), m = Array(s).fill(0).map(() => Array(s).fill(0));
    for (let A = 1; A < s; ++A)
      u[A][A] = a[A], m[A][A] = A * a[A];
    for (let A = 1; A < s - 1; ++A)
      u[1][A + 1] = u[1][A] + a[A + 1], m[1][A + 1] = m[1][A] + (A + 1) * a[A + 1];
    for (let A = 2; A < s; A++)
      for (let x = A + 1; x < s; x++)
        u[A][x] = u[1][x] - u[1][A - 1], m[A][x] = m[1][x] - m[1][A - 1];
    for (let A = 1; A < s; ++A)
      for (let x = A + 1; x < s; x++)
        u[A][x] !== 0 && (u[A][x] = m[A][x] * m[A][x] / u[A][x]);
    let g = 0;
    const p = [1 / 0, 1 / 0, 1 / 0];
    if (e > 3)
      for (let A = 0; A < s - 3; A++)
        for (let x = A + 1; x < s - 2; x++)
          for (let w = x + 1; w < s - 1; w++) {
            const v = u[0][A] + u[A + 1][x] + u[x + 1][w] + u[w + 1][r];
            v > g && (p[0] = A, p[1] = x, p[2] = w, g = v);
          }
    else if (e === 3)
      for (let A = 0; A < s - 2; A++)
        for (let x = A + 1; x < s - 1; x++) {
          const w = u[0][A] + u[A + 1][x] + u[x + 1][r];
          w > g && (p[0] = A, p[1] = x, g = w);
        }
    else
      for (let A = 0; A < s - 1; A++) {
        const x = u[0][A] + u[A + 1][r];
        x > g && (p[0] = A, g = x);
      }
    return [c(p[0]), c(p[1]), c(p[2])];
  }
  /**
   * remove dark voxels in air
   * @param levels - (2-4) segment brain into this many types. For example drawOtsu(2) will create a binary drawing where bright voxels are colored and dark voxels are clear.
   * @example niivue.drawOtsu(3);
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  drawOtsu(e = 2) {
    if (this.volumes.length === 0)
      return;
    const t = this.volumes[0].img.length, i = this.findOtsu(e);
    if (i.length < 3)
      return;
    this.drawBitmap || this.createEmptyDrawing();
    const s = this.drawBitmap, r = this.volumes[0].img;
    for (let a = 0; a < t; a++) {
      if (s[a] !== 0)
        continue;
      const n = r[a];
      n > i[0] && (s[a] = 1), n > i[1] && (s[a] = 2), n > i[2] && (s[a] = 3);
    }
    this.drawAddUndoBitmap(), this.refreshDrawing(!0);
  }
  /**
   * remove dark voxels in air
   * @param level - (1-5) larger values for more preserved voxels
   * @param volIndex - volume to dehaze
   * @example niivue.removeHaze(3, 0);
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  removeHaze(e = 5, t = 0) {
    const i = this.volumes[t].img, s = this.volumes[t].hdr, r = i.length;
    let a = 2;
    (e === 5 || e === 1) && (a = 4), (e === 4 || e === 2) && (a = 3);
    const n = this.findOtsu(a);
    if (n.length < 3)
      return;
    let o = n[0];
    e === 1 && (o = n[2]), e === 2 && (o = n[1]);
    const l = s.scl_inter, c = s.scl_slope, h = this.volumes[t].global_min;
    for (let f = 0; f < r; f++)
      i[f] * c + l < o && (i[f] = h);
    this.refreshLayers(this.volumes[t], 0), this.drawScene();
  }
  /**
   * Save voxel-based image to disk.
   *
   * @param options - configuration object with the following fields:
   *   - `filename`: name of the NIfTI image to create
   *   - `isSaveDrawing`: whether to save the drawing layer or the background image
   *   - `volumeByIndex`: which image layer to save (0 for background)
   * @returns `true` if successful when writing to disk, or a `Uint8Array` if exported as binary data
   *
   * @example
   * niivue.saveImage({ filename: "myimage.nii.gz", isSaveDrawing: true });
   * niivue.saveImage({ filename: "myimage.nii.gz", isSaveDrawing: true });
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  async saveImage(e = Cr) {
    var n;
    const t = {
      ...Cr,
      ...e
    }, { filename: i, isSaveDrawing: s, volumeByIndex: r } = t;
    return V.debug("saveImage", i, s, r), ((n = this.back) == null ? void 0 : n.dims) === void 0 ? (V.debug("No voxelwise image open"), !1) : s ? this.drawBitmap ? await this.volumes[0].saveToDisk(i, this.drawBitmap) : (V.debug("No drawing open"), !1) : (V.debug("saving image"), this.volumes[r].saveToDisk(i));
  }
  /**
   * Returns the index of a mesh given its ID or index.
   *
   * @param id - The mesh ID as a string, or an index number.
   * @returns The mesh index, or -1 if not found or out of range.
   */
  getMeshIndexByID(e) {
    if (typeof e == "number")
      return e >= this.meshes.length ? -1 : e;
    const t = this.meshes.length;
    for (let i = 0; i < t; i++)
      if (this.meshes[i].id === e)
        return i;
    return -1;
  }
  /**
   * change property of mesh, tractogram or connectome
   * @param id - identity of mesh to change
   * @param key - attribute to change
   * @param val - for attribute
   * @example niivue.setMeshProperty(niivue.meshes[0].id, 'fiberLength', 42)
   * @see {@link https://niivue.com/demos/features/meshes.html | live demo usage}
   */
  setMeshProperty(e, t, i) {
    const s = this.getMeshIndexByID(e);
    if (s < 0) {
      V.warn("setMeshProperty() id not loaded", e);
      return;
    }
    this.meshes[s].setProperty(t, i, this.gl), this.updateGLVolume(), this.onMeshPropertyChanged(s, t, i);
  }
  /**
   * returns the index of the mesh vertex that is closest to the provided coordinates
   * @param mesh - identity of mesh to change
   * @param Xmm - location in left/right dimension
   * @param Ymm - location in posterior/anterior dimension
   * @param Zmm - location in foot/head dimension
   * @returns the an array where ret[0] is the mesh index and ret[1] is distance from vertex to coordinates
   * @example niivue.indexNearestXYZmm(niivue.meshes[0].id, -22, 42, 13)
   * @see {@link https://niivue.com/demos/features/clipplanes.html | live demo usage}
   */
  indexNearestXYZmm(e, t, i, s) {
    const r = this.getMeshIndexByID(e);
    return r < 0 ? (V.warn("indexNearestXYZmm() id not loaded", e), [NaN, NaN]) : this.meshes[r].indexNearestXYZmm(t, i, s);
  }
  /**
   * reduce complexity of FreeSurfer mesh
   * @param mesh - identity of mesh to change
   * @param order - decimation order 0..6
   * @example niivue.decimateHierarchicalMesh(niivue.meshes[0].id, 4)
   * @returns boolean false if mesh is not hierarchical or of lower order
   * @see {@link https://niivue.com/demos/features/meshes.html | live demo usage}
   */
  decimateHierarchicalMesh(e, t = 3) {
    const i = this.getMeshIndexByID(e);
    if (i < 0) {
      V.warn("reverseFaces() id not loaded", e);
      return;
    }
    const s = this.meshes[i].decimateHierarchicalMesh(this.gl, t);
    return this.updateGLVolume(), s;
  }
  /**
   * reverse triangle winding of mesh (swap front and back faces)
   * @param mesh - identity of mesh to change
   * @example niivue.reverseFaces(niivue.meshes[0].id)
   * @see {@link https://niivue.com/demos/features/meshes.html | live demo usage}
   */
  reverseFaces(e) {
    const t = this.getMeshIndexByID(e);
    if (t < 0) {
      V.warn("reverseFaces() id not loaded", e);
      return;
    }
    this.meshes[t].reverseFaces(this.gl), this.updateGLVolume();
  }
  /**
   * reverse triangle winding of mesh (swap front and back faces)
   * @param mesh - identity of mesh to change
   * @param layer - selects the mesh overlay (e.g. GIfTI or STC file)
   * @param key - attribute to change
   * @param val - value for attribute
   * @example niivue.setMeshLayerProperty(niivue.meshes[0].id, 0, 'frame4D', 22)
   * @see {@link https://niivue.com/demos/features/mesh.4D.html | live demo usage}
   */
  async setMeshLayerProperty(e, t, i, s) {
    const r = this.getMeshIndexByID(e);
    if (r < 0) {
      V.warn("setMeshLayerProperty() id not loaded", e);
      return;
    }
    await this.meshes[r].setLayerProperty(t, i, s, this.gl), this.updateGLVolume();
  }
  /**
   * adjust offset position and scale of 2D sliceScale
   * @param xyzmmZoom - first three components are spatial, fourth is scaling
   * @example niivue.setPan2Dxyzmm([5,-4, 2, 1.5])
   */
  setPan2Dxyzmm(e) {
    this.scene.pan2Dxyzmm = e, this.opts.yoke3Dto2DZoom && (this.scene.volScaleMultiplier = e[3]), this.drawScene();
  }
  /**
   * set rotation of 3D render view
   * @example niivue.setRenderAzimuthElevation(45, 15)
   * @see {@link https://niivue.com/demos/features/mask.html | live demo usage}
   */
  setRenderAzimuthElevation(e, t) {
    this.scene.renderAzimuth = e, this.scene.renderElevation = t, this.onAzimuthElevationChange(e, t), this.drawScene();
  }
  /**
   * get the index of an overlay by its unique id. unique ids are assigned to the NVImage.id property when a new NVImage is created.
   * @param id - the id string to search for
   * @see NiiVue#getVolumeIndexByID
   * @example
   * niivue = new Niivue()
   * niivue.getOverlayIndexByID(someVolume.id)
   */
  getOverlayIndexByID(e) {
    const t = this.overlays.length;
    for (let i = 0; i < t; i++)
      if (this.overlays[i].id === e)
        return i;
    return -1;
  }
  /**
   * set the index of a volume. This will change it's ordering and appearance if there are multiple volumes loaded.
   * @param volume - the volume to update
   * @param toIndex - the index to move the volume to. The default is the background (0 index)
   * @example
   * niivue = new Niivue()
   * niivue.setVolume(someVolume, 1) // move it to the second position in the array of loaded volumes (0 is the first position)
   */
  setVolume(e, t = 0) {
    const i = this.volumes.length;
    if (t > i)
      return;
    const s = this.getVolumeIndexByID(e.id);
    t === 0 ? (this.volumes.splice(s, 1), this.volumes.unshift(e), this.back = this.volumes[0], this.overlays = this.volumes.slice(1)) : t < 0 ? (this.volumes.splice(this.getVolumeIndexByID(e.id), 1), this.back = this.volumes[0], this.volumes.length > 1 ? this.overlays = this.volumes.slice(1) : this.overlays = []) : (this.volumes.splice(s, 1), this.volumes.splice(t, 0, e), this.overlays = this.volumes.slice(1), this.back = this.volumes[0]), this.updateGLVolume();
  }
  /**
   * Reorders a mesh within the internal mesh list.
   *
   * @param mesh - The `NVMesh` instance to reposition.
   * @param toIndex - Target index to move the mesh to.
   *   - If `0`, moves mesh to the front.
   *   - If `< 0`, removes the mesh.
   *   - If within bounds, inserts mesh at the specified index.
   */
  setMesh(e, t = 0) {
    this.meshes.forEach((r) => {
      V.debug("MESH: ", r.name);
    });
    const i = this.meshes.length;
    if (t > i)
      return;
    const s = this.getMeshIndexByID(e.id);
    t === 0 ? (this.meshes.splice(s, 1), this.meshes.unshift(e)) : t < 0 ? this.meshes.splice(this.getMeshIndexByID(e.id), 1) : (this.meshes.splice(s, 1), this.meshes.splice(t, 0, e)), this.updateGLVolume(), this.meshes.forEach((r) => {
      V.debug(r.name);
    });
  }
  /**
   * Remove a volume
   * @param volume - volume to delete
   * @example
   * niivue = new Niivue()
   * niivue.removeVolume(this.volumes[3])
   * @see {@link https://niivue.com/demos/features/document.3d.html | live demo usage}
   */
  removeVolume(e) {
    if (this.setVolume(e, -1), this.mediaUrlMap.has(e)) {
      const t = this.mediaUrlMap.get(e);
      this.onVolumeWithUrlRemoved(t), this.mediaUrlMap.delete(e);
    }
    this.drawScene();
  }
  /**
   * Remove a volume from the scene by its index
   * @param index - index of the volume to remove
   * @throws if the index is out of bounds
   * @see {@link https://niivue.com/demos/features/clusterize.html | live demo usage}
   */
  removeVolumeByIndex(e) {
    if (e >= this.volumes.length)
      throw new Error("Index of volume out of bounds");
    this.removeVolume(this.volumes[e]);
  }
  /**
   * Remove a triangulated mesh, connectome or tractogram
   * @param mesh - mesh to delete
   * @example
   * niivue = new Niivue()
   * niivue.removeMesh(this.meshes[3])
   * @see {@link https://niivue.com/demos/features/connectome.html | live demo usage}
   */
  removeMesh(e) {
    if (e.unloadMesh(this.gl), this.setMesh(e, -1), this.mediaUrlMap.has(e)) {
      const t = this.mediaUrlMap.get(e);
      this.onMeshWithUrlRemoved(t), this.mediaUrlMap.delete(e);
    }
  }
  /**
   * Remove a triangulated mesh, connectome or tractogram
   * @param url - URL of mesh to delete
   * @example
   * niivue.removeMeshByUrl('../images/cit168.mz3')
   */
  removeMeshByUrl(e) {
    const t = this.getMediaByUrl(e);
    t && (this.removeMesh(t), this.mediaUrlMap.delete(t), this.onMeshWithUrlRemoved(e));
  }
  /**
   * Move a volume to the bottom of the stack of loaded volumes. The volume will become the background
   * @param volume - the volume to move
   * @example
   * niivue = new Niivue()
   * niivue.moveVolumeToBottom(this.volumes[3]) // move the 4th volume to the 0 position. It will be the new background
   */
  moveVolumeToBottom(e) {
    this.setVolume(e, 0);
  }
  /**
   * Move a volume up one index position in the stack of loaded volumes. This moves it up one layer
   * @param volume - the volume to move
   * @example
   * niivue = new Niivue()
   * niivue.moveVolumeUp(this.volumes[0]) // move the background image to the second index position (it was 0 index, now will be 1)
   */
  moveVolumeUp(e) {
    const t = this.getVolumeIndexByID(e.id);
    this.setVolume(e, t + 1);
  }
  /**
   * Move a volume down one index position in the stack of loaded volumes. This moves it down one layer
   * @param volume - the volume to move
   * @example
   * niivue = new Niivue()
   * niivue.moveVolumeDown(this.volumes[1]) // move the second image to the background position (it was 1 index, now will be 0)
   */
  moveVolumeDown(e) {
    const t = this.getVolumeIndexByID(e.id);
    this.setVolume(e, t - 1);
  }
  /**
   * Move a volume to the top position in the stack of loaded volumes. This will be the top layer
   * @param volume - the volume to move
   * @example
   * niivue = new Niivue()
   * niivue.moveVolumeToTop(this.volumes[0]) // move the background image to the top layer position
   */
  moveVolumeToTop(e) {
    this.setVolume(e, this.volumes.length - 1);
  }
  /**
   * Records the current mouse position in screen space (adjusted for device pixel ratio).
   * @internal
   */
  mouseDown(e, t) {
    e *= this.uiData.dpr, t *= this.uiData.dpr, this.mousePos = [e, t];
  }
  /**
   * Updates mouse position
   * @internal
   */
  updateMousePos(e, t) {
    return e *= this.uiData.dpr, t *= this.uiData.dpr, this.mousePos = [e, t], [e, t];
  }
  /**
   *  and modifies 3D render view if the pointer is in the render tile.
   *
   * @internal
   */
  mouseMove(e, t) {
    e *= this.uiData.dpr, t *= this.uiData.dpr;
    const i = (e - this.mousePos[0]) / this.uiData.dpr, s = (t - this.mousePos[1]) / this.uiData.dpr;
    this.mousePos = [e, t], !(this.inRenderTile(e, t) < 0) && (Math.abs(i) < 1 && Math.abs(s) < 1 || (this.scene.renderAzimuth += i, this.scene.renderElevation += s, this.drawScene()));
  }
  /**
   * convert spherical AZIMUTH, ELEVATION to Cartesian
   * @param azimuth - azimuth number
   * @param elevation - elevation number
   * @returns the converted [x, y, z] coordinates
   * @example
   * niivue = new Niivue()
   * xyz = niivue.sph2cartDeg(42, 42)
   * @internal
   */
  sph2cartDeg(e, t) {
    const i = -t * (Math.PI / 180), s = (e - 90) % 360 * (Math.PI / 180), r = [Math.cos(i) * Math.cos(s), Math.cos(i) * Math.sin(s), Math.sin(i)], a = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
    return a <= 0 || (r[0] /= a, r[1] /= a, r[2] /= a), r;
  }
  /**
   * Set multiple clip planes from their depth/azimuth/elevation definitions.
   *
   *  depth: distance of clip plane from center of volume, range 0..~1.73
   *         (e.g. 2.0 for no clip plane)
   *  azimuth: camera position in degrees around object, typically 0..360
   *           (or -180..+180)
   *  elevation: camera height in degrees, range -90..90
   *
   * This replaces the entire `clipPlanes` and `clipPlaneDepthAziElevs` arrays,
   * ensuring they always have the same length.
   *
   * @param depthAziElevs - array of `[depth, azimuthDeg, elevationDeg]` values
   * @see {@link https://niivue.com/demos/features/clipplanesmulti.html | live demo usage}
   */
  setClipPlanes(e) {
    this.scene.clipPlanes = [], this.scene.clipPlaneDepthAziElevs = [];
    for (let t = 0; t < e.length; t++) {
      const i = e[t], s = this.sph2cartDeg(i[1], i[2]), r = -i[0], a = [s[0], s[1], s[2], r];
      this.scene.clipPlanes.push(a), this.scene.clipPlaneDepthAziElevs.push(i);
    }
    this.drawScene();
  }
  /**
   * Update the clip plane orientation in 3D view mode.
   * @param depthAzimuthElevation - a 3-component array:
   *   - `depth`: distance of clip plane from center of volume (0 to ~1.73, or >2.0 to disable clipping)
   *   - `azimuth`: camera angle around the object in degrees (0360 or -180180)
   *   - `elevation`: camera height in degrees (-90 to 90)
   * @example
   * niivue = new Niivue()
   * niivue.setClipPlane([42, 42])
   * @see {@link https://niivue.com/demos/features/mask.html | live demo usage}
   */
  setClipPlane(e) {
    if (!e || e.length === 0)
      return;
    const t = this.uiData.activeClipPlaneIndex ?? 0;
    for (this.scene.clipPlanes || (this.scene.clipPlanes = []), this.scene.clipPlaneDepthAziElevs || (this.scene.clipPlaneDepthAziElevs = []); this.scene.clipPlanes.length <= t; )
      this.scene.clipPlanes.push([0, 0, 0, 2]);
    for (; this.scene.clipPlaneDepthAziElevs.length <= t; )
      this.scene.clipPlaneDepthAziElevs.push([2, 0, 0]);
    const i = this.sph2cartDeg(e[1] + 180, e[2]), s = [i[0], i[1], i[2], e[0]];
    this.scene.clipPlanes[t] = s, this.scene.clipPlaneDepthAziElevs[t] = e, this.onClipPlaneChange(s), this.drawScene();
  }
  /**
   * set the crosshair and colorbar outline color
   * @param color - an RGBA array. values range from 0 to 1
   * @example
   * niivue = new Niivue()
   * niivue.setCrosshairColor([0, 1, 0, 0.5]) // set crosshair to transparent green
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  setCrosshairColor(e) {
    this.opts.crosshairColor = e, this.drawScene();
  }
  /**
   * set thickness of crosshair
   * @example niivue.crosshairWidth(2)
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  setCrosshairWidth(e) {
    this.opts.crosshairWidth = e, this.crosshairs3D && (this.crosshairs3D.mm[0] = NaN), this.drawScene();
  }
  /*
   * set colors and labels for different drawing values
   * @param {array} cmap a structure mapping indices to colors and labels
   * @example
   * let cmap = {
   *    R: [0, 255, 0],
   *    G: [0, 20, 0],
   *    B: [0, 20, 80],
   *    A: [0, 255, 255],
   *    labels: ["", "white-matter", "delete T1"],
   *  };
   *  nv.setDrawColormap(cmap);
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  setDrawColormap(e) {
    this.drawLut = rt.makeDrawLut(e), this.updateGLVolume();
  }
  /**
   * does dragging over a 2D slice create a drawing?
   * @param trueOrFalse - enabled (true) or not (false)
   * @example niivue.setDrawingEnabled(true)
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  setDrawingEnabled(e) {
    this.opts.drawingEnabled = e, this.opts.drawingEnabled ? this.drawBitmap || this.createEmptyDrawing() : (this.clickToSegmentIsGrowing && (this.clickToSegmentIsGrowing = !1, this.refreshDrawing(!0, !1)), this.drawPenLocation = [NaN, NaN, NaN], this.drawPenAxCorSag = -1, this.drawPenFillPts = [], this.drawShapeStartLocation = [NaN, NaN, NaN], this.drawShapePreviewBitmap && (this.drawBitmap = this.drawShapePreviewBitmap, this.drawShapePreviewBitmap = null)), this.drawScene();
  }
  /**
   * determine color and style of drawing
   * @param penValue - sets the color of the pen
   * @param isFilledPen - determines if dragging creates flood-filled shape
   * @example niivue.setPenValue(1, true)
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  setPenValue(e, t = !1) {
    this.opts.penValue = e, this.opts.isFilledPen = t, this.drawScene();
  }
  /**
   * control whether drawing is transparent (0), opaque (1) or translucent (between 0 and 1).
   * @param opacity - translucency of drawing
   * @example niivue.setDrawOpacity(0.7)
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  setDrawOpacity(e) {
    this.drawOpacity = e, this.drawScene();
  }
  /**
   * set the selection box color. A selection box is drawn when you right click and drag to change image contrast
   * @param color - an RGBA array. values range from 0 to 1
   * @example
   * niivue = new Niivue()
   * niivue.setSelectionBoxColor([0, 1, 0, 0.5]) // set to transparent green
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  setSelectionBoxColor(e) {
    this.opts.selectionBoxColor = e;
  }
  /**
   * Update the drawing bounds for this Niivue instance.
   *
   * @param bounds - [x1, y1, x2, y2] in normalized (01) coordinates.
   *
   * Example:
   *   nv.setBounds([0,0,0.5,0.5])   // top-left quarter
   *   nv.setBounds([0.5,0.5,1,1])   // bottom-right quarter
   */
  setBounds(e) {
    if (!Array.isArray(e) || e.length !== 4)
      throw new Error("setBounds: expected [x1,y1,x2,y2] array");
    this.opts.bounds = [
      [e[0], e[1]],
      [e[2], e[3]]
    ], this.gl && this.drawScene();
  }
  /**
   * Handles mouse wheel or trackpad scroll to change slices, zoom, or frame depending on context.
   * @internal
   */
  sliceScroll2D(e, t, i, s = !0) {
    if (this.opts.scrollRequiresFocus && this.canvas !== document.activeElement) {
      V.warn("Canvas element does not have focus. Scroll events will not be processed.");
      return;
    }
    if (this.inGraphTile(t, i)) {
      let r = this.volumes[0].frame4D;
      e > 0 && r++, e < 0 && r--, this.setFrame4D(this.volumes[0].id, r);
      return;
    }
    if (e !== 0 && this.opts.dragMode === 3 && this.inRenderTile(this.uiData.dpr * t, this.uiData.dpr * i) === -1) {
      let r = this.scene.pan2Dxyzmm[3] * (1 + 10 * e);
      r = Math.round(r * 10) / 10;
      const a = this.scene.pan2Dxyzmm[3] - r;
      this.opts.yoke3Dto2DZoom && (this.scene.volScaleMultiplier = r), this.scene.pan2Dxyzmm[3] = r;
      const n = this.frac2mm(this.scene.crosshairPos);
      this.scene.pan2Dxyzmm[0] += a * n[0], this.scene.pan2Dxyzmm[1] += a * n[1], this.scene.pan2Dxyzmm[2] += a * n[2], this.drawScene(), this.canvas.focus(), this.sync();
      return;
    }
    this.mouseClick(t, i, e, s);
  }
  /**
   * set the slice type. This changes the view mode
   * @param st - sliceType is an enum of slice types to use
   * @example
   * niivue = new Niivue()
   * niivue.setSliceType(Niivue.sliceTypeMultiplanar)
   * @see {@link https://niivue.com/demos/features/basic.multiplanar.html | live demo usage}
   */
  setSliceType(e) {
    return this.opts.sliceType = e, this.drawScene(), this;
  }
  /**
   * set the opacity of a volume given by volume index
   * @param volIdx - the volume index of the volume to change
   * @param newOpacity - the opacity value. valid values range from 0 to 1. 0 will effectively remove a volume from the scene
   * @example
   * niivue = new Niivue()
   * niivue.setOpacity(0, 0.5) // make the first volume transparent
   * @see {@link https://niivue.com/demos/features/atlas.html | live demo usage}
   */
  setOpacity(e, t) {
    this.volumes[e].opacity = t, this.updateGLVolume();
  }
  /**
   * set the scale of the 3D rendering. Larger numbers effectively zoom.
   * @param scale - the new scale value
   * @example
   * niivue.setScale(2) // zoom some
   * @see {@link https://niivue.com/demos/features/shiny.volumes.html | live demo usage}
   */
  setScale(e) {
    this.scene.volScaleMultiplier = e, this.drawScene();
  }
  /**
   * Set the color of the 3D clip plane.
   * @param {number[]} color - An array of RGBA values.
   *   - **R**, **G**, **B** components range from `0.0` to `1.0`.
   *   - **A** (alpha) component ranges from `-1.0` to `1.0`, where:
   *       - `0.01.0`  controls background translucency.
   *       - `-1.00.0`  applies translucent shading to the volume instead of the background.
   *
   * @example
   * niivue.setClipPlaneColor([1, 1, 1, 0.5]);   // white, translucent background
   * niivue.setClipPlaneColor([1, 1, 1, -0.5]);  // white, translucent shading
   * @see {@link https://niivue.com/demos/features/clipplanes.html | Live demo usage}
   */
  setClipPlaneColor(e) {
    this.opts.clipPlaneColor = e, this.renderShader.use(this.gl), this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor, this.opts.clipPlaneColor), this.drawScene();
  }
  /**
   * @deprecated This method has been removed.
   * Use {@link setClipPlanes} instead, which generalizes clip plane configuration
   * @see {@link https://niivue.com/demos/features/clipplanesmulti.html | Multiple clip plane demo}
   */
  setClipPlaneThick(e) {
    V.warn("setClipPlaneThick() has been removed. use setClipPlanes() instead.");
  }
  /**
   * @deprecated This method has been removed.
   * Use {@link setClipPlanes} instead, which generalizes clip plane configuration
   * @see {@link https://niivue.com/demos/features/clipplanesmulti.html | Multiple clip plane demo}
   */
  setClipVolume(e, t) {
    V.warn("setClipVolume() has been removed. use setClipPlanes() instead.");
  }
  /**
   * set proportion of volume rendering influenced by selected matcap.
   * @param gradientAmount - amount of matcap (NaN or 0..1), default 0 (matte, surface normal does not influence color). NaN renders the gradients.
   * @example
   * niivue.setVolumeRenderIllumination(0.6);
   * @see {@link https://niivue.com/demos/features/shiny.volumes.html | live demo usage}
   * @see {@link https://niivue.com/demos/features/gradient.order.html | live demo usage}
   */
  async setVolumeRenderIllumination(e = 0) {
    this.renderGradientValues = Number.isNaN(e), this.renderShader = this.renderVolumeShader, this.renderGradientValues ? this.renderShader = this.renderGradientValuesShader : (this.opts.gradientAmount = e, e > 0 || this.opts.gradientOpacity > 0 ? this.renderShader = this.renderGradientShader : e < 0 && (this.renderShader = this.renderSliceShader)), await this.refreshLayers(this.volumes[0], 0), this.initRenderShader(this.renderShader, e), this.renderShader.use(this.gl), this.setClipPlaneColor(this.opts.clipPlaneColor), Number.isNaN(e) ? this.gradientTextureAmount = 1 : this.gradientTextureAmount = e, !(this.volumes.length < 1) && this.drawScene();
  }
  /**
   * set volume rendering opacity influence of the gradient magnitude
   * @param gradientOpacity - amount of gradient magnitude influence on opacity (0..1), default 0 (no-influence)
   * @param renderSilhouette - make core transparent to enhance rims (0..1), default 0 (no-influence)
   * @example
   * niivue.setGradientOpacity(0.6);
   * @see {@link https://niivue.com/demos/features/gradient.opacity.html | live demo usage}
   */
  async setGradientOpacity(e = 0, t = 0) {
    this.opts.gradientOpacity = e, this.opts.renderSilhouette = t, this.renderGradientValues ? this.renderShader = this.renderGradientValuesShader : this.gradientTextureAmount > 0 || e > 0 ? this.renderShader = this.renderGradientShader : this.gradientTextureAmount < 0 && (this.renderShader = this.renderSliceShader), this.initRenderShader(this.renderShader, this.gradientTextureAmount), this.renderShader.use(this.gl), this.gradientTextureAmount > 0 && this.refreshLayers(this.volumes[0], 0), this.drawScene();
  }
  /**
   * Generates a placeholder RGBA overlay of a green sphere for testing purposes only.
   * @internal
   * @remarks Marked for future removal  creates a test sphere, not intended for production use.
   */
  overlayRGBA(e) {
    const t = e.hdr, i = t.dims[1] * t.dims[2] * t.dims[3], s = new Uint8ClampedArray(i * 4), r = 0.2 * Math.min(Math.min(t.dims[1], t.dims[2]), t.dims[3]), a = 0.5 * t.dims[1], n = 0.5 * t.dims[2], o = 0.5 * t.dims[3];
    let l = 0;
    for (let c = 0; c < t.dims[3]; c++)
      for (let h = 0; h < t.dims[2]; h++)
        for (let f = 0; f < t.dims[1]; f++) {
          const d = Math.abs(f - a), u = Math.abs(h - n), m = Math.abs(c - o), g = Math.sqrt(d * d + u * u + m * m);
          let p = 0;
          g < r && (p = 255), s[l++] = 0, s[l++] = p, s[l++] = 0, s[l++] = p * 0.5;
        }
    return s;
  }
  /**
   * Convert voxel coordinates to millimeters using a transformation matrix.
   * @internal
   */
  vox2mm(e, t) {
    return H.vox2mm(e, t);
  }
  /**
   * clone a volume and return a new volume
   * @param index - the index of the volume to clone
   * @returns new volume to work with, but that volume is not added to the canvas
   * @example
   * niivue = new Niivue()
   * niivue.cloneVolume(0)
   */
  cloneVolume(e) {
    return this.volumes[e].clone();
  }
  /**
   * Loads an NVDocument from a URL and integrates it into the scene.
   */
  async loadDocumentFromUrl(e) {
    const t = await zi.loadFromUrl(e);
    await this.loadDocument(t);
  }
  /**
   * Loads an NVDocument
   * @returns  Niivue instance
   * @see {@link https://niivue.com/demos/features/document.load.html | live demo usage}
   */
  async loadDocument(e) {
    this.volumes = [], this.meshes = [], this.document = e, this.document.labels = this.document.labels ? this.document.labels : [];
    const t = { ...kt, ...e.opts };
    this.scene.pan2Dxyzmm = e.scene.pan2Dxyzmm ? e.scene.pan2Dxyzmm : [0, 0, 0, 1], this.document.opts = t, this.scene.clipPlaneDepthAziElevs && this.setClipPlane(this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex ?? 0]), V.debug("load document", e), this.mediaUrlMap.clear(), this.createEmptyDrawing();
    const i = e.encodedImageBlobs;
    for (let r = 0; r < e.imageOptionsArray.length; r++) {
      const a = e.imageOptionsArray[r], n = i[r];
      if (n) {
        "colorMap" in a && (a.colormap = a.colorMap);
        const o = await Mt.loadFromBase64({ base64: n, ...a });
        if (o) {
          if (o.colormapLabel) {
            const l = Object.keys(o.colormapLabel.lut).length, c = new Uint8ClampedArray(l);
            for (const h in o.colormapLabel.lut)
              c[h] = o.colormapLabel.lut[h];
            o.colormapLabel.lut = c;
          }
          this.addVolume(o);
        }
      }
    }
    this.volumes.length > 0 && (this.back = this.volumes[0]);
    for (const r of e.meshDataObjects ?? []) {
      const a = { gl: this.gl, ...r };
      r.offsetPt0 && (a.rgba255[3] = 0, a.tris = new Uint32Array(r.offsetPt0)), V.debug(a);
      const n = new Ae(
        a.pts,
        a.tris,
        a.name,
        a.rgba255,
        a.opacity,
        a.visible,
        this.gl,
        a.connectome,
        a.dpg,
        a.dps,
        a.dpv
      );
      r.offsetPt0 && (n.fiberGroupColormap = r.fiberGroupColormap, n.fiberColor = r.fiberColor, n.fiberDither = r.fiberDither, n.fiberRadius = r.fiberRadius, n.colormap = r.colormap), n.meshShaderIndex = a.meshShaderIndex, n.layers = a.layers, n.updateMesh(this.gl), V.debug(n), this.addMesh(n);
    }
    if (e.data.connectomes)
      for (const r of e.data.connectomes) {
        const a = JSON.parse(r), n = this.loadConnectomeAsMesh(a);
        n.updateMesh(this.gl), this.addMesh(n);
      }
    this.createEmptyDrawing();
    const s = e.encodedDrawingBlob;
    if (s) {
      const r = await H.b64toUint8(s);
      if (r) {
        const a = this.back.dims;
        let n = a[1] * a[2] * a[3];
        if (r.length - 352 === n && (n += 352), r.length !== n)
          throw new Error(
            `drawBitmap size does not match the texture dimensions (${a[1]}${a[2]}${a[3]}) ${n} != ${a[1] * a[2] * a[3]}.`
          );
        this.drawBitmap = r, this.refreshDrawing();
      }
    }
    return await this.setGradientOpacity(this.opts.gradientOpacity), await this.setVolumeRenderIllumination(this.opts.gradientAmount), this.updateGLVolume(), this.drawScene(), this.onDocumentLoaded(e), this;
  }
  /**
  * generates JavaScript to load the current scene as a document
  * @param canvasId - id of canvas NiiVue will be attached to
  * @param esm - bundled version of NiiVue
  * @example
  * const javascript = this.generateLoadDocumentJavaScript("gl1");
  * const html = `<html><body><canvas id="gl1"></canvas><script type="module" async>
         ${javascript}<\/script></body></html>`;
  * @see {@link https://niivue.com/demos/features/save.custom.html.html | live demo usage}
  */
  async generateLoadDocumentJavaScript(e, t) {
    const i = this.json(), s = await H.compressToBase64String(JSON.stringify(i));
    return `
        ${t}

        async function saveNiivueAsHtml(pageName) {
          //get new docstring
          const docString = nv1.json();
          const html =
          document.getElementsByTagName("html")[0]
              .innerHTML.replace(base64, await NVUtilities.compressToBase64String(JSON.stringify(docString)));
          NVUtilities.download(html, pageName, "application/html");
        }

        var nv1 = new Niivue();
        await nv1.attachTo("${e}");
        var base64 = "${s}";
        NVUtilities.decompressBase64String(base64).then((jsonText) => {
          var json = JSON.parse(jsonText); // string -> JSON
          var doc = NVDocument.loadFromJSON(json);
          nv1.loadDocument(doc);
          nv1.updateGLVolume();
        });

      `;
  }
  /**
   * generates HTML of current scene
   * @param canvasId - id of canvas NiiVue will be attached to
   * @param esm - bundled version of NiiVue
   * @returns HTML with javascript of the current scene
   * @example
   * const template = `<html><body><canvas id="gl1"></canvas><script type="module" async>
   *       %%javascript%%<\/script></body></html>`;
   * nv1.generateHTML("page.html", esm);
   */
  async generateHTML(e = "gl1", t) {
    return `<!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <meta http-equiv="X-UA-Compatible" content="IE=edge" />
            <meta name="viewport" content="width=device-width,initial-scale=1.0" />
            <title>Save as HTML</title>
            <style>
            html {
              height: auto;
              min-height: 100%;
              margin: 0;
            }
            body {
              display: flex;
              flex-direction: column;
              margin: 0;
              min-height: 100%;
              width: 100%;
              position: absolute;
              font-family: system-ui, Arial, Helvetica, sans-serif;
              background: #ffffff;
              color: black;
              user-select: none; /* Standard syntax */
            }
            header {
              margin: 10px;
            }
            main {
              flex: 1;
              background: #000000;
              position: relative;
            }
            footer {
              margin: 10px;
            }
            canvas {
              position: absolute;
              cursor: crosshair;
            }
            canvas:focus {
              outline: 0px;
            }
            div {
              display: table-row;
              background-color: blue;
            }
            </style>
          </head>
          <body>
            <noscript>niivue requires JavaScript.</noscript>
            <header>
            Save the current scene as HTML
            <button id="save">Save as HTML</button>
            </header>
            <main>
              <canvas id="gl1"></canvas>
            </main>
            <script type="module" async>
              ${await this.generateLoadDocumentJavaScript(e, t)}
              function saveAsHtml() {
                saveNiivueAsHtml("page.html");
              }
              // assign our event handler
              var button = document.getElementById("save");
              button.onclick = saveAsHtml;
            <\/script>
          </body>
        </html>`;
  }
  /**
   * Save the current scene as a standalone HTML file
   * @param fileName - name of the HTML file to save (default: "untitled.html")
   * @param canvasId - ID of the canvas element NiiVue will attach to
   * @param esm - bundled ES module source for NiiVue
   * @returns a Promise that resolves when the file is downloaded
   * @see {@link https://niivue.com/demos/features/save.html.html | live demo usage}
   */
  async saveHTML(e = "untitled.html", t = "gl1", i) {
    const s = await this.generateHTML(t, i);
    return H.download(s, e, "application/html");
  }
  /**
   * Converts NiiVue scene to JSON
   */
  json() {
    return this.document.opts = this.opts, this.document.scene = this.scene, this.document.volumes = this.volumes, this.document.meshes = this.meshes, this.drawScene(), this.document.previewImageDataURL = this.canvas.toDataURL(), this.document.json();
  }
  /**
   * Save the current scene as an .nvd document.
   *
   * @param fileName  Name of the file to create (default "untitled.nvd")
   * @param compress  If true, gzip-compress the JSON (default true)
   * @param options   Fine-grained switches:
   *                   embedImages   store encodedImageBlobs  (default true)
   *                   embedPreview  store previewImageDataURL (default true)
   *
   * @example
   * // smallest possible file  no preview, just metadata
   * await nv.saveDocument('scene.nvd', true, { embedImages:false, embedPreview:false });
   * @see {@link https://niivue.com/demos/features/document.3d.html | live demo usage}
   */
  async saveDocument(e = "untitled.nvd", t = !0, i = {}) {
    const { embedImages: s = !0, embedPreview: r = !0 } = i;
    this.document.title = e, this.document.volumes = this.volumes, this.document.meshes = this.meshes, r ? (this.drawScene(), this.document.previewImageDataURL = this.canvas.toDataURL()) : this.document.previewImageDataURL = "", await this.document.download(e, t, { embedImages: s });
  }
  /**
   * Load an array of image or mesh URLs using appropriate handlers
   * @param images - array of image or mesh descriptors (with URL and optional name)
   * @returns a Promise resolving to the current NiiVue instance after loading completes
   * @remarks Automatically dispatches each item to either volume or mesh loader based on file extension or registered custom loader
   * @see {@link https://niivue.com/demos/features/timeseries2.html | live demo usage}
   */
  async loadImages(e) {
    const t = [], i = [];
    for (const s of e)
      if ("url" in s) {
        const r = this.getFileExt(s.name ? s.name : s.url);
        if (this.loaders[r]) {
          const a = this.loaders[r].toExt.toUpperCase();
          ee.includes(a) ? i.push(s) : t.push(s);
          continue;
        }
        ee.includes(r.toUpperCase()) ? i.push(s) : t.push(s);
      }
    return t.length > 0 && await this.loadVolumes(t), i.length > 0 && await this.loadMeshes(i), this;
  }
  async loadDicoms(e) {
    if (!this.getDicomLoader())
      throw new Error("No dicom loader set. Please set a dicom loader before loading dicoms");
    this.drawScene(), this.volumes = [];
    const t = e.map(async (s) => {
      let r = null;
      if (s.isManifest)
        r = await Mt.fetchDicomData(s.url);
      else {
        const h = await fetch(s.url);
        if (!h.ok)
          throw new Error(`Failed to load file: ${h.statusText}`);
        const f = await h.arrayBuffer();
        r = [{ name: s.url.split("/").pop(), data: f }];
      }
      const a = this.getDicomLoader().loader, n = await a(r), o = n[0].name, l = n[0].data;
      return await Mt.loadFromUrl({ url: l, name: o });
    }), i = await Promise.all(t);
    return i.length === 1 ? this.addVolume(i[0]) : this.onDicomLoaderFinishedWithImages(i), this;
  }
  /**
   * load an array of volume objects
   * @param volumeList - the array of objects to load. each object must have a resolvable "url" property at a minimum
   * @returns returns the Niivue instance
   * @example
   * niivue = new Niivue()
   * niivue.loadVolumes([{url: 'someImage.nii.gz}, {url: 'anotherImage.nii.gz'}])
   * @see {@link https://niivue.com/demos/features/mask.html | live demo usage}
   */
  async loadVolumes(e) {
    return this.drawScene(), this.thumbnailVisible ? (this.deferredVolumes = e, this) : (this.volumes = [], this.closePAQD(), await this.addVolumesFromUrl(e), this);
  }
  /**
   * Add mesh and notify subscribers
   */
  async addMeshFromUrl(e) {
    const t = this.getFileExt(e.url);
    if (t === "JCON" || t === "JSON") {
      const r = await (await fetch(e.url, {})).json(), a = this.loadConnectomeAsMesh(r);
      return this.mediaUrlMap.set(a, e.url), this.onMeshAddedFromUrl(e, a), this.addMesh(a), a;
    }
    const i = await Ae.loadFromUrl({ ...e, gl: this.gl });
    return this.mediaUrlMap.set(i, e.url), this.onMeshAddedFromUrl(e, i), this.addMesh(i), i;
  }
  /**
   * Add mesh and notify subscribers
   */
  async addMeshesFromUrl(e) {
    const t = e.map(async (s) => {
      const r = this.getFileExt(s.name || s.url);
      if (this.loaders[r]) {
        let n = s.url;
        const o = this.loaders[r].toExt;
        let l = s.name || s.url;
        if (l = l.split("/").pop(), typeof s.url == "string") {
          const u = s.url;
          try {
            const m = await fetch(u);
            if (!m.ok)
              throw new Error(`Failed to load file: ${m.statusText}`);
            n = await m.arrayBuffer();
          } catch (m) {
            throw new Error(`Failed to load url ${u}: ${m}`);
          }
        }
        const { positions: c, indices: h, colors: f = null } = await this.loaders[r].loader(n);
        s.name = `${l}.${o}`;
        const d = await ne.createMZ3Async(c, h, !1, f);
        s.buffer = d;
      }
      if (r === "JCON" || r === "JSON") {
        const o = await (await fetch(s.url, {})).json(), l = this.loadConnectomeAsMesh(o);
        return this.mediaUrlMap.set(l, s.url), this.onMeshAddedFromUrl(s, l), l;
      }
      const a = await Ae.loadFromUrl({ ...s, gl: this.gl });
      return this.mediaUrlMap.set(a, s.url), this.onMeshAddedFromUrl(s, a), a;
    }), i = await Promise.all(t);
    for (let s = 0; s < i.length; s++)
      this.addMesh(i[s]);
    return i;
  }
  /**
   * load an array of meshes
   * @param meshList - the array of objects to load. each object must have a resolvable "url" property at a minimum
   * @returns Niivue instance
   * @example
   * niivue = new Niivue()
   * niivue.loadMeshes([{url: 'someMesh.gii'}])
   * @see {@link https://niivue.com/demos/features/meshes.html | live demo usage}
   */
  async loadMeshes(e) {
    return this.drawScene(), this.thumbnailVisible ? (this.deferredMeshes = e, this) : (this.initialized, this.meshes = [], await this.addMeshesFromUrl(e), this.updateGLVolume(), this.drawScene(), this);
  }
  /**
   * Load a connectome from a given URL and initialize it.
   *
   * @param url - the URL to a JSON-formatted connectome definition
   * @param headers - optional HTTP headers to include with the request (e.g. for authorization)
   * @returns the `Niivue` instance (for method chaining)
   * @see {@link https://niivue.com/demos/features/connectome.html | live demo usage}
   */
  async loadConnectomeFromUrl(e, t = {}) {
    const s = await (await fetch(e, { headers: t })).json();
    return this.loadConnectome(s);
  }
  /**
   * Load a FreeSurfer-style connectome from a given URL and initialize it.
   * @param url - the URL of the JSON-formatted connectome file
   * @param headers - optional HTTP headers to include in the fetch request (e.g. for authorization)
   * @returns the `Niivue` instance (for method chaining)
   * @see {@link https://niivue.com/demos/features/connectome.html | live demo usage}
   */
  async loadFreeSurferConnectomeFromUrl(e, t = {}) {
    const s = await (await fetch(e, { headers: t })).json();
    return this.loadFreeSurferConnectome(s);
  }
  /**
   * load a connectome specified by json
   * @param json - freesurfer model
   * @returns Niivue instance
   * @see {@link https://niivue.com/demos/features/connectome.html | live demo usage}
   */
  async loadFreeSurferConnectome(e) {
    const t = oi.convertFreeSurferConnectome(e);
    return this.loadConnectome(t);
  }
  /**
   * Handles addition of a connectome node by adding a corresponding label and redrawing.
   * @internal
   */
  handleNodeAdded(e) {
    const t = e.detail.node, i = [1, 1, 1, 1];
    this.addLabel(
      t.name,
      {
        textColor: i,
        bulletScale: 1,
        bulletColor: i,
        lineWidth: 0,
        lineColor: i,
        lineTerminator: "none",
        textScale: 1
      },
      [t.x, t.y, t.z]
    ), this.drawScene();
  }
  /**
   * Converts various connectome JSON formats to a standardized mesh representation.
   *
   * @param json - Connectome data in current or legacy format.
   * @returns The connectome as an `NVMesh`.
   * @internal
   */
  loadConnectomeAsMesh(e) {
    let t = e;
    if ("data_type" in e && e.data_type === "fs_pointset")
      t = oi.convertFreeSurferConnectome(e), V.warn("converted FreeSurfer connectome", t);
    else if ("nodes" in e) {
      const i = e.nodes;
      "names" in i && "X" in i && "Y" in i && "Z" in i && "Color" in i && "Size" in i && (t = oi.convertLegacyConnectome(e));
    } else
      throw new Error("not a known connectome format");
    return new oi(this.gl, t);
  }
  /**
   * load a connectome specified by json
   * @param json - connectome model
   * @returns Niivue instance
   * @see {@link https://niivue.com/demos/features/connectome.html | live demo usage}
   */
  loadConnectome(e) {
    this.drawScene(), this.meshes = [];
    const t = this.loadConnectomeAsMesh(e);
    return this.addMesh(t), this.drawScene(), this;
  }
  /**
   * generate a blank canvas for the pen tool
   * @example niivue.createEmptyDrawing()
   * @see {@link https://niivue.com/demos/features/cactus.html | live demo usage}
   */
  createEmptyDrawing() {
    if (this.back === null || !this.back.dims || Math.min(Math.min(this.back.dims[1], this.back.dims[2]), this.back.dims[3]) < 1)
      return;
    const t = this.back.dims[1] * this.back.dims[2] * this.back.dims[3];
    this.drawBitmap = new Uint8Array(t), this.clickToSegmentGrowingBitmap = new Uint8Array(t), this.drawClearAllUndoBitmaps(), this.drawAddUndoBitmap(), this.opts.is2DSliceShader ? this.drawTexture = this.r8Tex2D(this.drawTexture, qt, this.back.dims) : this.drawTexture = this.r8Tex(this.drawTexture, qt, this.back.dims, !0), this.refreshDrawing(!1);
  }
  /**
   * Creates or updates a 1-component 16-bit signed integer 3D texture on the GPU.
   * @internal
   */
  r16Tex(e, t, i, s) {
    e && this.gl.deleteTexture(e), e = this.gl.createTexture(), this.gl.activeTexture(t), this.gl.bindTexture(this.gl.TEXTURE_3D, e), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16I, i[1], i[2], i[3]);
    const r = i[1] * i[2] * i[3];
    return s.length !== r && (s = new Int16Array(r)), this.gl.texSubImage3D(
      this.gl.TEXTURE_3D,
      0,
      0,
      0,
      0,
      i[1],
      i[2],
      i[3],
      this.gl.RED_INTEGER,
      this.gl.SHORT,
      s
    ), e;
  }
  /**
   * dilate drawing so all voxels are colored.
   * works on drawing with multiple colors
   * @example niivue.drawGrowCut();
   * @see {@link https://niivue.com/demos/features/draw2.html | live demo usage}
   */
  drawGrowCut() {
    if (!this.back || !this.back.dims)
      throw new Error("back not defined");
    const e = this.back.hdr, t = this.gl, i = e.dims[1] * e.dims[2] * e.dims[3];
    if (!this.drawBitmap || this.drawBitmap.length !== i) {
      V.debug("bitmap dims are wrong");
      return;
    }
    const s = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, s), t.disable(t.CULL_FACE), t.viewport(0, 0, this.back.dims[1], this.back.dims[2]), t.disable(t.BLEND);
    let r = uh(this.back);
    const a = this.r16Tex(null, xh, this.back.dims, r);
    for (let v = 1; v < i; v++)
      r[v] = this.drawBitmap[v];
    const n = this.r16Tex(null, bh, this.back.dims, r), o = this.r16Tex(null, yh, this.back.dims, r), l = 1e4;
    for (let v = 1; v < i; v++)
      r[v] > 0 && (r[v] = l);
    const c = this.r16Tex(null, vh, this.back.dims, r), h = this.r16Tex(null, wh, this.back.dims, r);
    t.bindVertexArray(this.genericVAO);
    const f = this.growCutShader;
    f.use(t);
    const d = 128;
    t.uniform1i(f.uniforms.finalPass, 0), t.uniform1i(f.uniforms.backTex, 11);
    for (let v = 0; v < d; v++) {
      t.uniform1i(f.uniforms.labelTex, 14), t.uniform1i(f.uniforms.strengthTex, 12);
      for (let F = 0; F < this.back.dims[3]; F++) {
        const C = 1 / this.back.dims[3] * (F + 0.5);
        t.uniform1f(f.uniforms.coordZ, C), t.framebufferTextureLayer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, o, 0, F), t.framebufferTextureLayer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT1, h, 0, F), t.drawBuffers([t.COLOR_ATTACHMENT0, t.COLOR_ATTACHMENT1]), t.checkFramebufferStatus(t.FRAMEBUFFER) !== t.FRAMEBUFFER_COMPLETE && V.error("Incomplete framebuffer"), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
      }
      v === d - 1 && t.uniform1i(f.uniforms.finalPass, 1), t.uniform1i(f.uniforms.labelTex, 15), t.uniform1i(f.uniforms.strengthTex, 13);
      for (let F = 0; F < this.back.dims[3]; F++) {
        const C = 1 / this.back.dims[3] * (F + 0.5);
        t.uniform1f(f.uniforms.coordZ, C), t.framebufferTextureLayer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, n, 0, F), t.framebufferTextureLayer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT1, c, 0, F), t.drawBuffers([t.COLOR_ATTACHMENT0, t.COLOR_ATTACHMENT1]), t.checkFramebufferStatus(t.FRAMEBUFFER) !== t.FRAMEBUFFER_COMPLETE && V.error("Incomplete framebuffer"), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
      }
    }
    t.drawBuffers([t.COLOR_ATTACHMENT0]);
    const u = t.COLOR_ATTACHMENT1, m = n;
    t.readBuffer(u);
    const g = t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT), p = t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE);
    (g !== t.RED_INTEGER || p !== t.SHORT) && V.debug("readPixels will fail."), r = new Int16Array();
    const A = this.back.dims[1] * this.back.dims[2], x = new Int16Array(A);
    for (let v = 0; v < this.back.dims[3]; v++)
      t.framebufferTextureLayer(
        t.FRAMEBUFFER,
        u,
        // gl.COLOR_ATTACHMENT1,//COLOR_ATTACHMENT1
        m,
        // strength1,//strength0
        0,
        v
      ), t.readPixels(0, 0, this.back.dims[1], this.back.dims[2], g, p, x), r = Int16Array.from([...r, ...x]);
    let w = r[0];
    for (let v = 0; v < r.length; v++)
      w = Math.max(w, r[v]);
    for (let v = 1; v < i; v++)
      this.drawBitmap[v] = r[v];
    t.deleteTexture(a), t.deleteTexture(c), t.deleteTexture(h), t.deleteTexture(n), t.deleteTexture(o), t.bindVertexArray(this.unusedVAO), t.viewport(0, 0, t.canvas.width, t.canvas.height), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteFramebuffer(s), this.drawAddUndoBitmap(), this.refreshDrawing(!0);
  }
  /**
   * Sets the color value of a voxel and its neighbors in the drawing bitmap.
   * @internal
   */
  drawPt(e, t, i, s, r = null) {
    var f;
    if (r === null && (r = this.drawBitmap), !((f = this.back) != null && f.dims))
      throw new Error("back.dims not set");
    const a = this.back.dims[1], n = this.back.dims[2], o = this.back.dims[3];
    e = Math.min(Math.max(e, 0), a - 1), t = Math.min(Math.max(t, 0), n - 1), i = Math.min(Math.max(i, 0), o - 1), r[e + t * a + i * a * n] = s;
    const l = this.drawPenAxCorSag === 0, c = this.drawPenAxCorSag === 1, h = this.drawPenAxCorSag === 2;
    if (this.opts.penSize > 1) {
      const d = Math.floor(this.opts.penSize / 2);
      for (let u = -d; u <= d; u++)
        for (let m = -d; m <= d; m++)
          l ? r[e + u + (t + m) * a + i * a * n] = s : c ? r[e + u + t * a + (i + m) * a * n] = s : h && (r[e + (t + m) * a + (i + u) * a * n] = s);
    }
  }
  /**
   * Draws a 3D line between two voxels in the drawing bitmap using Bresenham's algorithm.
   * @internal
   */
  drawPenLine(e, t, i) {
    const s = Math.abs(e[0] - t[0]), r = Math.abs(e[1] - t[1]), a = Math.abs(e[2] - t[2]);
    let n = -1, o = -1, l = -1;
    t[0] > e[0] && (n = 1), t[1] > e[1] && (o = 1), t[2] > e[2] && (l = 1);
    let c = e[0], h = e[1], f = e[2];
    const d = t[0], u = t[1], m = t[2];
    if (s >= r && s >= a) {
      let g = 2 * r - s, p = 2 * a - s;
      for (; c !== d; )
        c += n, g >= 0 && (h += o, g -= 2 * s), p >= 0 && (f += l, p -= 2 * s), g += 2 * r, p += 2 * a, this.drawPt(c, h, f, i);
    } else if (r >= s && r >= a) {
      let g = 2 * s - r, p = 2 * a - r;
      for (; h !== u; )
        h += o, g >= 0 && (c += n, g -= 2 * r), p >= 0 && (f += l, p -= 2 * r), g += 2 * s, p += 2 * a, this.drawPt(c, h, f, i);
    } else {
      let g = 2 * r - a, p = 2 * s - a;
      for (; f !== m; )
        f += l, g >= 0 && (h += o, g -= 2 * a), p >= 0 && (c += n, p -= 2 * a), g += 2 * r, p += 2 * s, this.drawPt(c, h, f, i);
    }
  }
  /**
   * Draw a rectangle from point A to point B
   * @internal
   */
  drawRectangleMask(e, t, i) {
    var d;
    if (!((d = this.back) != null && d.dims))
      throw new Error("back.dims not set");
    const s = this.back.dims[1], r = this.back.dims[2], a = this.back.dims[3], n = Math.min(Math.max(Math.min(e[0], t[0]), 0), s - 1), o = Math.min(Math.max(Math.min(e[1], t[1]), 0), r - 1), l = Math.min(Math.max(Math.min(e[2], t[2]), 0), a - 1), c = Math.min(Math.max(Math.max(e[0], t[0]), 0), s - 1), h = Math.min(Math.max(Math.max(e[1], t[1]), 0), r - 1), f = Math.min(Math.max(Math.max(e[2], t[2]), 0), a - 1);
    for (let u = l; u <= f; u++)
      for (let m = o; m <= h; m++)
        for (let g = n; g <= c; g++)
          this.drawPt(g, m, u, i);
  }
  /**
   * Draw an ellipse from point A to point B (treating them as opposite corners of bounding box)
   * @internal
   */
  drawEllipseMask(e, t, i) {
    var x;
    if (!((x = this.back) != null && x.dims))
      throw new Error("back.dims not set");
    const s = this.back.dims[1], r = this.back.dims[2], a = this.back.dims[3], n = Math.min(Math.max(Math.min(e[0], t[0]), 0), s - 1), o = Math.min(Math.max(Math.min(e[1], t[1]), 0), r - 1), l = Math.min(Math.max(Math.min(e[2], t[2]), 0), a - 1), c = Math.min(Math.max(Math.max(e[0], t[0]), 0), s - 1), h = Math.min(Math.max(Math.max(e[1], t[1]), 0), r - 1), f = Math.min(Math.max(Math.max(e[2], t[2]), 0), a - 1), d = (n + c) / 2, u = (o + h) / 2, m = (l + f) / 2, g = Math.abs(c - n) / 2, p = Math.abs(h - o) / 2, A = Math.abs(f - l) / 2;
    for (let w = l; w <= f; w++)
      for (let v = o; v <= h; v++)
        for (let F = n; F <= c; F++) {
          const C = (F - d) / (g + 0.5), b = (v - u) / (p + 0.5), y = (w - m) / (A + 0.5);
          C * C + b * b + y * y <= 1 && this.drawPt(F, v, w, i);
        }
  }
  /**
   * Performs a 1-voxel binary dilation on a connected cluster within the drawing mask using the drawFloodFillCore function.
   *
   * @param seedXYZ -  voxel index of the seed voxel in the mask array.
   * @param neighbors - Number of neighbors to consider for connectivity and dilation (6, 18, or 26).
   */
  drawingBinaryDilationWithSeed(e, t = 6) {
    try {
      let i = function(p) {
        return p[0] + p[1] * o + p[2] * l;
      };
      const s = this.drawBitmap, r = this.back.dims[1], a = this.back.dims[2], n = this.back.dims[3], o = r, l = r * a, c = l * n, h = i(e);
      if (h < 0 || h >= c)
        throw new Error("Seed index is out of bounds.");
      const f = s[h];
      if (f === 0)
        throw new Error("Seed voxel is not part of a filled cluster.");
      const d = s.slice();
      for (let p = 0; p < c; p++)
        d[p] = d[p] === f ? 1 : 0;
      this.drawFloodFillCore(d, h, t);
      const u = s.slice(), m = [], g = [-l, l, -r, r, -1, 1];
      m.push(...g), t > 6 && m.push(
        -r - 1,
        -r + 1,
        r - 1,
        r + 1,
        -l - r,
        -l + r,
        -l - 1,
        -l + 1,
        l - r,
        l + r,
        l - 1,
        l + 1
      ), t > 18 && m.push(
        -l - r - 1,
        -l - r + 1,
        -l + r - 1,
        -l + r + 1,
        l - r - 1,
        l - r + 1,
        l + r - 1,
        l + r + 1
      );
      for (let p = 0; p < c; p++)
        if (d[p] === 2) {
          const A = p % r, x = Math.floor(p % l / r), w = Math.floor(p / l);
          for (const v of m) {
            const F = p + v;
            if (F < 0 || F >= c)
              continue;
            const C = F % r, b = Math.floor(F % l / r), y = Math.floor(F / l);
            Math.abs(C - A) > 1 || Math.abs(b - x) > 1 || Math.abs(y - w) > 1 || s[F] === 0 && (u[F] = f);
          }
        }
      this.drawBitmap = u, this.drawAddUndoBitmap(), this.refreshDrawing(!0);
    } catch (i) {
      V.error("Error in drawingBinaryDilationWithSeed:", i);
    }
  }
  /**
   * Flood fill to cluster connected voxels based on neighbor connectivity (6, 18, or 26 neighbors).
   * Voxels with value 1 are included in the cluster and set to 2.
   * Uses a queue-based breadth-first search.
   *
   * @internal
   */
  drawFloodFillCore(e, t, i = 6) {
    var c;
    if (!((c = this.back) != null && c.dims))
      throw new Error("back.dims undefined");
    const s = [this.back.dims[1], this.back.dims[2], this.back.dims[3]], r = s[0], a = r * s[1];
    function n(h) {
      return h[0] + h[1] * r + h[2] * a;
    }
    function o(h) {
      const f = Math.floor(h / a), d = Math.floor((h - f * a) / r);
      return [Math.floor(h % r), d, f];
    }
    const l = [];
    for (l.push(t), e[t] = 2; l.length > 0; ) {
      let h = function(u) {
        const m = d.slice();
        if (m[0] += u[0], m[1] += u[1], m[2] += u[2], m[0] < 0 || m[1] < 0 || m[2] < 0 || m[0] >= s[0] || m[1] >= s[1] || m[2] >= s[2])
          return;
        const g = n(m);
        e[g] === 1 && (e[g] = 2, l.push(g));
      };
      const f = l[0];
      l.shift();
      const d = o(f);
      h([0, 0, -1]), h([0, 0, 1]), h([0, -1, 0]), h([0, 1, 0]), h([-1, 0, 0]), h([1, 0, 0]), !(i <= 6) && (h([-1, -1, 0]), h([1, 1, 0]), h([-1, 1, 0]), h([1, 1, 0]), h([0, -1, -1]), h([0, 1, -1]), h([-1, 0, -1]), h([1, 0, -1]), h([0, -1, 1]), h([0, 1, 1]), h([-1, 0, 1]), h([1, 0, 1]), !(i <= 18) && (h([-1, -1, -1]), h([1, -1, -1]), h([-1, 1, -1]), h([1, 1, -1]), h([-1, -1, 1]), h([1, -1, 1]), h([-1, 1, 1]), h([1, 1, 1])));
    }
  }
  /**
   * Performs a flood fill on the drawing bitmap starting from a seed voxel, recoloring all connected voxels
   * based on spatial connectivity, intensity constraints, and other parameters.
   * Supports 2D or 3D fills, cluster growing, distance constraints, and preview mode for clickToSegment.
   *
   * @internal
   */
  drawFloodFill(e, t = 0, i = 0, s = NaN, r = NaN, a = 6, n = Number.POSITIVE_INFINITY, o = !1, l = null, c = !1) {
    var S;
    if (!this.drawBitmap && (V.warn("drawFloodFill called without an initialized drawBitmap."), this.createEmptyDrawing(), !this.drawBitmap)) {
      V.error("Failed to create drawing bitmap.");
      return;
    }
    if (this.clickToSegmentIsGrowing && !this.clickToSegmentGrowingBitmap) {
      if (V.warn("drawFloodFill called in preview mode without initialized clickToSegmentGrowingBitmap."), this.drawBitmap)
        this.clickToSegmentGrowingBitmap = this.drawBitmap.slice();
      else {
        V.error("Cannot initialize growing bitmap as drawBitmap is null.");
        return;
      }
      if (!this.clickToSegmentGrowingBitmap) {
        V.error("Failed to create growing bitmap.");
        return;
      }
    }
    if (l === null && (l = this.drawBitmap), !l) {
      V.error("drawFloodFill targetBitmap is null.");
      return;
    }
    if (!((S = this.back) != null && S.dims))
      throw new Error("back.dims undefined");
    t = Math.abs(t);
    const h = [this.back.dims[1], this.back.dims[2], this.back.dims[3]];
    if (e[0] < 0 || e[1] < 0 || e[2] < 0 || e[0] >= h[0] || e[1] >= h[1] || e[2] >= h[2])
      return;
    const f = h[0], d = f * h[1], u = d * h[2], m = this.clickToSegmentIsGrowing ? this.drawBitmap : l;
    if (!m) {
      V.error("Could not determine original bitmap state.");
      return;
    }
    const g = new Uint8Array(u).fill(0);
    let p = -1;
    o && this.drawPenAxCorSag === 0 ? p = 2 : o && this.drawPenAxCorSag === 1 ? p = 1 : o && this.drawPenAxCorSag === 2 && (p = 0);
    function A(D) {
      const M = Math.floor(D / d), B = Math.floor((D - M * d) / f);
      return [Math.floor(D % f), B, M];
    }
    function x(D) {
      return D[0] + D[1] * f + D[2] * d;
    }
    const w = (D) => this.vox2mm(D, this.back.matRAS), v = w(e), F = n ** 2;
    function C(D) {
      const M = A(D);
      if (p >= 0 && M[p] !== e[p])
        return !1;
      const B = w(M);
      return (B[0] - v[0]) ** 2 + (B[1] - v[1]) ** 2 + (B[2] - v[2]) ** 2 <= F;
    }
    const b = x(e), y = m[b];
    if (c && y === 0) {
      V.debug("Grow/Erase Cluster tool requires starting on a masked voxel."), this.clickToSegmentIsGrowing && this.clickToSegmentGrowingBitmap && this.drawBitmap && (this.clickToSegmentGrowingBitmap.set(this.drawBitmap), this.refreshDrawing(!0, !0));
      return;
    }
    if (i === 0 && y === t && !c && t !== 0 && (V.debug("drawFloodFill selected voxel is already desired color"), !this.clickToSegmentIsGrowing))
      return;
    let E = NaN;
    if (c && (i === Number.POSITIVE_INFINITY || i === Number.NEGATIVE_INFINITY)) {
      const D = m.slice();
      for (let N = 0; N < u; N++)
        D[N] = D[N] === y && C(N) ? 1 : 0;
      if (D[b] !== 1) {
        V.error("Seed voxel could not be marked for cluster ID.");
        return;
      }
      this.drawFloodFillCore(D, b, a);
      const M = this.volumes[0].img2RAS();
      let B = 0, T = 0;
      for (let N = 0; N < u; N++)
        D[N] === 2 && (B += M[N], T++);
      E = T > 0 ? B / T : M[b], V.debug(`Grow Cluster using mean intensity: ${E.toFixed(2)} from ${T} voxels.`);
      let U = -1 / 0, R = 1 / 0;
      i === Number.POSITIVE_INFINITY && (U = E), i === Number.NEGATIVE_INFINITY && (R = E);
      for (let N = 0; N < u; N++)
        if (D[N] === 2)
          g[N] = 1;
        else if (m[N] === 0) {
          const k = M[N];
          k >= U && k <= R && C(N) && (g[N] = 1);
        }
      t = y;
    } else if (i === 0)
      if (c && t === 0) {
        V.debug(`Erase Cluster: Identifying cluster with color ${y}`);
        for (let D = 0; D < u; D++)
          g[D] = m[D] === y && C(D) ? 1 : 0;
      } else
        for (let D = 0; D < u; D++)
          m[D] === y && C(D) && y !== 0 && (g[D] = 1);
    else {
      const D = this.volumes[0].img2RAS();
      E = D[b];
      let M = -1 / 0, B = 1 / 0;
      isFinite(s) && isFinite(r) ? (M = s, B = r) : i === Number.POSITIVE_INFINITY ? M = E : i === Number.NEGATIVE_INFINITY && (B = E);
      for (let T = 0; T < u; T++) {
        const U = D[T];
        U >= M && U <= B && C(T) && (g[T] = 1);
      }
      t = m[b], t === 0 && (t = this.opts.penValue, (t < 1 || !isFinite(t)) && (t = 1));
    }
    if (g[b] !== 1) {
      let D = !1;
      if (c && i !== 0 ? y !== 0 && (D = !0) : (y !== 0 || t === 0) && (D = !0), D && C(b))
        g[b] = 1, V.debug("Forcing seed voxel to 1 in working buffer.");
      else {
        V.debug("Seed voxel not marked as candidate '1' and not valid originally."), this.clickToSegmentIsGrowing && this.clickToSegmentGrowingBitmap && this.drawBitmap && this.clickToSegmentGrowingBitmap.set(this.drawBitmap);
        return;
      }
    }
    this.drawFloodFillCore(g, b, a);
    for (let D = 0; D < u; D++)
      g[D] === 2 ? l[D] = t : this.clickToSegmentIsGrowing && l === this.clickToSegmentGrowingBitmap && (l[D] = m[D]);
    this.clickToSegmentIsGrowing ? this.refreshDrawing(!0, !0) : (this.drawAddUndoBitmap(), this.refreshDrawing(!0, !1));
  }
  /**
   * Fills exterior regions of a 2D bitmap, marking outside voxels with 2
   * while leaving interior voxels at 0 and borders at 1. Operates within specified bounds.
   * uses first-in, first out queue for storage
   * @internal
   */
  floodFillSectionFIFO(e, t, i, s) {
    const r = t[0], [a, n] = i, [o, l] = s, c = 4 * (o - a + l - n + 2), h = new Int32Array(c * 2);
    let f = 0, d = 0;
    function u(p, A) {
      if (p < a || p > o || A < n || A > l)
        return;
      const x = p + A * r;
      e[x] === 0 && (e[x] = 2, h[d] = p, h[d + 1] = A, d = (d + 2) % h.length);
    }
    function m() {
      if (f === d)
        return null;
      const p = h[f], A = h[f + 1];
      return f = (f + 2) % h.length, [p, A];
    }
    for (let p = a; p <= o; p++)
      u(p, n), u(p, l);
    for (let p = n + 1; p <= l - 1; p++)
      u(a, p), u(o, p);
    let g;
    for (; (g = m()) !== null; ) {
      const [p, A] = g;
      u(p - 1, A), u(p + 1, A), u(p, A - 1), u(p, A + 1);
    }
  }
  /**
   * Connects and fills the interior of drawn line segments in 2D slice space.
   * @internal
   */
  drawPenFilled() {
    var p;
    const e = this.drawPenFillPts.length;
    if (e < 2) {
      this.drawPenFillPts = [];
      return;
    }
    const t = this.drawPenAxCorSag;
    let i = 0, s = 1;
    if (t === 1 && (s = 2), t === 2 && (i = 1, s = 2), !((p = this.back) != null && p.dims))
      throw new Error("back.dims undefined");
    const r = [this.back.dims[i + 1], this.back.dims[s + 1]], a = new Uint8Array(r[0] * r[1]);
    let n = 1;
    function o(A, x) {
      const w = Math.abs(A[0] - x[0]), v = Math.abs(A[1] - x[1]);
      a[A[0] + A[1] * r[0]] = n, a[x[0] + x[1] * r[0]] = n;
      let F = -1, C = -1;
      x[0] > A[0] && (F = 1), x[1] > A[1] && (C = 1);
      let b = A[0], y = A[1];
      const E = x[0], S = x[1];
      if (w >= v) {
        let D = 2 * v - w;
        for (; b !== E; )
          b += F, D >= 0 && (y += C, D -= 2 * w), D += 2 * v, a[b + y * r[0]] = n;
      } else {
        let D = 2 * w - v;
        for (; y !== S; )
          y += C, D >= 0 && (b += F, D -= 2 * v), D += 2 * w, a[b + y * r[0]] = n;
      }
    }
    function l(A) {
      const x = Math.min(Math.max(A[0], 0), r[0] - 1), w = Math.min(Math.max(A[1], 0), r[1] - 1);
      return [x, w];
    }
    const c = l([this.drawPenFillPts[0][i], this.drawPenFillPts[0][s]]);
    let h = [...c], f = [...c], d = c;
    for (let A = 1; A < e; A++) {
      let x = [this.drawPenFillPts[A][i], this.drawPenFillPts[A][s]];
      x = l(x), h = [Math.min(x[0], h[0]), Math.min(x[1], h[1])], f = [Math.max(x[0], f[0]), Math.max(x[1], f[1])], o(d, x), d = x;
    }
    o(c, d);
    const u = 1;
    h[0] = Math.max(0, h[0] - u), h[1] = Math.max(0, h[1] - u), f[0] = Math.min(r[0] - 1, f[0] + u), f[1] = Math.min(r[1] - 1, f[1] + u);
    for (let A = 0; A < r[1]; A++)
      for (let x = 0; x < r[0]; x++) {
        if (x >= h[0] && x < f[0] && A >= h[1] && A <= f[1])
          continue;
        const w = x + A * r[0];
        a[w] === 0 && (a[w] = 2);
      }
    const m = Date.now();
    this.floodFillSectionFIFO(a, r, h, f), V.debug(`FloodFill ${Date.now() - m}`), n = this.opts.penValue;
    const g = this.drawPenFillPts[0][3 - (i + s)];
    if (!this.drawBitmap)
      throw new Error("drawBitmap undefined");
    if (t === 0) {
      const A = g * r[0] * r[1];
      for (let x = 0; x < r[0] * r[1]; x++)
        a[x] !== 2 && (this.drawBitmap[x + A] = n);
    } else {
      let A = 1;
      const x = this.back.dims[1] * this.back.dims[2];
      let w = g * this.back.dims[1];
      t === 2 && (A = this.back.dims[1], w = g);
      let v = 0;
      for (let F = 0; F < r[1]; F++)
        for (let C = 0; C < r[0]; C++)
          a[v] !== 2 && (this.drawBitmap[C * A + F * x + w] = n), v++;
    }
    if (!this.drawFillOverwrites && this.drawUndoBitmaps[this.currentDrawUndoBitmap].length > 0) {
      const A = this.drawBitmap.length, x = cs(this.drawUndoBitmaps[this.currentDrawUndoBitmap], A);
      for (let w = 0; w < A; w++)
        x[w] !== 0 && (this.drawBitmap[w] = x[w]);
    }
    this.drawPenFillPts = [], this.drawAddUndoBitmap(), this.refreshDrawing(!1);
  }
  /**
   * close drawing: make sure you have saved any changes before calling this!
   * @example niivue.closeDrawing();
   * @see {@link https://niivue.com/demos/features/draw.ui.html | live demo usage}
   */
  closeDrawing() {
    this.drawClearAllUndoBitmaps(), this.drawTexture = this.rgbaTex(this.drawTexture, qt, [2, 2, 2, 2], !0), this.drawBitmap = null, this.clickToSegmentGrowingBitmap = null, this.drawScene();
  }
  /**
   * copy drawing bitmap from CPU to GPU storage and redraw the screen
   * @param isForceRedraw - refreshes scene immediately (default true)
   * @example niivue.refreshDrawing();
   * @see {@link https://niivue.com/demos/features/cactus.html | live demo usage}
   */
  refreshDrawing(e = !0, t = !1) {
    var n;
    t && (!this.opts.drawingEnabled || !this.opts.clickToSegment) && (V.debug("refreshDrawing: Conditions not met for clickToSegment bitmap, using drawBitmap."), t = !1);
    const i = t ? this.clickToSegmentGrowingBitmap : this.drawBitmap;
    !i && !t && this.clickToSegmentGrowingBitmap ? V.warn("refreshDrawing: drawBitmap is null, but clickToSegmentGrowingBitmap exists. Check state.") : !i && t && this.drawBitmap ? (V.warn("refreshDrawing: clickToSegmentGrowingBitmap is null, falling back to drawBitmap."), t = !1) : i || V.warn("refreshDrawing: Both bitmaps are null. Uploading empty data.");
    const s = t ? this.clickToSegmentGrowingBitmap : this.drawBitmap;
    if (!((n = this.back) != null && n.dims)) {
      V.warn("refreshDrawing: back.dims undefined, cannot refresh drawing texture yet.");
      return;
    }
    const r = this.back.dims.slice(), a = this.back.dims[1] * this.back.dims[2] * this.back.dims[3];
    if (!s) {
      V.warn(
        `refreshDrawing: Bitmap data source (${t ? "growing" : "main"}) is null. Cannot update texture.`
      ), e && this.drawScene();
      return;
    }
    if (s.length === 8 ? (r[1] = 2, r[2] = 2, r[3] = 2) : a !== s.length && V.warn(`Drawing bitmap length (${s.length}) must match the background image (${a})`), this.gl.activeTexture(qt), this.opts.is2DSliceShader) {
      const o = this.frac2vox(this.scene.crosshairPos), l = Math.min(Math.max(o[2], 0), r[3] - 1), c = r[1] * r[2], h = l * c;
      V.debug(`refresh huge 2D drawing xyz ${r[1]}${r[2]}${r[3]} slice ${h}`);
      const f = s.subarray(h, h + c);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.drawTexture), this.gl.texSubImage2D(
        this.gl.TEXTURE_2D,
        0,
        // Level
        0,
        0,
        // xOffset, yOffset
        r[1],
        r[2],
        // Width, Height
        this.gl.RED,
        this.gl.UNSIGNED_BYTE,
        f
      );
    } else
      this.gl.bindTexture(this.gl.TEXTURE_3D, this.drawTexture), this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        r[1],
        r[2],
        r[3],
        this.gl.RED,
        this.gl.UNSIGNED_BYTE,
        s
      );
    if (!this.drawTexture) {
      V.error("refreshDrawing: drawTexture (GPU texture) is null.");
      return;
    }
    e && this.drawScene();
  }
  /**
   * close probabilistic atlas texture
   * @example niivue.closePAQD();
   * @internal
   */
  closePAQD() {
    !this._gl || !this.paqdTexture || (this.paqdTexture = this.rgbaTex(this.paqdTexture, ue, [2, 2, 2, 2], !0));
  }
  /**
   * Creates a 2D 1-component uint8 texture on the GPU with given dimensions.
   * @internal
   */
  r8Tex2D(e, t, i, s = !1) {
    if (e && this.gl.deleteTexture(e), e = this.gl.createTexture(), this.gl.activeTexture(t), this.gl.bindTexture(this.gl.TEXTURE_2D, e), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.R8, i[1], i[2]), s) {
      const r = new Uint8Array(i[1] * i[2]);
      this.gl.texSubImage2D(
        this.gl.TEXTURE_2D,
        0,
        // Level
        0,
        0,
        // xOffset, yOffset
        i[1],
        i[2],
        // Width, Height
        this.gl.RED,
        this.gl.UNSIGNED_BYTE,
        r
      );
    }
    return e;
  }
  /**
   * Creates a 3D 1-component uint8 texture on the GPU with given dimensions.
   * @internal
   */
  r8Tex(e, t, i, s = !1) {
    if (e && this.gl.deleteTexture(e), e = this.gl.createTexture(), this.gl.activeTexture(t), this.gl.bindTexture(this.gl.TEXTURE_3D, e), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R8, i[1], i[2], i[3]), s) {
      const r = new Uint8Array(i[1] * i[2] * i[3]);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i[1],
        i[2],
        i[3],
        this.gl.RED,
        this.gl.UNSIGNED_BYTE,
        r
      );
    }
    return e;
  }
  /**
   * Creates a 2D 4-component (RGBA) uint8 texture on the GPU with optional vertical flip.
   * @internal
   */
  rgbaTex2D(e, t, i, s = null, r = !0) {
    if (e && this.gl.deleteTexture(e), e = this.gl.createTexture(), this.gl.activeTexture(t), this.gl.bindTexture(this.gl.TEXTURE_2D, e), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, i[1], i[2]), s) {
      let a = s;
      const n = i[1], o = i[2];
      if (r) {
        a = new Uint8Array(s.length);
        const l = n * 4;
        for (let c = 0; c < o; c++) {
          const h = c * l, f = (o - 1 - c) * l;
          a.set(s.subarray(h, h + l), f);
        }
      }
      this.gl.texSubImage2D(
        this.gl.TEXTURE_2D,
        0,
        // Level
        0,
        0,
        // xOffset, yOffset
        n,
        o,
        // Width, Height
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        a
      );
    }
    return e;
  }
  /**
   * Creates a 3D 4-component (RGBA) uint8 texture on the GPU, optionally initializing with empty data.
   * @internal
   */
  rgbaTex(e, t, i, s = !1) {
    if (e && this.gl.deleteTexture(e), e = this.gl.createTexture(), this.gl.activeTexture(t), this.gl.bindTexture(this.gl.TEXTURE_3D, e), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA8, i[1], i[2], i[3]), s) {
      const r = new Uint8Array(i[1] * i[2] * i[3] * 4);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i[1],
        i[2],
        i[3],
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        r
      );
    }
    return e;
  }
  /**
   * Create or recreate a 3D RGBA16UI texture on the GPU with given dimensions.
   * Deletes existing texture if provided, then allocates storage and optionally initializes with zeros.
   * @internal
   */
  rgba16Tex(e, t, i, s = !1) {
    if (e && this.gl.deleteTexture(e), e = this.gl.createTexture(), this.gl.activeTexture(t), this.gl.bindTexture(this.gl.TEXTURE_3D, e), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 2), this.gl.pixelStorei(this.gl.PACK_ALIGNMENT, 2), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA16UI, i[1], i[2], i[3]), s) {
      const r = new Uint16Array(i[1] * i[2] * i[3] * 4);
      this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i[1],
        i[2],
        i[3],
        this.gl.RGBA_INTEGER,
        this.gl.UNSIGNED_SHORT,
        r
      );
    }
    return e;
  }
  /**
   * Remove cross-origin attribute from image if its URL is not from the same origin as the current page.
   * @internal
   */
  requestCORSIfNotSameOrigin(e, t) {
    new URL(t, window.location.href).origin !== window.location.origin && (e.crossOrigin = "");
  }
  /**
   * Loads a PNG image from a URL and creates a 4-component (RGBA) uint8 WebGL texture.
   * Binds texture to a specific texture unit depending on textureNum and sets texture parameters.
   * Automatically handles CORS and draws scene if needed.
   * @internal
   */
  async loadPngAsTexture(e, t) {
    return new Promise((i, s) => {
      const r = new Image();
      r.onload = () => {
        if (!this.bmpShader)
          return;
        let a;
        t === 4 ? (this.bmpTexture !== null && this.gl.deleteTexture(this.bmpTexture), this.bmpTexture = this.gl.createTexture(), a = this.bmpTexture, this.bmpTextureWH = r.width / r.height, this.gl.activeTexture(Ah), this.bmpShader.use(this.gl), this.gl.uniform1i(this.bmpShader.uniforms.bmpTexture, 4)) : t === 5 ? (this.gl.activeTexture(ji), this.matCapTexture !== null && this.gl.deleteTexture(this.matCapTexture), this.matCapTexture = this.gl.createTexture(), a = this.matCapTexture) : (this.fontShader.use(this.gl), this.gl.activeTexture(vr), this.gl.uniform1i(this.fontShader.uniforms.fontTexture, 3), this.fontTexture !== null && this.gl.deleteTexture(this.fontTexture), this.fontTexture = this.gl.createTexture(), a = this.fontTexture), this.gl.bindTexture(this.gl.TEXTURE_2D, a), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, r), i(a), t !== 4 && this.drawScene();
      }, r.onerror = s, this.requestCORSIfNotSameOrigin(r, e), r.src = e;
    });
  }
  /**
   * Loads a font stored as a PNG bitmap into texture unit 3.
   * @internal
   */
  async loadFontTexture(e) {
    return this.loadPngAsTexture(e, 3);
  }
  /**
   * Loads a PNG bitmap into texture unit 4.
   * @internal
   */
  async loadBmpTexture(e) {
    return this.loadPngAsTexture(e, 4);
  }
  /**
   * Load matcap for illumination model.
   * @param bmpUrl - name of matcap to load ("Shiny", "Cortex", "Cream")
   * @example
   * niivue.loadMatCapTexture("Cortex");
   * @see {@link https://niivue.com/demos/features/shiny.volumes.html | live demo usage}
   */
  async loadMatCapTexture(e) {
    return this.loadPngAsTexture(e, 5);
  }
  /**
   * Initializes font metrics from loaded font data.
   * @internal
   */
  initFontMets() {
    if (!this.fontMetrics)
      throw new Error("fontMetrics undefined");
    this.fontMets = {
      distanceRange: this.fontMetrics.atlas.distanceRange,
      size: this.fontMetrics.atlas.size,
      mets: {}
    };
    for (let i = 0; i < 256; i++)
      this.fontMets.mets[i] = {
        xadv: 0,
        uv_lbwh: [0, 0, 0, 0],
        lbwh: [0, 0, 0, 0]
      };
    const e = this.fontMetrics.atlas.width, t = this.fontMetrics.atlas.height;
    for (let i = 0; i < this.fontMetrics.glyphs.length; i++) {
      const s = this.fontMetrics.glyphs[i], r = s.unicode;
      if (this.fontMets.mets[r].xadv = s.advance, s.planeBounds === void 0)
        continue;
      let a = s.atlasBounds.left / e, n = (t - s.atlasBounds.top) / t, o = (s.atlasBounds.right - s.atlasBounds.left) / e, l = (s.atlasBounds.top - s.atlasBounds.bottom) / t;
      this.fontMets.mets[r].uv_lbwh = [a, n, o, l], a = s.planeBounds.left, n = s.planeBounds.bottom, o = s.planeBounds.right - s.planeBounds.left, l = s.planeBounds.top - s.planeBounds.bottom, this.fontMets.mets[r].lbwh = [a, n, o, l];
    }
  }
  /**
   * Load typeface for colorbars, measurements and orientation text.
   * @param fontSheetUrl - URL to a bitmap font sheet image (e.g., a PNG atlas of glyphs)
   * @param metricsUrl - URL to the corresponding font metrics JSON (defines character bounds and spacing)
   * @returns a Promise that resolves when the font is loaded
   * @example
   * niivue.loadFont("./Roboto.png","./Roboto.json")
   * @see {@link https://niivue.com/demos/features/selectfont.html | live demo usage}
   */
  async loadFont(e = lr, t = cr) {
    await this.loadFontTexture(e);
    const i = await fetch(t);
    if (!i.ok)
      throw Error(i.statusText);
    const s = await i.text();
    this.fontMetrics = JSON.parse(s), this.initFontMets(), this.fontShader.use(this.gl), this.drawScene();
  }
  /**
   * Loads the default MatCap texture.
   * @internal
   */
  async loadDefaultMatCap() {
    return this.loadMatCapTexture(sc);
  }
  /**
   * Loads the default font texture and initializes font metrics.
   * @internal
   */
  async loadDefaultFont() {
    await this.loadFontTexture(this.DEFAULT_FONT_GLYPH_SHEET), this.fontMetrics = this.DEFAULT_FONT_METRICS, this.initFontMets();
  }
  /**
   * Initializes text rendering by setting up font shader, loading default font and matcap texture,
   * and drawing the loading text.
   * @internal
   */
  async initText() {
    this.fontShader = new et(this.gl, Dc, Sc), this.fontShader.use(this.gl), await this.loadDefaultFont(), await this.loadDefaultMatCap(), this.drawLoadingText(this.opts.loadingText);
  }
  /**
   * Maps a mesh shader name to its corresponding index number.
   * @internal
   */
  meshShaderNameToNumber(e = "Phong") {
    const t = e.toLowerCase();
    for (let i = 0; i < this.meshShaders.length; i++)
      if (this.meshShaders[i].Name.toLowerCase() === t)
        return i;
  }
  /**
   * select new shader for triangulated meshes and connectomes. Note that this function requires the mesh is fully loaded: you may want use `await` with loadMeshes (as seen in live demo).
   * @param id - id of mesh to change
   * @param meshShaderNameOrNumber - identify shader for usage
   * @example niivue.setMeshShader('toon');
   * @see {@link https://niivue.com/demos/features/meshes.html | live demo usage}
   */
  setMeshShader(e, t = 2) {
    let i = 0;
    if (typeof t == "number" ? i = t : i = this.meshShaderNameToNumber(t), i === void 0)
      throw new Error("shaderIndex undefined");
    i = Math.min(i, this.meshShaders.length - 1), i = Math.max(i, 0);
    const s = this.getMeshIndexByID(e);
    if (s >= this.meshes.length) {
      V.debug("Unable to change shader until mesh is loaded (maybe you need async)");
      return;
    }
    this.meshes[s].meshShaderIndex = i, this.updateGLVolume(), this.onMeshShaderChanged(s, i);
  }
  /**
   *
   * @param fragmentShaderText - custom fragment shader.
   * @param name - title for new shader.
   * @returns created custom mesh shader
   */
  createCustomMeshShader(e, t = "Custom") {
    if (!e)
      throw new Error("Need fragment shader");
    const i = this.meshShaderNameToNumber(t);
    i >= 0 && (this.gl.deleteProgram(this.meshShaders[i].shader.program), this.meshShaders.splice(i, 1));
    const s = new et(this.gl, Xi, e);
    return s.use(this.gl), {
      Name: t,
      Frag: e,
      shader: s
    };
  }
  /**
   * Install a special shader for 2D slice views
   * @param fragmentShaderText - custom fragment shader.
   * @if not text is provided, the default shader will be used
   * @internal
   */
  setCustomSliceShader(e = "") {
    const t = this.gl;
    if (this.customSliceShader && (t.deleteProgram(this.customSliceShader.program), this.customSliceShader = null), !e) {
      this.updateGLVolume();
      return;
    }
    const i = new et(t, li, e);
    i.use(t), t.uniform1i(i.uniforms.volume, 0), t.uniform1i(i.uniforms.colormap, 1), t.uniform1i(i.uniforms.overlay, 2), t.uniform1i(i.uniforms.drawing, 7), t.uniform1i(i.uniforms.paqd, 8), t.uniform1f(i.uniforms.drawOpacity, this.drawOpacity), this.customSliceShader = i, this.updateGLVolume();
  }
  /**
   * Define a new GLSL shader program to influence mesh coloration
   * @param fragmentShaderText - the GLSL source code for the custom fragment shader
   * @param name - a descriptive label for the shader (used in menus or debugging)
   * @returns the index of the new shader (use with {@link setMeshShader})
   * @see {@link https://niivue.com/demos/features/mesh.atlas.html | live demo usage}
   */
  setCustomMeshShader(e = "", t = "Custom") {
    const i = this.createCustomMeshShader(e, t);
    return this.meshShaders.push(i), this.onCustomMeshShaderAdded(e, t), this.meshShaders.length - 1;
  }
  /**
   * retrieve all currently loaded meshes
   * @param sort - sort output alphabetically
   * @returns list of available mesh shader names
   * @example niivue.meshShaderNames();
   * @see {@link https://niivue.com/demos/features/meshes.html | live demo usage}
   */
  meshShaderNames(e = !0) {
    const t = [];
    for (let i = 0; i < this.meshShaders.length; i++)
      t.push(this.meshShaders[i].Name);
    return e === !0 ? t.sort() : t;
  }
  /**
   * Initializes a rendering shader with texture units and uniforms.
   * @internal
   */
  initRenderShader(e, t = 0) {
    e.use(this.gl), this.gl.uniform1i(e.uniforms.volume, 0), this.gl.uniform1i(e.uniforms.colormap, 1), this.gl.uniform1i(e.uniforms.overlay, 2), this.gl.uniform1i(e.uniforms.drawing, 7), this.gl.uniform1i(e.uniforms.paqd, 8), this.gl.uniform1fv(e.uniforms.renderDrawAmbientOcclusion, [this.renderDrawAmbientOcclusion, 1]), this.gl.uniform1f(e.uniforms.gradientAmount, t), this.gl.uniform1f(e.uniforms.silhouettePower, this.opts.renderSilhouette);
    const i = new Float32Array(Ne);
    for (let s = 0; s < Ne; s++)
      this.opts.gradientOpacity === 0 ? i[s] = 1 : i[s] = Math.pow(s / (Ne - 1), this.opts.gradientOpacity * 8);
    this.gl.uniform1fv(this.gl.getUniformLocation(e.program, "gradientOpacity"), i), e.uniforms.clipPlanes = this.gl.getUniformLocation(e.program, "clipPlanes[0]");
  }
  /**
   * Initializes WebGL state, shaders, textures, buffers, and sets up the rendering pipeline.
   * Also loads default fonts, matcap textures, and thumbnail if specified.
   * @internal
   * @returns {Promise<this>} Resolves to this instance after initialization completes.
   */
  async init() {
    const e = this.gl.getExtension("WEBGL_debug_renderer_info");
    if (e) {
      const a = this.gl.getParameter(e.UNMASKED_VENDOR_WEBGL), n = this.gl.getParameter(e.UNMASKED_RENDERER_WEBGL);
      V.info("renderer vendor: ", a), V.info("renderer: ", n);
    } else
      V.info("debug_renderer_info unavailable");
    const t = this.gl.getParameter(this.gl.RENDERER);
    V.info("firefox renderer: ", t), this.gl.enable(this.gl.CULL_FACE), this.gl.cullFace(this.gl.FRONT), this.gl.enable(this.gl.BLEND), this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA), this.volumeTexture = this.rgbaTex(this.volumeTexture, ie, [2, 2, 2, 2], !0), this.overlayTexture = this.rgbaTex(this.overlayTexture, fi, [2, 2, 2, 2], !0), this.drawTexture = this.r8Tex(this.drawTexture, qt, [2, 2, 2, 2], !0), this.paqdTexture = this.rgbaTex(this.paqdTexture, ue, [2, 2, 2, 2], !0);
    const i = [
      1,
      1,
      0,
      // RAI
      1,
      0,
      0,
      // RPI
      0,
      1,
      0,
      // LAI
      0,
      0,
      0
      // LPI
    ], s = this.gl;
    this.cuboidVertexBuffer = s.createBuffer(), s.bindBuffer(s.ARRAY_BUFFER, this.cuboidVertexBuffer), s.bufferData(s.ARRAY_BUFFER, new Float32Array(i), s.STATIC_DRAW), this.genericVAO = s.createVertexArray(), s.bindVertexArray(this.genericVAO), s.bindBuffer(s.ARRAY_BUFFER, this.cuboidVertexBuffer), s.enableVertexAttribArray(0), s.vertexAttribPointer(0, 3, s.FLOAT, !1, 0, 0), s.bindVertexArray(this.unusedVAO), this.pickingMeshShader = new et(s, Xi, zc), this.pickingMeshShader.use(s), this.pickingImageShader = new et(s, Me, ih), this.pickingImageShader.use(s), this.pickingImageShader.uniforms.clipPlanes = this.gl.getUniformLocation(
      this.pickingImageShader.program,
      "clipPlanes[0]"
    ), s.uniform1i(this.pickingImageShader.uniforms.volume, 0), s.uniform1i(this.pickingImageShader.uniforms.colormap, 1), s.uniform1i(this.pickingImageShader.uniforms.overlay, 2), s.uniform1i(this.pickingImageShader.uniforms.drawing, 7), this.slice2DShader = new et(s, li, Ac), this.slice2DShader.use(s), s.uniform1i(this.slice2DShader.uniforms.volume, 0), s.uniform1i(this.slice2DShader.uniforms.colormap, 1), s.uniform1i(this.slice2DShader.uniforms.overlay, 2), s.uniform1i(this.slice2DShader.uniforms.drawing, 7), s.uniform1f(this.slice2DShader.uniforms.drawOpacity, this.drawOpacity), this.sliceMMShader = new et(s, li, xc), this.sliceMMShader.use(s), s.uniform1i(this.sliceMMShader.uniforms.volume, 0), s.uniform1i(this.sliceMMShader.uniforms.colormap, 1), s.uniform1i(this.sliceMMShader.uniforms.overlay, 2), s.uniform1i(this.sliceMMShader.uniforms.drawing, 7), s.uniform1f(this.sliceMMShader.uniforms.drawOpacity, this.drawOpacity), this.sliceV1Shader = new et(s, li, vc), this.sliceV1Shader.use(s), s.uniform1i(this.sliceV1Shader.uniforms.volume, 0), s.uniform1i(this.sliceV1Shader.uniforms.colormap, 1), s.uniform1i(this.sliceV1Shader.uniforms.overlay, 2), s.uniform1i(this.sliceV1Shader.uniforms.drawing, 7), s.uniform1f(this.sliceV1Shader.uniforms.drawOpacity, this.drawOpacity), this.orientCubeShader = new et(s, sh, rh), this.orientCubeShaderVAO = s.createVertexArray(), s.bindVertexArray(this.orientCubeShaderVAO);
    const r = s.createBuffer();
    s.enableVertexAttribArray(0), s.enableVertexAttribArray(1), s.bindBuffer(s.ARRAY_BUFFER, r), s.bufferData(s.ARRAY_BUFFER, Mo, s.STATIC_DRAW), s.vertexAttribPointer(0, 3, s.FLOAT, !1, 24, 0), s.enableVertexAttribArray(1), s.vertexAttribPointer(1, 3, s.FLOAT, !1, 24, 12), s.bindVertexArray(this.unusedVAO), this.rectShader = new et(s, fr, Wi), this.rectShader.use(s), this.rectOutlineShader = new et(s, fr, wc), this.rectOutlineShader.use(s), this.lineShader = new et(s, Cc, Wi), this.lineShader.use(s), this.line3DShader = new et(s, Fc, Wi), this.line3DShader.use(s), this.circleShader = new et(s, Ic, Tc), this.circleShader.use(s), this.renderVolumeShader = new et(s, Me, mc), this.initRenderShader(this.renderVolumeShader), this.renderSliceShader = new et(s, Me, uc), this.initRenderShader(this.renderSliceShader), this.renderGradientShader = new et(s, Me, gc), this.initRenderShader(this.renderGradientShader, 0.3), s.uniform1i(this.renderGradientShader.uniforms.matCap, 5), s.uniform1i(this.renderGradientShader.uniforms.gradient, 6), this.renderGradientValuesShader = new et(s, Me, pc), this.initRenderShader(this.renderGradientValuesShader), s.uniform1i(this.renderGradientValuesShader.uniforms.matCap, 5), s.uniform1i(this.renderGradientValuesShader.uniforms.gradient, 6), this.renderShader = this.renderVolumeShader, this.colorbarShader = new et(s, bc, yc), this.colorbarShader.use(s), s.uniform1i(this.colorbarShader.uniforms.colormap, 1), this.blurShader = new et(s, hi, oh), this.sobelBlurShader = new et(s, hi, lh), this.sobelFirstOrderShader = new et(s, hi, ch), this.sobelSecondOrderShader = new et(s, hi, hh), this.growCutShader = new et(s, Rc, Pc), this.passThroughShader = new et(s, nh, ah), this.orientShaderAtlasU = new et(s, te, ci.concat(ur)), this.orientShaderAtlasI = new et(s, te, dr.concat(ur)), this.orientShaderU = new et(s, te, ci.concat(Ki)), this.orientShaderI = new et(s, te, dr.concat(Ki)), this.orientShaderF = new et(s, te, Vc.concat(Ki)), this.orientShaderRGBU = new et(s, te, ci.concat(Uc)), this.orientShaderPAQD = new et(s, te, ci.concat(Bc)), this.surfaceShader = new et(s, Nc, Lc), this.surfaceShader.use(s), this.fiberShader = new et(s, kc, Oc), this.pickingImageShader.use(s);
    for (let a = 0; a < this.meshShaders.length; a++) {
      const n = this.meshShaders[a];
      n.Name === "Flat" ? n.shader = new et(s, eh, mr) : n.shader = new et(s, Xi, n.Frag), n.shader.use(s), n.shader.isCrosscut = n.Name === "Crosscut", n.shader.isMatcap = n.Name === "Matcap", n.shader.isMatcap && s.uniform1i(n.shader.uniforms.matCap, 5);
    }
    return this.bmpShader = new et(s, Mc, Ec), await this.initText(), this.opts.thumbnail.length > 0 && (await this.loadBmpTexture(this.opts.thumbnail), this.thumbnailVisible = !0), this.updateGLVolume(), this.initialized = !0, this.resizeListener(), this.drawScene(), this;
  }
  /**
   * Generates gradient texture from volume data using GPU shaders and framebuffers.
   * @internal
   */
  gradientGL(e) {
    const t = this.gl;
    t.bindVertexArray(this.genericVAO);
    const i = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, i), t.viewport(0, 0, e.dims[1], e.dims[2]), t.disable(t.BLEND);
    const s = this.rgbaTex(null, wr, e.dims, !0), r = this.opts.gradientOrder === 2 ? this.sobelBlurShader : this.blurShader;
    r.use(t), t.activeTexture(ie), t.bindTexture(t.TEXTURE_3D, this.volumeTexture), t.texParameteri(t.TEXTURE_3D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_3D, t.TEXTURE_MAG_FILTER, t.LINEAR);
    const a = 0.7;
    t.uniform1i(r.uniforms.intensityVol, 0), t.uniform1f(r.uniforms.dX, a / e.dims[1]), t.uniform1f(r.uniforms.dY, a / e.dims[2]), t.uniform1f(r.uniforms.dZ, a / e.dims[3]);
    for (let l = 0; l < e.dims[3] - 1; l++) {
      const c = 1 / e.dims[3] * (l + 0.5);
      t.uniform1f(r.uniforms.coordZ, c), t.framebufferTextureLayer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, s, 0, l);
      const h = t.checkFramebufferStatus(t.FRAMEBUFFER);
      h !== t.FRAMEBUFFER_COMPLETE && V.error("blur shader: ", h), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
    }
    const n = this.opts.gradientOrder === 2 ? this.sobelSecondOrderShader : this.sobelFirstOrderShader;
    n.use(t), t.activeTexture(wr), t.bindTexture(t.TEXTURE_3D, s), t.texParameteri(t.TEXTURE_3D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_3D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.uniform1i(n.uniforms.intensityVol, 8);
    const o = 0.7;
    t.uniform1f(n.uniforms.dX, o / e.dims[1]), t.uniform1f(n.uniforms.dY, o / e.dims[2]), t.uniform1f(n.uniforms.dZ, o / e.dims[3]), this.opts.gradientOrder === 2 && (t.uniform1f(n.uniforms.dX2, 2 * o / e.dims[1]), t.uniform1f(n.uniforms.dY2, 2 * o / e.dims[2]), t.uniform1f(n.uniforms.dZ2, 2 * o / e.dims[3])), t.uniform1f(n.uniforms.coordZ, 0.5), this.gradientTexture !== null && t.deleteTexture(this.gradientTexture), this.gradientTexture = this.rgbaTex(this.gradientTexture, di, e.dims);
    for (let l = 0; l < e.dims[3] - 1; l++) {
      const c = 1 / e.dims[3] * (l + 0.5);
      t.uniform1f(n.uniforms.coordZ, c), t.framebufferTextureLayer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, this.gradientTexture, 0, l);
      const h = t.checkFramebufferStatus(t.FRAMEBUFFER);
      h !== t.FRAMEBUFFER_COMPLETE && V.error("sobel shader: ", h), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
    }
    t.deleteFramebuffer(i), t.deleteTexture(s), t.bindFramebuffer(t.FRAMEBUFFER, null), t.activeTexture(ue), t.bindTexture(t.TEXTURE_3D, this.paqdTexture), this.gl.bindVertexArray(this.unusedVAO);
  }
  /**
   * Get the gradient texture produced by gradientGL as a TypedArray
   * @returns Float32Array containing the gradient texture data, or null if no gradient texture exists
   * @example
   * niivue = new Niivue()
   * niivue.loadVolumes([{url: './someImage.nii'}])
   * // ... after volume is loaded and gradient is computed
   * const gradientData = niivue.getGradientTextureData()
   * if (gradientData) {
   *   console.log('Gradient texture dimensions:', gradientData.length)
   * }
   * @see {@link https://niivue.com/demos/features/gradient.custom.html | live demo usage}
   */
  getGradientTextureData() {
    if (!this.gradientTexture || !this.back)
      return null;
    const e = this.gl, t = this.back.dims, i = t[1], s = t[2], r = t[3], a = i * s * r, n = e.createFramebuffer();
    e.bindFramebuffer(e.FRAMEBUFFER, n);
    const o = new Float32Array(a * 4);
    try {
      for (let l = 0; l < r; l++) {
        e.framebufferTextureLayer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, this.gradientTexture, 0, l);
        const c = e.checkFramebufferStatus(e.FRAMEBUFFER);
        if (c !== e.FRAMEBUFFER_COMPLETE) {
          console.warn(
            "Framebuffer not complete for gradient texture reading, slice",
            l,
            "status:",
            c.toString(16)
          );
          continue;
        }
        try {
          const h = new Uint8Array(i * s * 4);
          e.readPixels(0, 0, i, s, e.RGBA, e.UNSIGNED_BYTE, h);
          const f = new Float32Array(i * s * 4);
          for (let u = 0; u < h.length; u++)
            f[u] = h[u] / 127.5 - 1;
          const d = l * i * s * 4;
          o.set(f, d);
        } catch (h) {
          console.warn("Failed to read pixels for slice", l, ":", h);
          const f = l * i * s * 4, d = new Float32Array(i * s * 4);
          o.set(d, f);
        }
      }
    } catch (l) {
      return console.error("Error reading gradient texture:", l), null;
    } finally {
      e.deleteFramebuffer(n), e.bindFramebuffer(e.FRAMEBUFFER, null);
    }
    return o;
  }
  /**
   * Set a custom gradient texture to use instead of the one produced by gradientGL
   * When a custom gradient texture is set, the useCustomGradientTexture flag is set to true
   * to prevent gradientGL from overwriting the custom texture during volume updates.
   * @param data - Float32Array or Uint8Array containing RGBA gradient data, or null to revert to auto-generated gradient
   * @param dims - Optional dimensions array [width, height, depth]. If not provided, uses current volume dimensions
   * @example
   * niivue = new Niivue()
   * niivue.loadVolumes([{url: './someImage.nii'}])
   * // Create custom gradient data
   * const customGradient = new Float32Array(256 * 256 * 256 * 4) // example dimensions
   * // ... fill customGradient with desired values
   * niivue.setCustomGradientTexture(customGradient, [256, 256, 256])
   *
   * // To revert to auto-generated gradient:
   * niivue.setCustomGradientTexture(null)
   * @see {@link https://niivue.com/demos/features/gradient.custom.html | live demo usage}
   */
  setCustomGradientTexture(e, t) {
    const i = this.gl;
    if (e === null) {
      this.useCustomGradientTexture = !1, this.back && this.gradientTextureAmount > 0 && this.gradientGL(this.back.hdr);
      return;
    }
    if (!t && !this.back) {
      console.warn("No dimensions provided and no background volume loaded");
      return;
    }
    const s = t || this.back.dims, r = s[1], a = s[2], n = s[3], o = r * a * n * 4;
    if (e.length !== o) {
      console.warn(`Custom gradient data size mismatch. Expected ${o}, got ${e.length}`);
      return;
    }
    this.useCustomGradientTexture = !0, this.gradientTexture !== null && i.deleteTexture(this.gradientTexture), this.gradientTexture = i.createTexture(), i.activeTexture(di), i.bindTexture(i.TEXTURE_3D, this.gradientTexture), i.texParameteri(i.TEXTURE_3D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_3D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_3D, i.TEXTURE_WRAP_R, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_3D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_3D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.pixelStorei(i.UNPACK_ALIGNMENT, 1);
    let l;
    if (e instanceof Float32Array) {
      l = new Uint8Array(e.length);
      for (let c = 0; c < e.length; c++) {
        const h = Math.max(-1, Math.min(1, e[c]));
        l[c] = Math.round((h + 1) * 127.5);
      }
    } else
      l = e;
    i.texStorage3D(i.TEXTURE_3D, 1, i.RGBA8, r, a, n), i.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, r, a, n, i.RGBA, i.UNSIGNED_BYTE, l), this.drawScene();
  }
  /**
   * update the webGL 2.0 scene after making changes to the array of volumes. It's always good to call this method after altering one or more volumes manually (outside of Niivue setter methods)
   * @example
   * niivue = new Niivue()
   * niivue.updateGLVolume()
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  updateGLVolume() {
    var i;
    let e = 0;
    const t = this.volumes.length;
    this.refreshColormaps(), this.closePAQD();
    for (let s = 0; s < t; s++)
      this.volumes[s].toRAS && (this.refreshLayers(this.volumes[s], e), e++);
    if (this.furthestVertexFromOrigin = 0, t > 0 && (this.furthestVertexFromOrigin = ((i = this.volumeObject3D) == null ? void 0 : i.furthestVertexFromOrigin) ?? 0), this.meshes)
      for (let s = 0; s < this.meshes.length; s++)
        this.furthestVertexFromOrigin = Math.max(this.furthestVertexFromOrigin, this.meshes[s].furthestVertexFromOrigin);
    this.onVolumeUpdated && this.onVolumeUpdated(), this.drawScene();
  }
  /**
   * basic statistics for selected voxel-based image
   * @param options - an object containing the following properties:
   *   - layer: selects image to describe
   *   - masks: optional binary images to filter voxels
   *   - drawingIsMask: a boolean indicating if the drawing is used as a mask
   *   - roiIsMask: a boolean indicating if the ROI is used as a mask
   *   - startVox: the starting voxel coordinates
   *   - endVox: the ending voxel coordinates
   * @returns numeric values to describe image or regions of images
   * @example
   * niivue.getDescriptives({
   *   layer: 0,
   *   masks: [],
   *   drawingIsMask: true, // drawingIsMask and roiIsMask are mutually exclusive
   *   roiIsMask: false,
   *   startVox: [10, 20, 30], // ignored if roiIsMask is false
   *   endVox: [40, 50, 60] // ignored if roiIsMask is false
   * });
   * @see {@link https://niivue.com/demos/features/draw2.html | live demo usage}
   */
  getDescriptives(e) {
    const {
      layer: t = 0,
      masks: i = [],
      drawingIsMask: s = !1,
      roiIsMask: r = !1,
      startVox: a = [0, 0, 0],
      endVox: n = [0, 0, 0]
    } = e;
    let o = null;
    const l = this.volumes[t].hdr, c = this.volumes[t].pixDimsRAS;
    let h = l.scl_slope;
    isNaN(h) && (h = 1);
    let f = l.scl_inter;
    isNaN(f) && (f = 1);
    const d = this.volumes[t].img, u = d.length, m = new Float32Array(u);
    for (let M = 0; M < u; M++)
      m[M] = d[M] * h + f;
    const g = new Uint8Array(u);
    for (let M = 0; M < u; M++)
      g[M] = 1;
    if (i.length > 0)
      for (let M = 0; M < i.length; M++) {
        const B = this.volumes[i[M]].img;
        if (B.length !== u) {
          V.debug("Mask resolution does not match image. Skipping masking layer " + i[M]);
          continue;
        }
        for (let T = 0; T < u; T++)
          (B[T] === 0 || isNaN(B[T])) && (g[T] = 0);
      }
    else if (i.length < 1 && s)
      for (let M = 0; M < u; M++)
        (this.drawBitmap[M] === 0 || isNaN(this.drawBitmap[M])) && (g[M] = 0);
    else if (i.length < 1 && r) {
      g.fill(0);
      let M = -1;
      if (a[0] === n[0])
        M = 0;
      else if (a[1] === n[1])
        M = 1;
      else if (a[2] === n[2])
        M = 2;
      else {
        console.error("Error: No constant dimension found.");
        return;
      }
      const T = [0, 1, 2].filter((ut) => ut !== M), U = [];
      U[M] = a[M], U[T[0]] = (a[T[0]] + n[T[0]]) / 2, U[T[1]] = (a[T[1]] + n[T[1]]) / 2;
      const R = Math.abs(n[T[0]] - a[T[0]]) / 2, N = Math.abs(n[T[1]] - a[T[1]]) / 2, k = l.dims[1], L = l.dims[2], q = Math.max(0, Math.floor(U[T[0]] - R)), _ = Math.min(l.dims[T[0] + 1] - 1, Math.ceil(U[T[0]] + R)), z = Math.max(0, Math.floor(U[T[1]] - N)), K = Math.min(l.dims[T[1] + 1] - 1, Math.ceil(U[T[1]] + N)), W = U[M];
      if (W < 0 || W >= l.dims[M + 1]) {
        console.error("Error: Constant dimension value is out of bounds.");
        return;
      }
      for (let ut = q; ut <= _; ut++)
        for (let bt = z; bt <= K; bt++) {
          const xt = [];
          xt[M] = W, xt[T[0]] = ut, xt[T[1]] = bt;
          const St = (xt[T[0]] - U[T[0]]) / R, Ft = (xt[T[1]] - U[T[1]]) / N;
          if (St * St + Ft * Ft <= 1) {
            const Cn = xt[0], Fn = xt[1], Mn = xt[2] * k * L + Fn * k + Cn;
            g[Mn] = 1;
          }
        }
      const $ = R * c[T[0] + 1], tt = N * c[T[1] + 1];
      o = Math.PI * $ * tt;
    }
    let p = 0, A = 0, x = 0, w = Number.NEGATIVE_INFINITY, v = Number.POSITIVE_INFINITY, F = 0, C = 0, b = 0;
    for (let M = 0; M < u; M++) {
      if (g[M] < 1)
        continue;
      const B = m[M];
      p++;
      let T = A + (B - A) / p;
      x = x + (B - A) * (B - T), A = T, B !== 0 && (F++, T = C + (B - C) / F, b = b + (B - C) * (B - T), C = T, v = Math.min(B, v), w = Math.max(B, w));
    }
    const y = Math.sqrt(x / (p - 1)), E = Math.sqrt(b / (F - 1)), S = v, D = w;
    return p !== F && (v = Math.min(0, v), w = Math.max(0, w)), {
      mean: A,
      stdev: y,
      nvox: p,
      volumeMM3: p * l.pixDims[1] * l.pixDims[2] * l.pixDims[3],
      // volume also in milliliters
      volumeML: p * l.pixDims[1] * l.pixDims[2] * l.pixDims[3] * 1e-3,
      min: v,
      max: w,
      meanNot0: C,
      stdevNot0: E,
      nvoxNot0: F,
      minNot0: S,
      maxNot0: D,
      cal_min: this.volumes[t].cal_min,
      cal_max: this.volumes[t].cal_max,
      robust_min: this.volumes[t].robust_min,
      robust_max: this.volumes[t].robust_max,
      area: o
    };
  }
  /**
   * Updates textures, shaders, and GPU state for a given overlay layer based on image properties and rendering options.
   * @internal
   */
  refreshLayers(e, t) {
    var C;
    if (this.volumes.length < 1)
      return;
    this.refreshColormaps();
    const i = e.hdr;
    let s = e.img;
    e.frame4D > 0 && e.frame4D < e.nFrame4D && (s = e.img.slice(
      e.frame4D * e.nVox3D,
      (e.frame4D + 1) * e.nVox3D
    ));
    const r = e.opacity;
    if (t > 1 && r === 0)
      return;
    let a = null;
    if (!this.back)
      throw new Error("back undefined");
    this.gl.bindVertexArray(this.unusedVAO), this.crosshairs3D && (this.crosshairs3D.mm[0] = NaN);
    let n = mt(e.toRAS);
    if (t === 0) {
      this.volumeObject3D = rc(e, this.VOLUME_ID, this.gl), Vt(n, n), this.back.matRAS = e.matRAS, this.back.dims = e.dimsRAS, this.back.pixDims = e.pixDimsRAS;
      const { volScale: b, vox: y } = this.sliceScale(!0);
      this.volScale = b, this.vox = y, this.volumeObject3D.scale = b, (i.dims[1] > this.uiData.max2D || i.dims[2] > this.uiData.max2D) && V.error("Image dimensions exceed maximum texture size of hardware.");
      const S = i.dims[1] > this.uiData.max3D || i.dims[2] > this.uiData.max3D || i.dims[3] > this.uiData.max3D;
      if (S && i.datatypeCode === 2304 && i.dims[3] < 2) {
        V.info(`Large RGBA image (>${this.uiData.max3D}) requires Texture2D`), this.opts.is2DSliceShader = !0, a = this.rgbaTex2D(this.volumeTexture, ie, e.dimsRAS, s);
        return;
      }
      if (S) {
        V.info(
          `Large scalar image (>${this.uiData.max3D}) requires Texture2D (${i.dims[1]}${i.dims[2]}${i.dims[3]})`
        );
        const M = i.dims[1] * i.dims[2], B = this.frac2vox(this.scene.crosshairPos), U = Math.min(Math.max(B[2], 0), i.dims[3] - 1) * M, R = new Uint8Array(M * 4), N = new Uint32Array(R.buffer), k = Math.floor(e.opacity * 255), L = 255 * i.scl_slope / (e.cal_max - e.cal_min), q = 255 * (i.scl_inter - e.cal_min) / (e.cal_max - e.cal_min), _ = new Uint8Array(this.colormap(e.colormap)), z = new Uint32Array(_.buffer);
        let K = -1;
        for (let W = 0; W < M; W++) {
          const $ = s[W + U] * L + q, tt = Math.round(Math.min(255, Math.max(0, $)));
          N[W] = z[tt], R[K += 4] = k;
        }
        this.opts.is2DSliceShader = !0, a = this.rgbaTex2D(
          this.volumeTexture,
          ie,
          e.dimsRAS,
          R,
          !1
        );
        return;
      }
      if (S && V.warn(`dimensions exceed 3D limits ${i.dims}`), this.opts.is2DSliceShader = !1, a = this.rgbaTex(this.volumeTexture, ie, e.dimsRAS), !this.renderShader)
        throw new Error("renderShader undefined");
      this.renderShader.use(this.gl), this.gl.uniform3fv(this.renderShader.uniforms.texVox, y), this.gl.uniform3fv(this.renderShader.uniforms.volScale, b);
      const D = this.pickingImageShader;
      D.use(this.gl), this.gl.uniform1i(D.uniforms.volume, 0), this.gl.uniform1i(D.uniforms.colormap, 1), this.gl.uniform1i(D.uniforms.overlay, 2), this.gl.uniform3fv(D.uniforms.volScale, b), V.debug(this.volumeObject3D);
    } else {
      ((C = this.back) == null ? void 0 : C.dims) === void 0 && V.error("Fatal error: Unable to render overlay: background dimensions not defined!");
      const b = this.mm2frac(e.mm000, 0, !0);
      let y = this.mm2frac(e.mm100, 0, !0), E = this.mm2frac(e.mm010, 0, !0), S = this.mm2frac(e.mm001, 0, !0);
      y = ot(y, y, b), E = ot(E, E, b), S = ot(S, S, b), n = Pt(
        y[0],
        E[0],
        S[0],
        b[0],
        y[1],
        E[1],
        S[1],
        b[1],
        y[2],
        E[2],
        S[2],
        b[2],
        0,
        0,
        0,
        1
      ), Vt(n, n), t === 1 ? (a = this.rgbaTex(this.overlayTexture, fi, this.back.dims), this.overlayTexture = a, this.overlayTextureID = a) : a = this.overlayTextureID;
    }
    const o = this.gl.createFramebuffer();
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, o), this.gl.disable(this.gl.CULL_FACE), this.gl.viewport(0, 0, this.back.dims[1], this.back.dims[2]), this.gl.disable(this.gl.BLEND);
    const l = this.gl.createTexture();
    this.gl.activeTexture(br), this.gl.bindTexture(this.gl.TEXTURE_3D, l), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
    let c = this.orientShaderU;
    if (!i)
      throw new Error("hdr undefined");
    if (!s)
      throw new Error("img undefined");
    if (i.datatypeCode === 2)
      i.intent_code === 1002 && (c = this.orientShaderAtlasU), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R8UI, i.dims[1], i.dims[2], i.dims[3]), this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i.dims[1],
        i.dims[2],
        i.dims[3],
        this.gl.RED_INTEGER,
        this.gl.UNSIGNED_BYTE,
        s
      );
    else if (i.datatypeCode === 4)
      c = this.orientShaderI, i.intent_code === 1002 && (c = this.orientShaderAtlasI), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16I, i.dims[1], i.dims[2], i.dims[3]), this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i.dims[1],
        i.dims[2],
        i.dims[3],
        this.gl.RED_INTEGER,
        this.gl.SHORT,
        s
      );
    else if (i.datatypeCode === 16)
      this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R32F, i.dims[1], i.dims[2], i.dims[3]), this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i.dims[1],
        i.dims[2],
        i.dims[3],
        this.gl.RED,
        this.gl.FLOAT,
        s
      ), c = this.orientShaderF;
    else if (i.datatypeCode === 64) {
      let b = new Float32Array();
      b = Float32Array.from(s), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R32F, i.dims[1], i.dims[2], i.dims[3]), this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i.dims[1],
        i.dims[2],
        i.dims[3],
        this.gl.RED,
        this.gl.FLOAT,
        b
      ), c = this.orientShaderF;
    } else if (i.datatypeCode === 128)
      c = this.orientShaderRGBU, c.use(this.gl), this.gl.uniform1i(c.uniforms.hasAlpha, 0), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGB8UI, i.dims[1], i.dims[2], i.dims[3]), this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i.dims[1],
        i.dims[2],
        i.dims[3],
        this.gl.RGB_INTEGER,
        this.gl.UNSIGNED_BYTE,
        s
      );
    else if (i.datatypeCode === 512)
      i.intent_code === 1002 && (c = this.orientShaderAtlasU), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16UI, i.dims[1], i.dims[2], i.dims[3]), this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i.dims[1],
        i.dims[2],
        i.dims[3],
        this.gl.RED_INTEGER,
        this.gl.UNSIGNED_SHORT,
        s
      );
    else if (i.datatypeCode === 2304) {
      if (c = this.orientShaderRGBU, e.colormapLabel) {
        c = this.orientShaderPAQD;
        let b = !0;
        for (let y = 0; y < t; y++) {
          const E = this.volumes[y].hdr.datatypeCode === 2304, S = !!this.volumes[y].colormapLabel;
          E && S && (b = !1);
        }
        b ? this.paqdTexture = this.rgbaTex(this.paqdTexture, ue, this.back.dims) : V.warn("Current version only one probabilistic atlas (PAQD) at a time"), a = this.paqdTexture, this.gl.activeTexture(br);
      }
      c.use(this.gl), this.gl.uniform1i(c.uniforms.hasAlpha, 1), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA8UI, i.dims[1], i.dims[2], i.dims[3]), this.gl.texSubImage3D(
        this.gl.TEXTURE_3D,
        0,
        0,
        0,
        0,
        i.dims[1],
        i.dims[2],
        i.dims[3],
        this.gl.RGBA_INTEGER,
        this.gl.UNSIGNED_BYTE,
        s
      );
    }
    e.global_min === void 0 && e.calMinMax();
    let h = null;
    if (this.gl.bindVertexArray(this.genericVAO), t > 1) {
      if (!this.back.dims)
        throw new Error("back.dims undefined");
      h = this.rgbaTex(h, yr, this.back.dims), this.gl.bindTexture(this.gl.TEXTURE_3D, h);
      const b = this.passThroughShader;
      b.use(this.gl), this.gl.uniform1i(b.uniforms.in3D, 2);
      for (let y = 0; y < this.back.dims[3]; y++) {
        const E = 1 / this.back.dims[3] * (y + 0.5);
        this.gl.uniform1f(b.uniforms.coordZ, E), this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, h, 0, y), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      }
    } else
      h = this.rgbaTex(h, yr, [2, 2, 2, 2]);
    c.use(this.gl), this.gl.activeTexture(Se);
    let f = null;
    if (e.colormapLabel !== null && e.colormapLabel.lut.length > 7) {
      const b = e.colormapLabel.max - e.colormapLabel.min + 1;
      f = this.createColormapTexture(f, 1, b), this.gl.texSubImage2D(
        this.gl.TEXTURE_2D,
        0,
        0,
        0,
        b,
        1,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        e.colormapLabel.lut
      ), this.gl.uniform1f(c.uniforms.cal_min, e.colormapLabel.min - 0.5), this.gl.uniform1f(c.uniforms.cal_max, e.colormapLabel.max + 0.5), this.gl.bindTexture(this.gl.TEXTURE_2D, f);
    } else
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture), this.gl.uniform1f(c.uniforms.cal_min, e.cal_min), this.gl.uniform1f(c.uniforms.cal_max, e.cal_max);
    "alphaThreshold" in e && (V.warn("alphaThreshold is deprecated: use colormapType"), e.alphaThreshold === !0 && (e.colormapType = 2), e.alphaThreshold === !1 && (e.colormapType = 1), delete e.alphaThreshold);
    const d = e.colormapType !== 0 ? 1 : 0, u = e.colormapType === 2 ? 1 : 0;
    this.gl.uniform1i(c.uniforms.isAlphaThreshold, u), this.gl.uniform1i(c.uniforms.isColorbarFromZero, d), this.gl.uniform1i(c.uniforms.isAdditiveBlend, this.opts.isAdditiveBlend ? 1 : 0);
    let m = Number.POSITIVE_INFINITY, g = Number.NEGATIVE_INFINITY;
    if (e.colormapNegative.length > 0 && (m = Math.min(-e.cal_min, -e.cal_max), g = Math.max(-e.cal_min, -e.cal_max), isFinite(e.cal_minNeg) && isFinite(e.cal_maxNeg) && (m = Math.min(e.cal_minNeg, e.cal_maxNeg), g = Math.max(e.cal_minNeg, e.cal_maxNeg))), t > 0 && this.overlayOutlineWidth > 0) {
      const b = e.cal_min, y = e.cal_max;
      let E = Math.min(b, y) <= 0 && Math.max(b, y) >= 0;
      !E && m < g && (E = m <= 0 && g >= 0), E && V.error("issue1139: do not use overlayOutlineWidth when thresholds cross or touch zero");
    }
    if (!c)
      throw new Error("orientShader undefined");
    this.gl.uniform1f(c.uniforms.layer ?? null, t), this.gl.uniform1f(c.uniforms.cal_minNeg ?? null, m), this.gl.uniform1f(c.uniforms.cal_maxNeg ?? null, g), this.gl.bindTexture(this.gl.TEXTURE_3D, l), this.gl.uniform1i(c.uniforms.intensityVol ?? null, 9), this.gl.uniform1i(c.uniforms.blend3D ?? null, 10), this.gl.uniform1i(c.uniforms.colormap ?? null, 1), this.gl.uniform1f(c.uniforms.scl_inter ?? null, i.scl_inter), this.gl.uniform1f(c.uniforms.scl_slope ?? null, i.scl_slope), this.gl.uniform1f(c.uniforms.opacity ?? null, r), this.gl.uniform1i(c.uniforms.modulationVol ?? null, 7);
    let p = null;
    if (e.modulationImage !== null && e.modulationImage >= 0 && e.modulationImage < this.volumes.length) {
      V.debug("modulating", this.volumes);
      const b = this.volumes[e.modulationImage].hdr;
      if (b.dims[1] === i.dims[1] && b.dims[2] === i.dims[2] && b.dims[3] === i.dims[3]) {
        e.modulateAlpha ? (this.gl.uniform1i(c.uniforms.modulation, 2), this.gl.uniform1f(c.uniforms.opacity, 1)) : this.gl.uniform1i(c.uniforms.modulation, 1), p = this.r8Tex(p, this.gl.TEXTURE7, i.dims, !0), this.gl.activeTexture(this.gl.TEXTURE7), this.gl.bindTexture(this.gl.TEXTURE_3D, p);
        const y = i.dims[1] * i.dims[2] * i.dims[3], E = new Uint8Array(y), S = this.volumes[e.modulationImage].cal_min, D = 1 / (this.volumes[e.modulationImage].cal_max - S), M = this.volumes[e.modulationImage].img.buffer;
        let B = new Uint8Array(
          M
        );
        switch (b.datatypeCode) {
          case 4:
            B = new Int16Array(M);
            break;
          case 16:
            B = new Float32Array(M);
            break;
          case 64:
            B = new Float64Array(M);
            break;
          case 128:
            B = new Uint8Array(M);
            break;
          case 512:
            B = new Uint16Array(M);
            break;
        }
        V.debug(this.volumes[e.modulationImage]);
        const T = this.volumes[e.modulationImage].colormapNegative.length > 0;
        let U = this.volumes[e.modulationImage].cal_min, R = this.volumes[e.modulationImage].cal_max;
        isFinite(this.volumes[e.modulationImage].cal_minNeg) && isFinite(this.volumes[e.modulationImage].cal_maxNeg) && (U = this.volumes[e.modulationImage].cal_minNeg, R = this.volumes[e.modulationImage].cal_minNeg), U = Math.abs(U), R = Math.abs(R), U > R && ([U, R] = [R, U]);
        const N = 1 / (R - U);
        let k = Math.abs(e.modulateAlpha);
        k = Math.max(k, 1);
        const L = this.volumes[e.modulationImage].frame4D * y;
        for (let q = 0; q < y; q++) {
          const _ = B[q + L] * b.scl_slope + b.scl_inter;
          let z = (_ - S) * D;
          T && _ < 0 && (z = (Math.abs(_) - U) * N), z = Math.min(Math.max(z, 0), 1), z = Math.pow(z, k) * 255, E[q] = z;
        }
        this.gl.texSubImage3D(
          this.gl.TEXTURE_3D,
          0,
          0,
          0,
          0,
          i.dims[1],
          i.dims[2],
          i.dims[3],
          this.gl.RED,
          this.gl.UNSIGNED_BYTE,
          E
        );
      } else
        V.debug("Modulation image dimensions do not match target");
    } else
      this.gl.uniform1i(c.uniforms.modulation, 0);
    if (this.gl.uniformMatrix4fv(c.uniforms.mtx, !1, n), !this.back.dims)
      throw new Error("back.dims undefined");
    let A = 0;
    i.intent_code === 1002 && (A = this.opts.atlasOutline, this.gl.uniform1ui(c.uniforms.activeIndex, this.opts.atlasActiveIndex | 0)), this.gl.uniform4fv(c.uniforms.xyzaFrac, [
      1 / this.back.dims[1],
      1 / this.back.dims[2],
      1 / this.back.dims[3],
      A
    ]), V.debug("back dims: ", this.back.dims);
    for (let b = 0; b < this.back.dims[3]; b++) {
      const y = 1 / this.back.dims[3] * (b + 0.5);
      this.gl.uniform1f(c.uniforms.coordZ, y), this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, a, 0, b), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    if (this.gl.bindVertexArray(this.unusedVAO), this.gl.deleteTexture(l), this.gl.deleteTexture(p), this.gl.deleteTexture(h), this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.deleteFramebuffer(o), t === 0 && (this.volumeTexture = a, this.gradientTextureAmount > 0 && !this.useCustomGradientTexture ? (this.gradientGL(i), this.gl.bindVertexArray(this.genericVAO)) : this.gradientTextureAmount <= 0 && (this.gradientTexture !== null && this.gl.deleteTexture(this.gradientTexture), this.gradientTexture = null)), !this.renderShader)
      throw new Error("renderShader undefined");
    this.renderShader.use(this.gl);
    const x = this.sliceScale(!0), w = x.vox, v = x.volScale;
    if (this.gl.uniform1f(this.renderShader.uniforms.overlays, this.overlays.length), this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor, this.opts.clipPlaneColor), this.gl.uniform1f(this.renderShader.uniforms.backOpacity, this.volumes[0].opacity), this.gl.uniform1f(this.renderShader.uniforms.renderOverlayBlend, this.opts.renderOverlayBlend), this.gl.uniform4fv(this.renderShader.uniforms.clipPlane, this.scene.clipPlane), this.gl.uniform3fv(this.renderShader.uniforms.texVox, w), this.gl.uniform3fv(this.renderShader.uniforms.volScale, v), !this.pickingImageShader)
      throw new Error("pickingImageShader undefined");
    this.pickingImageShader.use(this.gl), this.gl.uniform1f(this.pickingImageShader.uniforms.overlays, this.overlays.length), this.gl.uniform3fv(this.pickingImageShader.uniforms.texVox, w);
    let F = this.sliceMMShader;
    if (this.opts.is2DSliceShader && (F = this.slice2DShader), this.opts.isV1SliceShader && (F = this.sliceV1Shader), this.customSliceShader && (F = this.customSliceShader), !F)
      throw new Error("slice shader undefined");
    F.use(this.gl), this.gl.uniform1f(F.uniforms.overlays, this.overlays.length), this.gl.uniform1f(F.uniforms.drawOpacity, this.drawOpacity), f !== null && (this.gl.deleteTexture(f), this.gl.activeTexture(Se), this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture)), this.gl.uniform1i(F.uniforms.drawing, 7), this.gl.activeTexture(qt), this.opts.is2DSliceShader ? this.gl.bindTexture(this.gl.TEXTURE_2D, this.drawTexture) : this.gl.bindTexture(this.gl.TEXTURE_3D, this.drawTexture), this.gl.uniform4fv(F.uniforms.paqdUniforms, this.opts.paqdUniforms), this.gl.uniform1i(F.uniforms.paqd, 8), this.gl.activeTexture(ue), this.gl.bindTexture(this.gl.TEXTURE_3D, this.paqdTexture), this.updateInterpolation(t);
  }
  /**
   * query all available color maps that can be applied to volumes
   * @returns an array of colormap strings
   * @example
   * niivue = new Niivue()
   * colormaps = niivue.colormaps()
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  colormaps() {
    return rt.colormaps();
  }
  /**
   * create a new colormap
   * @param key - name of new colormap
   * @param cmap - colormap properties (Red, Green, Blue, Alpha and Indices)
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  addColormap(e, t) {
    rt.addColormap(e, t);
  }
  /**
   * update the colormap of an image given its ID
   * @param id - the ID of the NVImage
   * @param colormap - the name of the colormap to use
   * @example
   * niivue.setColormap(niivue.volumes[0].id,, 'red')
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  setColormap(e, t) {
    const i = this.getVolumeIndexByID(e);
    this.volumes[i].colormap = t, this.updateGLVolume();
  }
  // port of https://github.com/rordenlab/niimath/blob/master/src/bwlabel.c
  /**
   * Computes the linear voxel index from 3D coordinates using image dimensions.
   * @internal
   */
  idx(e, t, i, s) {
    return i * s[0] * s[1] + t * s[0] + e;
  }
  // idx()
  /**
   * Checks if voxels below the given voxel have labels matching its value, returning the first matching label or 0.
   * @internal
   */
  check_previous_slice(e, t, i, s, r, a, n, o) {
    const l = new Uint32Array(27);
    let c = 0;
    if (!r)
      return 0;
    const h = e[this.idx(i, s, r, a)];
    if (n >= 6) {
      const f = this.idx(i, s, r - 1, a);
      h === e[f] && (l[c++] = t[f]);
    }
    if (n >= 18) {
      if (i) {
        const f = this.idx(i - 1, s, r - 1, a);
        h === e[f] && (l[c++] = t[f]);
      }
      if (s) {
        const f = this.idx(i, s - 1, r - 1, a);
        h === e[f] && (l[c++] = t[f]);
      }
      if (i < a[0] - 1) {
        const f = this.idx(i + 1, s, r - 1, a);
        h === e[f] && (l[c++] = t[f]);
      }
      if (s < a[1] - 1) {
        const f = this.idx(i, s + 1, r - 1, a);
        h === e[f] && (l[c++] = t[f]);
      }
    }
    if (n === 26) {
      if (i && s) {
        const f = this.idx(i - 1, s - 1, r - 1, a);
        h === e[f] && (l[c++] = t[f]);
      }
      if (i < a[0] - 1 && s) {
        const f = this.idx(i + 1, s - 1, r - 1, a);
        h === e[f] && (l[c++] = t[f]);
      }
      if (i && s < a[1] - 1) {
        const f = this.idx(i - 1, s + 1, r - 1, a);
        h === e[f] && (l[c++] = t[f]);
      }
      if (i < a[0] - 1 && s < a[1] - 1) {
        const f = this.idx(i + 1, s + 1, r - 1, a);
        h === e[f] && (l[c++] = t[f]);
      }
    }
    return c ? (this.fill_tratab(o, l, c), l[0]) : 0;
  }
  // check_previous_slice()
  /**
   * Performs provisional labeling of connected voxels in a volume using specified connectivity.
   * @internal
   */
  do_initial_labelling(e, t, i) {
    let s = 1;
    const r = 8192;
    let a = r, n = new Uint32Array(a).fill(0);
    const o = new Uint32Array(t[0] * t[1] * t[2]).fill(0), l = new Uint32Array(27);
    for (let c = 0; c < t[2]; c++)
      for (let h = 0; h < t[1]; h++)
        for (let f = 0; f < t[0]; f++) {
          let d = 0;
          const u = e[this.idx(f, h, c, t)];
          if (u !== 0) {
            if (l[0] = this.check_previous_slice(e, o, f, h, c, t, i, n), l[0] && (d += 1), i >= 6) {
              if (f) {
                const m = this.idx(f - 1, h, c, t);
                u === e[m] && (l[d++] = o[m]);
              }
              if (h) {
                const m = this.idx(f, h - 1, c, t);
                u === e[m] && (l[d++] = o[m]);
              }
            }
            if (i >= 18) {
              if (h && f) {
                const m = this.idx(f - 1, h - 1, c, t);
                u === e[m] && (l[d++] = o[m]);
              }
              if (h && f < t[0] - 1) {
                const m = this.idx(f + 1, h - 1, c, t);
                u === e[m] && (l[d++] = o[m]);
              }
            }
            if (d)
              o[this.idx(f, h, c, t)] = l[0], this.fill_tratab(n, l, d);
            else {
              if (o[this.idx(f, h, c, t)] = s, s >= a) {
                a += r;
                const m = new Uint32Array(a);
                m.set(n), n = m;
              }
              n[s - 1] = s, s++;
            }
          }
        }
    for (let c = 0; c < s - 1; c++) {
      let h = c;
      for (; n[h] !== h + 1; )
        h = n[h] - 1;
      n[c] = h + 1;
    }
    return [s - 1, n, o];
  }
  // do_initial_labelling()
  /**
   * Merges multiple provisional labels into a unified class using a translation table.
   * @internal
   */
  fill_tratab(e, t, i) {
    let s = 0;
    const r = new Uint32Array(i + 5).fill(0);
    let n = 2147483647;
    for (let o = 0; o < i; o++) {
      let l = t[o];
      for (s = 0; e[l - 1] !== l; )
        if (l = e[l - 1], s++, s > 100) {
          V.info(`
Ooh no!!`);
          break;
        }
      r[o] = l, n = Math.min(n, l);
    }
    for (let o = 0; o < i; o++)
      e[r[o] - 1] = n;
  }
  // fill_tratab()
  /**
   * Removes gaps in label indices to produce a dense labeling.
   * @internal
   */
  translate_labels(e, t, i, s) {
    const r = t[0] * t[1] * t[2];
    let a = 0;
    const n = new Uint32Array(r).fill(0);
    for (let c = 0; c < s; c++)
      a = Math.max(a, i[c]);
    const o = new Uint32Array(a).fill(0);
    let l = 0;
    for (let c = 0; c < r; c++)
      e[c] && (o[i[e[c] - 1] - 1] || (l += 1, o[i[e[c] - 1] - 1] = l), n[c] = o[i[e[c] - 1] - 1]);
    return [l, n];
  }
  // translate_labels()
  /**
   * Retains only the largest cluster for each region in a labeled volume.
   * @internal
   */
  largest_original_cluster_labels(e, t, i) {
    const s = e.length, r = new Uint32Array(t + 1).fill(0), a = new Uint32Array(t + 1).fill(0);
    for (let l = 0; l < s; l++) {
      const c = e[l], h = i[l];
      r[h] = c, a[h]++;
    }
    let n = 0;
    for (let l = 0; l < t + 1; l++) {
      const c = r[l];
      n = Math.max(n, c);
      for (let h = 0; h < t + 1; h++)
        h !== l && c === r[h] && (a[l] < a[h] || a[l] === a[h] && l < h) && (r[l] = 0);
    }
    const o = new Uint32Array(s).fill(0);
    for (let l = 0; l < s; l++)
      o[l] = r[i[l]];
    return [n, o];
  }
  /**
   * Computes connected components labeling on a 3D image.
   * @internal
   */
  bwlabel(e, t, i = 26, s = !1, r = !1) {
    const a = Date.now(), n = t[0] * t[1] * t[2], o = new Uint32Array(n).fill(0);
    if (![6, 18, 26].includes(i))
      return V.info("bwlabel: conn must be 6, 18 or 26."), [0, o];
    if (t[0] < 2 || t[1] < 2 || t[2] < 1)
      return V.info("bwlabel: img must be 2 or 3-dimensional"), [0, o];
    if (s)
      for (let u = 0; u < n; u++)
        e[u] !== 0 && (o[u] = 1);
    else
      o.set(e);
    let [l, c, h] = this.do_initial_labelling(o, t, i);
    c === void 0 && (c = new Uint32Array());
    const [f, d] = this.translate_labels(h, t, c, l);
    if (V.info(i + " neighbor clustering into " + f + " regions in " + (Date.now() - a) + "ms"), r) {
      const [u, m] = this.largest_original_cluster_labels(o, f, d);
      return [u, m];
    }
    return [f, d];
  }
  // bwlabel()
  /**
   * Create a connected component label map from a volume
   * @param id - ID of the input volume
   * @param conn - connectivity for clustering (6 = faces, 18 = faces + edges, 26 = faces + edges + corners)
   * @param binarize - whether to binarize the volume before labeling
   * @param onlyLargestClusterPerClass - retain only the largest cluster for each label
   * @returns a new NVImage with labeled clusters, using random colormap
   * @see {@link https://niivue.com/demos/features/clusterize.html | live demo usage}
   */
  async createConnectedLabelImage(e, t = 26, i = !1, s = !1) {
    var h, f;
    const r = this.getVolumeIndexByID(e), a = Uint32Array.from(((h = this.volumes[r].dims) == null ? void 0 : h.slice(1, 4)) ?? []), n = Uint32Array.from(((f = this.volumes[r].img) == null ? void 0 : f.slice()) ?? []), [o, l] = this.bwlabel(n, a, t, i, s), c = this.volumes[r].clone();
    c.opacity = 0.5, c.colormap = "random";
    for (let d = 0; d < c.img.length; d++)
      c.img[d] = l[d];
    return c.cal_min = 0, c.cal_max = o, c;
  }
  // conform.py functions follow
  // https://github.com/Deep-MI/FastSurfer/blob/4e76bed7b11fd7e6403ddac729059ad3842b56de/FastSurferCNN/data_loader/conform.py
  // Licensed under the Apache License, Version 2.0 (the "License")
  // Crop the intensity ranges to specific min and max values.
  /**
   * Scales and crops a Float32 image to Uint8 range.
   * @internal
   */
  async scalecropUint8(e, t = 0, i = 255, s, r) {
    const a = e.length, n = new Uint8Array(a);
    for (let o = 0; o < a; o++) {
      let l = e[o];
      l = t + r * (l - s), l = Math.max(l, t), l = Math.min(l, i), n[o] = l;
    }
    return n;
  }
  /**
   * Scales and crops a Float32 image to a specified range.
   * @internal
   */
  async scalecropFloat32(e, t = 0, i = 1, s, r) {
    const a = e.length, n = new Float32Array(a);
    for (let o = 0; o < a; o++) {
      let l = e[o];
      l = t + r * (l - s), l = Math.max(l, t), l = Math.min(l, i), n[o] = l;
    }
    return n;
  }
  /**
   * Computes offset and scale to robustly rescale image intensities to a target range.
   * @internal
   */
  getScale(e, t = 0, i = 255, s = 0, r = 0.999) {
    let a = e.global_min, n = e.global_max;
    if (e.hdr.datatypeCode === 2)
      return [a, 1];
    if ((!isFinite(s) || !isFinite(r)) && isFinite(e.cal_min) && isFinite(e.cal_max) && e.cal_max > e.cal_min) {
      a = e.cal_min, n = e.cal_max;
      const x = (i - t) / (n - a);
      return V.info(" Robust Rescale:  min: " + a + "  max: " + n + " scale: " + x), [a, x];
    }
    let o = e.img;
    const l = e.hdr.dims[1] * e.hdr.dims[2] * e.hdr.dims[3];
    if (e.hdr.scl_slope !== 1 || e.hdr.scl_inter !== 0) {
      const x = e.img;
      o = new Float32Array(e.img.length);
      for (let w = 0; w < l; w++)
        o[w] = x[w] * e.hdr.scl_slope + e.hdr.scl_inter;
    }
    if (a < 0 && V.warn("WARNING: Input image has value(s) below 0.0 !"), V.info(" Input:    min: " + a + "  max: " + n), s === 0 && r === 1)
      return [a, 1];
    let c = 0;
    for (let x = 0; x < l; x++)
      Math.abs(o[x]) >= 1e-15 && c++;
    const h = 1e3, f = (n - a) / h, d = new Array(h).fill(0);
    for (let x = 0; x < l; x++) {
      const w = o[x];
      let v = Math.floor((w - a) / f);
      v = Math.min(v, h - 1), d[v]++;
    }
    const u = new Array(h).fill(0);
    u[0] = d[0];
    for (let x = 1; x < h; x++)
      u[x] = u[x - 1] + d[x];
    let m = Math.floor(s * l), g = 0;
    for (; g < h && !(u[g] >= m); )
      g++;
    const p = a;
    for (a = g * f + p, m = l - Math.floor((1 - r) * c), g = 0; g < h - 1 && !(u[g + 1] >= m); )
      g++;
    n = g * f + p;
    let A = 1;
    return a !== n && (A = (i - t) / (n - a)), V.info(" Rescale:  min: " + a + "  max: " + n + " scale: " + A), [a, A];
  }
  // Translation of nibabel mghformat.py (MIT License 2009-2019) and FastSurfer conform.py (Apache License)
  // https://github.com/nipy/nibabel/blob/a2e5dee05cf374c22670ff9fd0d385ce366eb495/nibabel/freesurfer/mghformat.py#L30
  /**
   * Computes output affine, voxel-to-voxel transform, and its inverse for resampling.
   * @internal
   */
  conformVox2Vox(e, t, i = 256, s = 1, r = !1) {
    const a = t.flat(), n = Pt(
      a[0],
      a[1],
      a[2],
      a[3],
      a[4],
      a[5],
      a[6],
      a[7],
      a[8],
      a[9],
      a[10],
      a[11],
      a[12],
      a[13],
      a[14],
      a[15]
    ), o = ht(e[1] / 2, e[2] / 2, e[3] / 2, 1), l = Wt(), c = it();
    Ut(c, n), Ct(l, o, c);
    const h = O(l[0], l[1], l[2]), f = O(s, s, s);
    let d = Pt(-1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
    r && (d = Pt(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)), Ut(d, d);
    const u = ht(i, i, i, 1), m = it();
    Ns(m, d, f);
    const g = ht(u[0], u[1], u[2], 1);
    Ct(g, g, m), Hn(g, g, 0.5);
    const p = nt();
    ot(p, h, O(g[0], g[1], g[2]));
    const A = it();
    Ut(A, m), A[3] = p[0], A[7] = p[1], A[11] = p[2];
    const x = it();
    Vt(x, A);
    const w = it();
    Br(w, n, x);
    const v = it();
    return Vt(v, w), [A, w, v];
  }
  /**
   * Create a binary NIfTI file as a Uint8Array, including header and image data
   * @param dims - image dimensions [x, y, z]
   * @param pixDims - voxel dimensions in mm [x, y, z]
   * @param affine - 44 affine transformation matrix in row-major order
   * @param datatypeCode - NIfTI datatype code (e.g., DT_UINT8, DT_FLOAT32)
   * @param img - image data buffer (optional)
   * @returns a Uint8Array representing a complete NIfTI file
   * @see {@link https://niivue.com/demos/features/conform.html | live demo usage}
   */
  async createNiftiArray(e = [256, 256, 256], t = [1, 1, 1], i = [1, 0, 0, -128, 0, 1, 0, -128, 0, 0, 1, -128, 0, 0, 0, 1], s = 2, r = new Uint8Array()) {
    return await Mt.createNiftiArray(e, t, i, s, r);
  }
  /**
   * Convert a binary NIfTI file (as a Uint8Array) to an NVImage object
   * @param bytes - binary contents of a NIfTI file
   * @returns a Promise resolving to an NVImage object
   * @see {@link https://niivue.com/demos/features/conform.html | live demo usage}
   */
  async niftiArray2NVImage(e = new Uint8Array()) {
    return await Mt.loadFromUrl({ url: e });
  }
  /**
   * Load a NIfTI image from a URL and convert it to an NVImage object
   * @param fnm - URL of the NIfTI file to load
   * @returns a Promise resolving to an NVImage (not yet added to GPU or scene)
   * @see {@link https://niivue.com/demos/features/conform.html | live demo usage}
   */
  async loadFromUrl(e) {
    return await Mt.loadFromUrl({ url: e });
  }
  // Translation of FastSurfer conform.py (Apache License)
  // Reslice an image to an isotropic 1mm with dimensions of 1x1x1mm
  // The original volume is translated to be in the center of the new volume
  // Interpolation is linear (default) or nearest neighbor
  // asFloat32 determines if output is Float32 with range 0..255 or Uint8 with range 0..255
  /**
   * FreeSurfer-style conform reslices any image to a 256x256x256 volume with 1mm voxels
   * @param volume - input volume to be re-oriented, intensity-scaled and resliced
   * @param toRAS - reslice to row, column slices to right-anterior-superior not left-inferior-anterior (default false).
   * @param isLinear - reslice with linear rather than nearest-neighbor interpolation (default true).
   * @param asFloat32 - use Float32 datatype rather than Uint8 (default false).
   * @param isRobustMinMax - clamp intensity with robust min max (~2%..98%) instead of FreeSurfer (0%..99.99%) (default false).
   * @see {@link https://niivue.com/demos/features/torso.html | live demo usage}
   */
  async conform(e, t = !1, i = !0, s = !1, r = !1) {
    const o = this.conformVox2Vox(e.hdr.dims, e.hdr.affine.flat(), 256, 1, t), l = o[0], c = o[2], h = 256 * 256 * 256, f = new Float32Array(h), d = new Float32Array(e.img), u = e.hdr.dims[1] * e.hdr.dims[2] * e.hdr.dims[3];
    if (e.hdr.scl_slope !== 1 || e.hdr.scl_inter !== 0)
      for (let S = 0; S < u; S++)
        d[S] = d[S] * e.hdr.scl_slope + e.hdr.scl_inter;
    const m = e.hdr.dims[1], g = e.hdr.dims[2], p = e.hdr.dims[3], A = m * g;
    let x = -1;
    function w(S, D, M) {
      return S + D * m + M * A;
    }
    const v = c[0], F = c[4], C = c[8];
    if (i)
      for (let S = 0; S < 256; S++)
        for (let D = 0; D < 256; D++) {
          const M = D * c[1] + S * c[2] + c[3], B = D * c[5] + S * c[6] + c[7], T = D * c[9] + S * c[10] + c[11];
          for (let U = 0; U < 256; U++) {
            const R = U * v + M, N = U * F + B, k = U * C + T, L = Math.floor(R), q = Math.floor(N), _ = Math.floor(k);
            if (x++, L < 0 || q < 0 || _ < 0)
              continue;
            const z = Math.ceil(R), K = Math.ceil(N), W = Math.ceil(k);
            if (z >= m || K >= g || W >= p)
              continue;
            const $ = R - L, tt = N - q, at = k - _, ut = 1 - $, bt = 1 - tt, xt = 1 - at, St = w(L, q, _);
            let Ft = 0;
            Ft += d[St] * ut * bt * xt, Ft += d[St + A] * ut * bt * at, Ft += d[St + m] * ut * tt * xt, Ft += d[St + m + A] * ut * tt * at, Ft += d[St + 1] * $ * bt * xt, Ft += d[St + 1 + A] * $ * bt * at, Ft += d[St + 1 + m] * $ * tt * xt, Ft += d[St + 1 + m + A] * $ * tt * at, f[x] = Ft;
          }
        }
    else
      for (let S = 0; S < 256; S++)
        for (let D = 0; D < 256; D++) {
          const M = D * c[1] + S * c[2] + c[3], B = D * c[5] + S * c[6] + c[7], T = D * c[9] + S * c[10] + c[11];
          for (let U = 0; U < 256; U++) {
            const R = Math.round(U * v + M), N = Math.round(U * F + B), k = Math.round(U * C + T);
            x++, !(R < 0 || N < 0 || k < 0) && (R >= m || N >= g || k >= p || (f[x] = d[w(R, N, k)]));
          }
        }
    let b = 0;
    r && (b = NaN);
    let y = new Uint8Array();
    if (s) {
      const S = await this.getScale(e, 0, 1, b), D = await this.scalecropFloat32(f, 0, 1, S[0], S[1]);
      y = await this.createNiftiArray(
        [256, 256, 256],
        [1, 1, 1],
        Array.from(l),
        16,
        new Uint8Array(D.buffer)
      );
    } else {
      const S = await this.getScale(e, 0, 255, b), D = await this.scalecropUint8(f, 0, 255, S[0], S[1]);
      y = await this.createNiftiArray(
        [256, 256, 256],
        [1, 1, 1],
        Array.from(l),
        2,
        D
      );
    }
    return await this.niftiArray2NVImage(y);
  }
  /**
   * darken crevices and brighten corners when 3D rendering drawings.
   * @param ao - amount of ambient occlusion (default 0.4)
   * @see {@link https://niivue.com/demos/features/torso.html | live demo usage}
   */
  setRenderDrawAmbientOcclusion(e) {
    if (!this.renderShader)
      throw new Error("renderShader undefined");
    this.renderDrawAmbientOcclusion = e, this.renderShader.use(this.gl), this.gl.uniform1fv(this.renderShader.uniforms.renderDrawAmbientOcclusion, [this.renderDrawAmbientOcclusion, 1]), this.drawScene();
  }
  /**
   * @deprecated Use {@link setColormap} instead. This alias is retained for compatibility with NiiVue < 0.35.
   * @param id - ID of the volume
   * @param colormap - name of the colormap to apply
   */
  setColorMap(e, t) {
    this.setColormap(e, t);
  }
  /**
   * use given color map for negative voxels in image
   * @param id - the ID of the NVImage
   * @param colormapNegative - the name of the colormap to use
   * @example
   * niivue = new Niivue()
   * niivue.setColormapNegative(niivue.volumes[1].id,"winter");
   * @see {@link https://niivue.com/demos/features/mosaics2.html | live demo usage}
   */
  setColormapNegative(e, t) {
    const i = this.getVolumeIndexByID(e);
    this.volumes[i].colormapNegative = t, this.updateGLVolume();
  }
  /**
   * modulate intensity of one image based on intensity of another
   * @param idTarget - the ID of the NVImage to be biased
   * @param idModulation - the ID of the NVImage that controls bias (empty string to disable modulation)
   * @param modulateAlpha - does the modulation influence alpha transparency (values greater than 1).
   * @example niivue.setModulationImage(niivue.volumes[0].id, niivue.volumes[1].id);
   * @see {@link https://niivue.com/demos/features/modulate.html | live demo scalar usage}
   * @see {@link https://niivue.com/demos/features/modulateAfni.html | live demo usage}
   */
  setModulationImage(e, t, i = 0) {
    const s = this.getVolumeIndexByID(e);
    let r = null;
    t.length > 0 && (r = this.getVolumeIndexByID(t)), this.volumes[s].modulationImage = r, this.volumes[s].modulateAlpha = i, this.updateGLVolume();
  }
  /**
   * adjust screen gamma. Low values emphasize shadows but can appear flat, high gamma hides shadow details.
   * @param gamma - selects luminance, default is 1
   * @example niivue.setGamma(1.0);
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  setGamma(e = 1) {
    this.scene.gamma = e, rt.gamma = e, this.updateGLVolume();
  }
  /** Load all volumes for image opened with `limitFrames4D`, the user can also click the `...` on a 4D timeline to load deferred volumes
   * @param id - the ID of the 4D NVImage
   **/
  async loadDeferred4DVolumes(e) {
    const t = this.getVolumeIndexByID(e), i = this.volumes[t];
    if (i.nTotalFrame4D <= i.nFrame4D)
      return;
    i.nTotalFrame4D = i.nFrame4D;
    let s;
    i.fileObject ? s = await Mt.loadFromFile({ file: i.fileObject }) : s = await Mt.loadFromUrl({ url: i.url }), s && (i.img = s.img.slice(), i.nTotalFrame4D = s.nTotalFrame4D, i.nFrame4D = s.nFrame4D, this.updateGLVolume());
  }
  /**
   * show desired 3D volume from 4D time series
   * @param id - the ID of the 4D NVImage
   * @param frame4D - frame to display (indexed from zero)
   * @example nv1.setFrame4D(nv1.volumes[0].id, 42);
   * @see {@link https://niivue.com/demos/features/timeseries.html | live demo usage}
   */
  setFrame4D(e, t) {
    const i = this.getVolumeIndexByID(e), s = this.volumes[i];
    t > s.nFrame4D - 1 && (t = s.nFrame4D - 1), t < 0 && (t = 0), t !== s.frame4D && (s.frame4D = t, this.updateGLVolume(), this.onFrameChange(s, t), this.createOnLocationChange());
  }
  /**
   * determine active 3D volume from 4D time series
   * @param id - the ID of the 4D NVImage
   * @returns currently selected volume (indexed from 0)
   * @example nv1.getFrame4D(nv1.volumes[0].id);
   * @see {@link https://niivue.com/demos/features/timeseries.html | live demo usage}
   */
  getFrame4D(e) {
    const t = this.getVolumeIndexByID(e);
    return this.volumes[t].frame4D;
  }
  /**
   * Returns a colormap by its name key.
   * @internal
   */
  colormapFromKey(e) {
    return rt.colormapFromKey(e);
  }
  /**
   * Retrieve a colormap with optional inversion
   * @param lutName - name of the lookup table (LUT) colormap
   * @param isInvert - whether to invert the colormap
   * @returns the RGBA colormap as a Uint8ClampedArray
   * @see {@link https://niivue.com/demos/features/colormaps.html | live demo usage}
   */
  colormap(e = "", t = !1) {
    return rt.colormap(e, t);
  }
  /**
   * Creates or recreates a 2D RGBA colormap texture with specified rows and columns.
   * @internal
   */
  createColormapTexture(e = null, t = 0, i = 256) {
    return e !== null && this.gl.deleteTexture(e), t < 1 || i < 1 ? null : (e = this.gl.createTexture(), this.gl.activeTexture(Se), this.gl.bindTexture(this.gl.TEXTURE_2D, e), this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, i, t), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), e);
  }
  /**
   * Adds a colormap configuration to the internal list with given parameters.
   * @internal
   */
  addColormapList(e = "", t = NaN, i = NaN, s = !1, r = !1, a = !0, n = !1) {
    e.length < 1 && (a = !1), this.colormapLists.push({
      name: e,
      min: t,
      max: i,
      isColorbarFromZero: s,
      negative: r,
      visible: a,
      invert: n
    });
  }
  /**
   * Rebuild and upload all colormap textures for volumes and meshes
   * @returns the current NiiVue instance, or undefined if no colormaps are used
   * @see {@link https://niivue.com/demos/features/mesh.stats.html | live demo usage}
   */
  refreshColormaps() {
    if (this.colormapLists = [], this.volumes.length < 1 && this.meshes.length < 1)
      return;
    const e = this.volumes.length;
    if (e > 0)
      for (let a = 0; a < e; a++) {
        const n = this.volumes[a], o = qi(n.cal_min, n.cal_max, n.cal_minNeg, n.cal_maxNeg), l = n.colormapType !== 0;
        this.addColormapList(
          n.colormapNegative,
          o[0],
          o[1],
          l,
          !0,
          n.colorbarVisible,
          n.colormapInvert
        ), this.addColormapList(
          n.colormap,
          n.cal_min,
          n.cal_max,
          l,
          !1,
          n.colorbarVisible,
          n.colormapInvert
        );
      }
    const t = this.meshes.length;
    if (t > 0)
      for (let a = 0; a < t; a++) {
        const n = this.meshes[a];
        if (!n.colorbarVisible)
          continue;
        const o = n.layers.length, l = n.fiberColor.toLowerCase();
        if (n.offsetPt0 && l.startsWith("dp")) {
          let c = null;
          const h = parseInt(l.substring(3));
          l.startsWith("dpg") && !n.fiberGroupColormap && (c = h < n.dpg.length ? n.dpg[h] : n.dpg[0]), l.startsWith("dps") && (c = h < n.dps.length ? n.dps[h] : n.dps[0]), l.startsWith("dpv") && (c = h < n.dpv.length ? n.dpv[h] : n.dpv[0]), c && typeof n.colormap == "string" && this.addColormapList(n.colormap, c.cal_min, c.cal_max, !1, !1, !0, n.colormapInvert);
        }
        if ("edgeColormap" in n && "edges" in n && n.edges !== void 0) {
          const c = qi(n.edgeMin, n.edgeMax, NaN, NaN);
          this.addColormapList(n.edgeColormapNegative, c[0], c[1], !1, !0, !0, n.colormapInvert), this.addColormapList(n.edgeColormap, n.edgeMin, n.edgeMax, !1, !1, !0, n.colormapInvert);
        }
        if (!(o < 1))
          for (let c = 0; c < o; c++) {
            const h = this.meshes[a].layers[c];
            if (!h.colorbarVisible || h.colormap.length < 1)
              continue;
            const f = h.colormapType !== 0;
            if (h.useNegativeCmap) {
              const d = qi(h.cal_min, h.cal_max, h.cal_minNeg, h.cal_maxNeg);
              this.addColormapList(
                h.colormapNegative,
                d[0],
                d[1],
                f,
                !0,
                // neg
                !0,
                // vis
                h.colormapInvert
              );
            }
            this.addColormapList(
              h.colormap,
              h.cal_min,
              h.cal_max,
              f,
              !1,
              // neg
              !0,
              // vis
              h.colormapInvert
            );
          }
      }
    const i = this.colormapLists.length;
    if (i < 1)
      return;
    this.colormapTexture = this.createColormapTexture(this.colormapTexture, i + 1);
    let s = new Uint8ClampedArray();
    function r(a) {
      const n = new Uint8ClampedArray(s.length + a.length);
      n.set(s), n.set(a, s.length), s = n;
    }
    for (let a = 0; a < i; a++)
      r(Array.from(this.colormap(this.colormapLists[a].name, this.colormapLists[a].invert)));
    return r(Array.from(this.drawLut.lut)), this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, 256, i + 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, s), this;
  }
  /**
   * Calculates volume scaling factors and voxel dimensions for rendering.
   * @internal
   */
  sliceScale(e = !1) {
    var a;
    let t = this.screenFieldOfViewMM(
      0
      /* AXIAL */
    );
    e && (t = this.screenFieldOfViewVox(
      0
      /* AXIAL */
    ));
    const i = Math.max(t[0], Math.max(t[1], t[2])), s = [t[0] / i, t[1] / i, t[2] / i];
    if (!((a = this.back) != null && a.dims))
      throw new Error("back.dims undefined");
    const r = [this.back.dims[1], this.back.dims[2], this.back.dims[3]];
    return { volScale: s, vox: r, longestAxis: i, dimsMM: t };
  }
  /**
   * Returns the index of the tile containing the given (x, y) screen coordinates.
   * Returns -1 if the coordinates are outside all tiles.
   * @internal
   */
  tileIndex(e, t) {
    for (let i = 0; i < this.screenSlices.length; i++) {
      const s = this.screenSlices[i].leftTopWidthHeight;
      if (e > s[0] && t > s[1] && e < s[0] + s[2] && t < s[1] + s[3])
        return i;
    }
    return -1;
  }
  /**
   * Returns the index of the render tile containing (x, y) screen coordinates, or -1 if none.
   * @internal
   */
  inRenderTile(e, t) {
    const i = this.tileIndex(e, t);
    return i >= 0 && this.screenSlices[i].axCorSag === 4 ? i : -1;
  }
  /**
   * Adjusts clip plane depth if active, else zooms render size.
   * @internal
   */
  sliceScroll3D(e = 0) {
    if (e !== 0) {
      if (this.volumes.length > 0 && this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex][0] < 1.8) {
        const t = this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex].slice();
        return e > 0 && (t[0] = Math.min(1.5, t[0] + 0.025)), e < 0 && (t[0] = Math.max(-1.5, t[0] - 0.025)), t[0] !== this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex][0] ? (this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = t, this.setClipPlane(this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex])) : void 0;
      }
      e > 0 && (this.scene.volScaleMultiplier = Math.min(2, this.scene.volScaleMultiplier * 1.1)), e < 0 && (this.scene.volScaleMultiplier = Math.max(0.5, this.scene.volScaleMultiplier * 0.9)), this.drawScene();
    }
  }
  /**
   * Checks if (x,y) is within the visible graph plotting area.
   * @internal
   */
  inGraphTile(e, t) {
    if (this.graph.opacity <= 0 || this.volumes.length < 1 || this.volumes[0].nFrame4D < 1 || !this.graph.plotLTWH || this.graph.plotLTWH[2] < 1 || this.graph.plotLTWH[3] < 1)
      return !1;
    const i = [(e - this.graph.LTWH[0]) / this.graph.LTWH[2], (t - this.graph.LTWH[1]) / this.graph.LTWH[3]];
    return i[0] > 0 && i[1] > 0 && i[0] <= 1 && i[1] <= 1;
  }
  /**
   * Updates drawBitmap to match clickToSegmentGrowingBitmap if they differ in content and size.
   * @internal
   */
  updateBitmapFromClickToSegment() {
    if (this.clickToSegmentGrowingBitmap === null || this.drawBitmap === null || this.clickToSegmentGrowingBitmap.length !== this.drawBitmap.length)
      return;
    const e = this.drawBitmap.length;
    for (let t = 0; t < e; t++)
      this.drawBitmap[t] = this.clickToSegmentGrowingBitmap[t];
  }
  /**
   * Calculates the sum of all voxel values in the given bitmap.
   * @internal
   */
  sumBitmap(e) {
    let t = 0;
    for (let i = 0; i < e.length; i++)
      t += e[i];
    return t;
  }
  /**
   * Performs click-to-segment operation based on user click within a specified tile.
   * Validates input, computes voxel coordinates from screen position, and applies flood fill
   * with intensity-based thresholding and optional growing mask.
   * Updates drawing bitmaps and triggers redraw and descriptive stats calculation.
   * @internal
   */
  doClickToSegment(e) {
    const { tileIndex: t } = e;
    if (t < 0 || t >= this.screenSlices.length) {
      V.warn(`Invalid tileIndex ${t} received in doClickToSegment.`);
      return;
    }
    const i = this.screenSlices[t].axCorSag;
    if (i > 2) {
      V.warn("ClickToSegment attempted on non-2D slice tile.");
      return;
    }
    const s = this.screenXY2TextureFrac(
      this.clickToSegmentXY[0],
      // Use the stored click location
      this.clickToSegmentXY[1],
      t,
      !1
    );
    if (s[0] < 0) {
      V.debug("Click location outside valid texture fraction for the tile.");
      return;
    }
    const r = this.frac2vox(s), a = this.opts.clickToSegmentPercent;
    let n = this.back.getValue(r[0], r[1], r[2]);
    this.opts.clickToSegmentAutoIntensity && (a !== 0 && (n === 0 && (n = 0.01), this.opts.clickToSegmentIntensityMax = n * (1 + a), this.opts.clickToSegmentIntensityMin = n * (1 - a)), n > (this.back.cal_min + this.back.cal_max) * 0.5 ? this.opts.clickToSegmentBright = !0 : this.opts.clickToSegmentBright = !1);
    const o = this.opts.clickToSegmentBright ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    this.drawPenAxCorSag = i;
    const l = this.clickToSegmentIsGrowing ? this.clickToSegmentGrowingBitmap : this.drawBitmap;
    if (!l) {
      if (V.error("Target bitmap for flood fill is null."), this.clickToSegmentIsGrowing) {
        if (this.drawBitmap || this.createEmptyDrawing(), !this.drawBitmap)
          return;
        this.clickToSegmentGrowingBitmap = this.drawBitmap.slice();
      } else if (this.createEmptyDrawing(), !this.drawBitmap)
        return;
      V.warn("Initialized missing bitmap in doClickToSegment.");
    }
    if (this.drawFloodFill(
      [r[0], r[1], r[2]],
      this.opts.penValue,
      o,
      this.opts.clickToSegmentIntensityMin,
      this.opts.clickToSegmentIntensityMax,
      this.opts.floodFillNeighbors,
      this.opts.clickToSegmentMaxDistanceMM,
      this.opts.clickToSegmentIs2D,
      l
    ), !this.clickToSegmentIsGrowing && (V.debug("Applying clickToSegment mask to drawBitmap."), this.drawBitmap ? (this.refreshDrawing(!1, !1), this.drawScene()) : V.error("Cannot refresh drawing after click-to-segment apply, drawBitmap is null."), this.drawBitmap)) {
      const c = this.getDescriptives({
        layer: 0,
        masks: [],
        drawingIsMask: !0
        // Use the final this.drawBitmap
      });
      this.onClickToSegment({ mL: c.volumeML, mm3: c.volumeMM3 });
    }
    this.createOnLocationChange(i);
  }
  /**
   * Handles mouse click on canvas by updating crosshair position, drawing, or segmenting based on current mode and location.
   * Supports thumbnail loading, graph interaction, 3D slice scrolling, and click-to-segment with flood fill.
   * @internal
   */
  mouseClick(e, t, i = 0, s = !0) {
    if (e *= this.uiData.dpr, t *= this.uiData.dpr, this.canvas.focus(), this.thumbnailVisible) {
      this.thumbnailVisible = !1, Promise.all([this.loadVolumes(this.deferredVolumes), this.loadMeshes(this.deferredMeshes)]).catch((r) => {
        throw r;
      });
      return;
    }
    if (this.inGraphTile(e, t)) {
      if (!this.graph.plotLTWH)
        throw new Error("plotLTWH undefined");
      const r = [
        (e - this.graph.plotLTWH[0]) / this.graph.plotLTWH[2],
        (t - this.graph.plotLTWH[1]) / this.graph.plotLTWH[3]
      ];
      if (r[0] > 0 && r[1] > 0 && r[0] <= 1 && r[1] <= 1) {
        const a = Math.round(r[0] * (this.volumes[0].nFrame4D - 1));
        this.setFrame4D(this.volumes[0].id, a);
        return;
      }
      r[0] > 0.5 && r[1] > 1 && this.loadDeferred4DVolumes(this.volumes[0].id).catch((a) => {
        throw a;
      });
      return;
    }
    if (this.inRenderTile(e, t) >= 0) {
      this.sliceScroll3D(i), this.drawScene();
      return;
    }
    if (!(this.screenSlices.length < 1 || this.gl.canvas.height < 1 || this.gl.canvas.width < 1))
      for (let r = 0; r < this.screenSlices.length; r++) {
        const a = this.screenSlices[r].axCorSag;
        if (this.drawPenAxCorSag >= 0 && this.drawPenAxCorSag !== a || a > 2 && !this.opts.clickToSegment && i === 0)
          continue;
        const n = this.screenXY2TextureFrac(e, t, r, !0);
        if (!(n[0] < 0)) {
          if (i !== 0 || !s) {
            if (!s) {
              a <= 2 && (this.scene.crosshairPos[2 - a] = i, this.drawScene(), this.createOnLocationChange(a));
              return;
            }
            const o = i < 0 ? -1 : 1, l = [0, 0, 0];
            a <= 2 && (l[2 - a] = o, this.moveCrosshairInVox(l[0], l[1], l[2]));
            return;
          }
          if (this.opts.isForceMouseClickToVoxelCenters ? this.scene.crosshairPos = Ot(this.vox2frac(this.frac2vox(n))) : this.scene.crosshairPos = Ot(n), this.opts.drawingEnabled) {
            const o = this.frac2vox(this.scene.crosshairPos);
            if (!isFinite(this.opts.penValue) || this.opts.penValue < 0 || Object.is(this.opts.penValue, -0)) {
              let l = 0, c = Math.abs(this.opts.penValue);
              const h = !0;
              Object.is(this.opts.penValue, -0) ? (l = 0, c = 0, V.debug("Erase Cluster selected")) : (l = this.opts.penValue, V.debug("Intensity Grow selected", l)), this.drawFloodFill(
                o,
                c,
                l,
                NaN,
                NaN,
                this.opts.floodFillNeighbors,
                Number.POSITIVE_INFINITY,
                !1,
                this.drawBitmap,
                h
              ), this.drawScene(), this.createOnLocationChange(a);
              return;
            } else if (this.opts.clickToSegment) {
              a <= 2 && (this.clickToSegmentIsGrowing = !1, this.doClickToSegment({
                x: this.clickToSegmentXY[0],
                y: this.clickToSegmentXY[1],
                tileIndex: r
              })), this.createOnLocationChange(a);
              return;
            } else if (this.opts.penType === 0) {
              if (isNaN(this.drawPenLocation[0]))
                this.drawPenAxCorSag = a, this.drawPenFillPts = [], this.drawPt(...o, this.opts.penValue);
              else {
                if (o[0] === this.drawPenLocation[0] && o[1] === this.drawPenLocation[1] && o[2] === this.drawPenLocation[2]) {
                  this.drawScene(), this.createOnLocationChange(a);
                  return;
                }
                this.drawPenLine(o, this.drawPenLocation, this.opts.penValue);
              }
              this.drawPenLocation = o, this.opts.isFilledPen && this.drawPenFillPts.push(o), this.refreshDrawing(!1, !1);
            } else (this.opts.penType === 1 || this.opts.penType === 2) && (isNaN(this.drawShapeStartLocation[0]) ? (this.drawPenAxCorSag = a, this.drawShapeStartLocation = [...o], this.drawBitmap && (this.drawShapePreviewBitmap = this.drawBitmap.slice())) : this.drawShapePreviewBitmap && this.drawBitmap && (this.drawBitmap.set(this.drawShapePreviewBitmap), this.opts.penType === 1 ? this.drawRectangleMask(this.drawShapeStartLocation, o, this.opts.penValue) : this.opts.penType === 2 && this.drawEllipseMask(this.drawShapeStartLocation, o, this.opts.penValue), this.refreshDrawing(!1, !1)));
          }
          this.drawScene(), this.createOnLocationChange(a);
          return;
        }
      }
  }
  /**
   * Draws a 10cm ruler on a 2D slice tile based on screen FOV and slice dimensions.
   * @internal
   */
  drawRuler() {
    let e = [], t = [];
    for (let A = 0; A < this.screenSlices.length; A++)
      if (this.screenSlices[A].axCorSag !== 4 && this.screenSlices[A].fovMM.length > 1) {
        t = this.screenSlices[A].leftTopWidthHeight, e = this.screenSlices[A].fovMM;
        break;
      }
    if (t.length < 4)
      return;
    const [i, s, r, a] = this.getBoundsRegion(), o = 100 / e[0] * t[2], l = Math.max(Math.round(o * 0.1), 2), c = Number(this.opts.rulerWidth), h = Math.floor(t[0] + 0.5 * t[2] - 0.5 * o), f = Math.floor(t[1] + t[3] - l) + 0.5 * c, d = Math.max(i, h), u = Math.min(i + r, h + o), m = Math.min(s + a, f);
    if (u <= d)
      return;
    const g = [d, m, u, m];
    let p = [0, 0, 0, 1];
    this.opts.rulerColor[0] + this.opts.rulerColor[1] + this.opts.rulerColor[2] < 0.8 && (p = [1, 1, 1, 1]), this.drawRuler10cm(g, p, c + 1), this.drawRuler10cm(g, this.opts.rulerColor, c);
  }
  /**
   * Draws a 10cm ruler at specified coordinates with given color and width.
   * @internal
   */
  drawRuler10cm(e, t, i = 1) {
    if (!this.lineShader)
      throw new Error("lineShader undefined");
    this.gl.bindVertexArray(this.genericVAO), this.lineShader.use(this.gl), this.gl.uniform4fv(this.lineShader.uniforms.lineColor, t), this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]), this.gl.uniform1f(this.lineShader.uniforms.thickness, i), this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, e), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    const s = -0.1 * (e[0] - e[2]), r = e[1] - Math.floor(0.5 * this.opts.rulerWidth), a = Math.floor(r - 0.35 * s), n = Math.floor(r - 0.7 * s);
    for (let o = 0; o < 11; o++) {
      let l = e[0] + o * s;
      l = Math.max(l, e[0] + 0.5 * i), l = Math.min(l, e[2] - 0.5 * i);
      const c = [l, r, l, a];
      o % 5 === 0 && (c[3] = n), this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, c), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    this.gl.bindVertexArray(this.unusedVAO);
  }
  /**
   * Returns vec4 with XYZ millimeter coordinates and tile index for given screen XY.
   * @internal
   */
  screenXY2mm(e, t, i = -1) {
    let s;
    for (let r = 0; r < this.screenSlices.length; r++) {
      let a = r;
      if (i >= 0 && (a = i), this.screenSlices[a].axCorSag > 2)
        continue;
      const o = this.screenSlices[a].leftTopWidthHeight;
      if (e < o[0] || t < o[1] || e > o[0] + o[2] || t > o[1] + o[3] || (s = this.screenXY2TextureFrac(e, t, a, !1), s[0] < 0))
        continue;
      const l = this.frac2mm(s);
      return ht(l[0], l[1], l[2], a);
    }
    return ht(NaN, NaN, NaN, NaN);
  }
  /**
   * Update scene pan position during drag based on start and end screen coordinates.
   * @internal
   */
  dragForPanZoom(e) {
    const t = this.screenXY2mm(e[2], e[3]);
    if (isNaN(t[0]))
      return;
    const i = this.screenXY2mm(e[0], e[1], t[3]);
    if (isNaN(i[0]) || isNaN(t[0]) || isNaN(t[3]))
      return;
    const s = Wt(), r = this.uiData.pan2DxyzmmAtMouseDown[3];
    _n(s, t, i), this.scene.pan2Dxyzmm[0] = this.uiData.pan2DxyzmmAtMouseDown[0] + r * s[0], this.scene.pan2Dxyzmm[1] = this.uiData.pan2DxyzmmAtMouseDown[1] + r * s[1], this.scene.pan2Dxyzmm[2] = this.uiData.pan2DxyzmmAtMouseDown[2] + r * s[2], this.canvas.focus();
  }
  /**
   * Handle center-button drag as pan and zoom.
   * @internal
   */
  dragForCenterButton(e) {
    this.dragForPanZoom(e);
  }
  /**
   * Update 3D slicer zoom and pan based on drag movement.
   * @internal
   */
  dragForSlicer3D(e) {
    let t = this.uiData.pan2DxyzmmAtMouseDown[3];
    const i = e[3] - e[1];
    t += i * 0.01, t = Math.max(t, 0.1), t = Math.min(t, 10);
    const r = this.scene.pan2Dxyzmm[3] - t;
    this.opts.yoke3Dto2DZoom && (this.scene.volScaleMultiplier = t), this.scene.pan2Dxyzmm[3] = t;
    const a = this.frac2mm(this.scene.crosshairPos);
    this.scene.pan2Dxyzmm[0] += r * a[0], this.scene.pan2Dxyzmm[1] += r * a[1], this.scene.pan2Dxyzmm[2] += r * a[2];
  }
  /**
   * Draw a measurement line with end caps and length text on a 2D tile.
   * @internal
   */
  drawMeasurementTool(e, t = !0) {
    function i(c, h, f, d, u) {
      const m = c - f, g = h - d;
      if (m === 0 && g === 0)
        return {
          origin: [f + u, d],
          terminus: [f + u, d]
        };
      const p = Math.sqrt(m * m + g * g), A = u * m / p, x = u * g / p;
      return {
        origin: [c + A, h + x],
        // next to start point
        terminus: [f - A, d - x]
      };
    }
    const s = this.gl;
    if (s.viewport(0, 0, s.canvas.width, s.canvas.height), s.bindVertexArray(this.genericVAO), s.depthFunc(s.ALWAYS), s.enable(s.BLEND), s.blendFunc(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA), !this.lineShader)
      throw new Error("lineShader undefined");
    this.lineShader.use(this.gl), s.uniform4fv(this.lineShader.uniforms.lineColor, this.opts.rulerColor), s.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [s.canvas.width, s.canvas.height]), s.uniform1f(this.lineShader.uniforms.thickness, this.opts.rulerWidth), s.uniform4fv(this.lineShader.uniforms.startXYendXY, e), s.drawArrays(s.TRIANGLE_STRIP, 0, 4);
    const r = this.opts.measureLineColor;
    r[3] = 1, s.uniform4fv(this.lineShader.uniforms.lineColor, r);
    const a = this.opts.rulerWidth;
    s.uniform1f(this.lineShader.uniforms.thickness, a * 2);
    let n = [e[0], e[1] - a, e[0], e[1] + a];
    s.uniform4fv(this.lineShader.uniforms.startXYendXY, n), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), n = [e[2], e[3] - a, e[2], e[3] + a], s.uniform4fv(this.lineShader.uniforms.startXYendXY, n), s.drawArrays(s.TRIANGLE_STRIP, 0, 4);
    let o = this.canvasPos2frac([e[0], e[1]]), l = this.canvasPos2frac([e[2], e[3]]);
    if (o[0] >= 0 && l[0] >= 0) {
      const c = this.frac2mm(o);
      o = O(c[0], c[1], c[2]);
      const h = this.frac2mm(l);
      l = O(h[0], h[1], h[2]);
      const f = nt();
      Os(f, o, l);
      const d = Le(f);
      let u = 2;
      d > 9 && (u = 1), d > 99 && (u = 0);
      let m = d.toFixed(u);
      this.opts.showMeasureUnits && (m = `${m} mm`);
      let g = e;
      const [p, A, x, w] = e, { origin: v, terminus: F } = i(p, A, x, w, 30);
      switch (this.opts.measureTextJustify) {
        case "start":
          g = [...v, ...v.map((C) => C + 1)];
          break;
        case "end":
          g = g = [...F, ...F.map((C) => C + 1)];
          break;
        default:
          g = e;
          break;
      }
      t && this.drawTextBetween(
        g,
        m,
        this.opts.measureTextHeight / 0.06,
        // <- TODO measureFontPx
        this.opts.measureTextColor
      );
    }
    s.bindVertexArray(this.unusedVAO);
  }
  /**
   * Draw angle measurement tool with two lines and angle display.
   * @internal
   */
  drawAngleMeasurementTool() {
    this.uiData.angleState === "drawing_first_line" ? this.drawMeasurementTool(
      [this.uiData.dragStart[0], this.uiData.dragStart[1], this.uiData.dragEnd[0], this.uiData.dragEnd[1]],
      !1
    ) : this.uiData.angleState === "drawing_second_line" && (this.drawMeasurementTool(this.uiData.angleFirstLine, !1), this.drawMeasurementTool(
      [
        this.uiData.angleFirstLine[2],
        // start from end of first line
        this.uiData.angleFirstLine[3],
        this.uiData.dragEnd[0],
        // to current mouse position
        this.uiData.dragEnd[1]
      ],
      !1
    ), this.drawAngleText());
  }
  /**
   * Calculate and draw angle text at the intersection of two lines.
   * @internal
   */
  drawAngleText() {
    const e = this.uiData.angleFirstLine, t = [
      this.uiData.angleFirstLine[2],
      // start from end of first line
      this.uiData.angleFirstLine[3],
      this.uiData.dragEnd[0],
      // to current mouse position
      this.uiData.dragEnd[1]
    ], i = this.calculateAngleBetweenLines(e, t), s = this.uiData.angleFirstLine[2], r = this.uiData.angleFirstLine[3], a = `${i.toFixed(1)}`;
    this.drawTextBetween(
      [s, r, s + 1, r + 1],
      a,
      this.opts.measureTextHeight / 0.06,
      this.opts.measureTextColor
    );
  }
  /**
   * Calculate and draw angle text for a completed angle.
   * @internal
   */
  drawAngleTextForAngle(e) {
    const t = this.calculateAngleBetweenLines(e.firstLine, e.secondLine), i = e.firstLine[2], s = e.firstLine[3], r = `${t.toFixed(1)}`;
    this.drawTextBetween(
      [i, s, i + 1, s + 1],
      r,
      this.opts.measureTextHeight / 0.06,
      this.opts.measureTextColor
    );
  }
  /**
   * Calculate angle between two lines in degrees.
   * @internal
   */
  calculateAngleBetweenLines(e, t) {
    const i = e[2], s = e[3], r = e[0] - i, a = e[1] - s, n = t[2] - i, o = t[3] - s, l = r * n + a * o, c = Math.sqrt(r * r + a * a), h = Math.sqrt(n * n + o * o);
    if (c === 0 || h === 0)
      return 0;
    const f = Math.max(-1, Math.min(1, l / (c * h)));
    return Math.acos(f) * (180 / Math.PI);
  }
  /**
   * Reset the angle measurement state.
   * @internal
   */
  resetAngleMeasurement() {
    this.uiData.angleState = "none", this.uiData.angleFirstLine = [0, 0, 0, 0];
  }
  /**
   * Get slice information for the current measurement/angle.
   * @internal
   */
  getCurrentSliceInfo() {
    const e = this.tileIndex(this.uiData.dragStart[0], this.uiData.dragStart[1]);
    if (e >= 0 && e < this.screenSlices.length) {
      const s = this.screenSlices[e].axCorSag;
      let r = 0;
      return s === 0 ? r = this.scene.crosshairPos[2] : s === 1 ? r = this.scene.crosshairPos[1] : s === 2 && (r = this.scene.crosshairPos[0]), {
        sliceIndex: e,
        sliceType: s,
        slicePosition: r
      };
    }
    const t = this.opts.sliceType;
    let i = 0;
    return t === 0 ? i = this.scene.crosshairPos[2] : t === 1 ? i = this.scene.crosshairPos[1] : t === 2 ? i = this.scene.crosshairPos[0] : t === 3 && this.canvasPos2frac([this.uiData.dragStart[0], this.uiData.dragStart[1]])[0] >= 0 && (i = this.scene.crosshairPos[2]), { sliceIndex: -1, sliceType: t, slicePosition: i };
  }
  /**
   * Get the current slice position based on slice type.
   * @internal
   */
  getCurrentSlicePosition(e) {
    return e === 0 ? this.scene.crosshairPos[2] : e === 1 ? this.scene.crosshairPos[1] : e === 2 ? this.scene.crosshairPos[0] : 0;
  }
  /**
   * Check if a measurement/angle should be drawn on the current slice.
   * @internal
   */
  shouldDrawOnCurrentSlice(e, t, i) {
    if (this.opts.sliceType === 3) {
      if (t > 2)
        return !1;
      for (let o = 0; o < this.screenSlices.length; o++)
        if (this.screenSlices[o].axCorSag === t) {
          const l = this.getCurrentSlicePosition(t);
          if (Math.abs(l - i) < 1e-3)
            return !0;
        }
      return !1;
    } else if (this.opts.sliceType !== t)
      return !1;
    const s = this.getCurrentSlicePosition(t);
    return Math.abs(s - i) < 1e-3;
  }
  /**
   * Clear all persistent measurement lines from the canvas.
   * @example
   * ```js
   * nv.clearMeasurements()
   * ```
   */
  clearMeasurements() {
    this.document.completedMeasurements = [], this.drawScene();
  }
  /**
   * Clear all persistent angle measurements from the canvas.
   * @example
   * ```js
   * nv.clearAngles()
   * ```
   */
  clearAngles() {
    this.document.completedAngles = [], this.drawScene();
  }
  /**
   * Clear all persistent measurements and angles from the canvas.
   * @example
   * ```js
   * nv.clearAllMeasurements()
   * ```
   */
  clearAllMeasurements() {
    this.document.completedMeasurements = [], this.document.completedAngles = [], this.drawScene();
  }
  /**
   * Set the drag mode for mouse interactions.
   * @param mode - The drag mode to set ('none', 'contrast', 'measurement', 'angle', 'pan', 'slicer3D', 'callbackOnly', 'roiSelection')
   */
  setDragMode(e) {
    if (typeof e == "string")
      switch (e) {
        case "none":
          this.opts.dragMode = 0;
          break;
        case "contrast":
          this.opts.dragMode = 1;
          break;
        case "measurement":
          this.opts.dragMode = 2;
          break;
        case "angle":
          this.opts.dragMode = 7;
          break;
        case "pan":
          this.opts.dragMode = 3;
          break;
        case "slicer3D":
          this.opts.dragMode = 4;
          break;
        case "callbackOnly":
          this.opts.dragMode = 5;
          break;
        case "roiSelection":
          this.opts.dragMode = 6;
          break;
        default:
          console.warn(`Unknown drag mode: ${e}`);
          return;
      }
    else
      this.opts.dragMode = e;
    this.opts.dragMode !== 7 && this.resetAngleMeasurement(), this.clearActiveDragMode();
  }
  /**
   * Set custom mouse event configuration for button mappings.
   * @param config - Mouse event configuration object
   * @example
   * ```js
   * nv.setMouseEventConfig({
   *   leftButton: {
   *     primary: DRAG_MODE.windowing,
   *     withShift: DRAG_MODE.measurement,
   *     withCtrl: DRAG_MODE.crosshair
   *   },
   *   rightButton: DRAG_MODE.crosshair,
   *   centerButton: DRAG_MODE.pan
   * })
   * ```
   */
  setMouseEventConfig(e) {
    this.opts.mouseEventConfig = e, this.clearActiveDragMode();
  }
  /**
   * Set custom touch event configuration for touch gesture mappings.
   * @param config - Touch event configuration object
   * @example
   * ```js
   * nv.setTouchEventConfig({
   *   singleTouch: DRAG_MODE.windowing,
   *   doubleTouch: DRAG_MODE.pan
   * })
   * ```
   */
  setTouchEventConfig(e) {
    this.opts.touchEventConfig = e, this.clearActiveDragMode();
  }
  /**
   * Get current mouse event configuration.
   * @returns Current mouse event configuration or undefined if using defaults
   */
  getMouseEventConfig() {
    return this.opts.mouseEventConfig;
  }
  /**
   * Get current touch event configuration.
   * @returns Current touch event configuration or undefined if using defaults
   */
  getTouchEventConfig() {
    return this.opts.touchEventConfig;
  }
  /**
   * Draw a rectangle or outline at given position with specified color or default crosshair color.
   * @internal
   */
  drawRect(e, t = [1, 0, 0, -1]) {
    if (t[3] < 0 && (t = this.opts.crosshairColor), !this.rectShader)
      throw new Error("rectShader undefined");
    this.gl.disable(this.gl.CULL_FACE), this.opts.selectionBoxIsOutline ? (this.drawCircle(e, t, 0.1), this.rectOutlineShader.use(this.gl), this.gl.enable(this.gl.BLEND), this.gl.uniform1f(this.rectOutlineShader.uniforms.thickness, this.opts.selectionBoxLineThickness), this.gl.uniform4fv(this.rectOutlineShader.uniforms.lineColor, t), this.gl.uniform2fv(this.rectOutlineShader.uniforms.canvasWidthHeight, [
      this.gl.canvas.width,
      this.gl.canvas.height
    ]), this.gl.uniform4f(
      this.rectOutlineShader.uniforms.leftTopWidthHeight,
      e[0],
      e[1],
      e[2],
      e[3]
    ), this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO)) : (this.rectShader.use(this.gl), this.gl.enable(this.gl.BLEND), this.gl.uniform4fv(this.rectShader.uniforms.lineColor, t), this.gl.uniform2fv(this.rectShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]), this.gl.uniform4f(
      this.rectShader.uniforms.leftTopWidthHeight,
      e[0],
      e[1],
      e[2],
      e[3]
    ), this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO));
  }
  drawBoundsBox(e, t, i = 2) {
    if (!this.rectOutlineShader)
      throw new Error("rectOutlineShader undefined");
    const s = this.gl, [r, a, n, o] = e;
    s.viewport(0, 0, s.canvas.width, s.canvas.height), this.rectOutlineShader.use(s), s.enable(s.BLEND), s.uniform1f(this.rectOutlineShader.uniforms.thickness, i), s.uniform4fv(this.rectOutlineShader.uniforms.lineColor, t), s.uniform2fv(this.rectOutlineShader.uniforms.canvasWidthHeight, [s.canvas.width, s.canvas.height]), s.uniform4f(this.rectOutlineShader.uniforms.leftTopWidthHeight, r, a, n, o), s.bindVertexArray(this.genericVAO), s.drawArrays(s.TRIANGLE_STRIP, 0, 4), s.bindVertexArray(this.unusedVAO);
  }
  /**
   * Draw a circle or outline at given position with specified color or default crosshair color.
   * @internal
   */
  drawCircle(e, t = this.opts.fontColor, i = 1) {
    if (!this.circleShader)
      throw new Error("circleShader undefined");
    this.circleShader.use(this.gl), this.gl.enable(this.gl.BLEND), this.gl.uniform4fv(this.circleShader.uniforms.circleColor, t), this.gl.uniform2fv(this.circleShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]), this.gl.uniform4f(
      this.circleShader.uniforms.leftTopWidthHeight,
      e[0],
      e[1],
      e[2],
      e[3]
    ), this.gl.uniform1f(this.circleShader.uniforms.fillPercent, i), this.gl.uniform4fv(this.circleShader.uniforms.circleColor, t), this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO);
  }
  /**
   * Draw selection box: circle if ROI selection mode, else rectangle.
   * @internal
   */
  drawSelectionBox(e) {
    if (this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.getCurrentDragMode() === 6) {
      this.drawCircle(e, this.opts.selectionBoxColor, 0.1);
      return;
    }
    this.drawRect(e, this.opts.selectionBoxColor);
  }
  /**
   * Get canvas height available for tiles (excludes colorbar).
   * @internal
   */
  effectiveCanvasHeight() {
    let e = this.gl.canvas.height;
    if (this.opts.bounds) {
      const [[, t], [, i]] = this.opts.bounds, s = Math.round(t * this.gl.canvas.height);
      e = Math.round(i * this.gl.canvas.height) - s;
    }
    return e - this.colorbarHeight;
  }
  /**
   * Get canvas width available for tiles (excludes legend panel).
   * @internal
   */
  effectiveCanvasWidth() {
    let e = this.gl.canvas.width;
    if (this.opts.bounds) {
      const [[t], [i]] = this.opts.bounds;
      e = Math.round((i - t) * this.gl.canvas.width);
    }
    return e - this.getLegendPanelWidth();
  }
  /**
   * Get all 3D labels from document and connectome meshes.
   * @internal
   */
  getAllLabels() {
    const s = this.meshes.filter(
      (a) => a.type === "connectome"
      /* CONNECTOME */
    ).flatMap((a) => a.nodes).map((a) => a.label).filter((a) => a !== void 0);
    return [...this.document.labels, ...s];
  }
  /**
   * Get all visible connectome and non-anchored mesh labels.
   * @internal
   */
  getConnectomeLabels() {
    const s = this.meshes.filter((o) => o.type === "connectome" && o.showLegend !== !1).flatMap((o) => o.nodes).map((o) => o.label).filter((o) => o !== void 0 && o.text !== ""), r = this.document.labels.filter(
      (o) => o.anchor == null || o.anchor === 0
      /* NONE */
    ), a = new Set(s);
    for (const o of r)
      a.add(o);
    const n = this.meshes.filter(
      (o) => o.type === "mesh"
      /* MESH */
    );
    for (let o = 0; o < n.length; o++)
      for (let l = 0; l < n[o].layers.length; l++)
        if (n[o].layers[l].labels)
          for (let c = 0; c < n[o].layers[l].labels.length; c++)
            a.add(n[o].layers[l].labels[c]);
    return Array.from(a);
  }
  /**
   * Calculate bullet margin width based on widest bullet scale and tallest label height.
   * @internal
   */
  getBulletMarginWidth() {
    let e = 0;
    const t = this.getConnectomeLabels();
    if (t.length === 0)
      return 0;
    const i = t.length === 1 ? t[0].style.bulletScale : t.reduce((a, n) => a.style.bulletScale > n.style.bulletScale ? a : n).style.bulletScale, s = t.length === 1 ? t[0] : t.reduce((a, n) => {
      const o = this.fontPx * a.style.textScale, l = this.fontPx * n.style.textScale;
      return this.textHeight(o, a.text) > this.textHeight(l, n.text) ? a : n;
    }), r = this.fontPx * s.style.textScale;
    return e = this.textHeight(r, s.text) * i, e += r, e;
  }
  /**
   * Calculate width of legend panel based on labels and bullet margin.
   * Returns 0 if legend is hidden or too wide for canvas.
   * @internal
   */
  getLegendPanelWidth() {
    const e = this.getConnectomeLabels();
    if (!this.opts.showLegend || e.length === 0)
      return 0;
    const i = this.fontPx * 1;
    let s = 0;
    const r = e.reduce((l, c) => {
      const h = this.fontPx * l.style.textScale, f = this.fontPx * c.style.textScale;
      return this.textWidth(h, l.text) > this.textWidth(f, c.text) ? l : c;
    }), a = this.fontPx * r.style.textScale, n = this.textWidth(a, r.text), o = this.getBulletMarginWidth();
    return n && (s = o + n, s += i * 2), s >= this.gl.canvas.width ? 0 : s;
  }
  /**
   * Calculate legend panel height based on labels and scale.
   * @internal
   */
  getLegendPanelHeight(e = 1) {
    const t = this.getConnectomeLabels();
    let i = 0;
    const s = this.fontPx;
    for (const r of t) {
      const a = this.fontPx * r.style.textScale * e, n = this.textHeight(a, r.text);
      i += n;
    }
    return i && (i += s / 2 * (t.length + 1) * e), i;
  }
  /**
   * Calculate and reserve canvas area for colorbar panel,
   * respecting opts.bounds if defined.
   * @internal
   */
  reserveColorbarPanel() {
    const e = 3 * this.fontPx;
    if (e < 0)
      return [0, 0, 0, 0];
    const [t, i, s, r] = this.getBoundsRegion(), n = (this.opts.colorbarWidth > 0 && this.opts.colorbarWidth <= 1 ? this.opts.colorbarWidth : 1) * s, o = [
      t + (s - n) / 2,
      // center within region
      i + r - e,
      // top within region
      n,
      e
    ];
    return this.colorbarHeight = o[3] + 1, o;
  }
  /**
   * Render a single colorbar with optional negative coloring and alpha threshold ticks.
   * @internal
   */
  drawColorbarCore(e = 0, t = [0, 0, 0, 0], i = !1, s = 0, r = 1, a) {
    if (t[2] <= 0 || t[3] <= 0)
      return;
    const n = this.fontPx;
    if (n <= 0)
      return;
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    let o = n;
    const l = 3 * n;
    let c = n;
    if (t[3] < l) {
      if (t[3] < 3)
        return;
      o = 1, c = t[3] - 2;
    }
    this.gl.disable(this.gl.DEPTH_TEST), this.colorbarHeight = t[3] + 1;
    const h = [t[0] + o, t[1], t[2] - 2 * o, c], f = [h[0] - 1, h[1] - 1, h[2] + 2, h[3] + 2];
    if (this.opts.showColorbarBorder && this.drawRect(f, this.opts.crosshairColor), !this.colorbarShader)
      throw new Error("colorbarShader undefined");
    this.colorbarShader.use(this.gl), this.gl.activeTexture(Se), this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    const d = e;
    if (this.gl.uniform1f(this.colorbarShader.uniforms.layer, d), this.gl.uniform2fv(this.colorbarShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]), this.gl.disable(this.gl.CULL_FACE), i) {
      const C = [h[0] + h[2], h[1], -h[2], h[3]];
      this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight, C);
    } else
      this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight, h);
    this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    let u = 0;
    if (a && r < 0 && i ? (u = r, r = 0) : a && s > 0 && (u = s, s = 0), s === r || n < 1)
      return;
    const m = Math.abs(r - s);
    let [g, p] = Ar(s, r);
    p < s && (p += g);
    function A(C) {
      return C.toFixed(6).replace(/\.?0*$/, "");
    }
    let x = p;
    const w = [0, h[1] + h[3] - n * 0.5, 2, n * 0.75], v = w[1] + w[3], F = 1;
    for (; x <= r; ) {
      w[0] = h[0] + (x - s) / m * h[2], this.drawRect(w);
      const C = A(F * x);
      this.drawTextBelow([w[0], v], C), x += g;
    }
    if (u !== 0) {
      const C = [
        h[0] + (u - s) / m * h[2],
        h[1] - h[3] * 0.25,
        2,
        h[3] * 1.5
      ];
      this.drawRect(C);
    }
  }
  /**
   * Draw all visible colorbars side by side in the reserved colorbar panel area.
   * @internal
   */
  drawColorbar() {
    const e = this.colormapLists, t = e.length;
    if (t < 1)
      return;
    let i = 0;
    for (let n = 0; n < t; n++)
      e[n].visible && i++;
    if (i < 1)
      return;
    let s = this.reserveColorbarPanel();
    const r = 3 * this.fontPx;
    if (r < 0)
      return;
    let a = s[2] / i;
    (s[2] <= 0 || s[3] <= 0) && (a = this.gl.canvas.width / i, s = [0, this.gl.canvas.height - r, a, r]), s[2] = a;
    for (let n = 0; n < t; n++)
      e[n].visible && (this.drawColorbarCore(
        n,
        s,
        e[n].negative,
        e[n].min,
        e[n].max,
        e[n].isColorbarFromZero
      ), s[0] += a);
  }
  /**
   * Calculate pixel width of text string based on glyph advances at given scale.
   * @internal
   */
  textWidth(e, t) {
    if (!t)
      return 0;
    let i = 0;
    const s = new TextEncoder().encode(t);
    for (let r = 0; r < t.length; r++)
      i += e * this.fontMets.mets[s[r]].xadv;
    return i;
  }
  /**
   * Calculate pixel height of text based on tallest glyph at given scale.
   * @internal
   */
  textHeight(e, t) {
    if (!t)
      return 0;
    const i = new Set(Array.from(t)), s = new TextEncoder().encode(Array.from(i).join("")), a = Object.values(this.fontMets.mets).filter((n, o) => s.includes(o)).reduce((n, o) => n.lbwh[3] > o.lbwh[3] ? n : o).lbwh[3];
    return e * a;
  }
  /**
   * Render a single character glyph at specified position and scale; returns advance width.
   * @internal
   */
  drawChar(e, t, i) {
    if (!this.fontShader)
      throw new Error("fontShader undefined");
    const s = this.fontMets.mets[i], r = e[0] + t * s.lbwh[0], a = -(t * s.lbwh[1]), n = t * s.lbwh[2], o = t * s.lbwh[3], l = e[1] + (a - o) + t;
    return this.gl.uniform4f(this.fontShader.uniforms.leftTopWidthHeight, r, l, n, o), this.gl.uniform4fv(this.fontShader.uniforms.uvLeftTopWidthHeight, s.uv_lbwh), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), t * s.xadv;
  }
  /**
   * Render loading text centered on the canvas.
   * @internal
   */
  drawLoadingText(e) {
    if (!e)
      return;
    if (!this.canvas)
      throw new Error("canvas undefined");
    const [t, i, s, r] = this.getBoundsRegion();
    this.gl.viewport(t, i, s, r), this.gl.enable(this.gl.CULL_FACE), this.gl.enable(this.gl.BLEND);
    const a = t + s / 2, n = i + r / 2;
    this.drawTextBelow([a, n], e, 3);
  }
  /**
   * Render a string of text at specified canvas coordinates with scaling and optional color.
   * @internal
   */
  drawText(e, t, i = 1, s = null) {
    if (this.fontPx <= 0)
      return;
    if (!this.fontShader)
      throw new Error("fontShader undefined");
    this.fontShader.use(this.gl);
    const r = this.fontPx * i;
    this.gl.enable(this.gl.BLEND), this.gl.uniform2f(this.fontShader.uniforms.canvasWidthHeight, this.gl.canvas.width, this.gl.canvas.height), s === null && (s = this.opts.fontColor), this.gl.uniform4fv(this.fontShader.uniforms.fontColor, s);
    let a = r / this.fontMets.size * this.fontMets.distanceRange;
    a = Math.max(a, 1), this.gl.uniform1f(this.fontShader.uniforms.screenPxRange, a);
    const n = new TextEncoder().encode(t);
    this.gl.bindVertexArray(this.genericVAO);
    for (let o = 0; o < t.length; o++)
      e[0] += this.drawChar(e, r, n[o]);
    this.gl.bindVertexArray(this.unusedVAO);
  }
  /**
   * Draw text right-aligned to the given coordinates, vertically centered on y.
   * @internal
   */
  drawTextRight(e, t, i = 1, s = null) {
    this.fontPx <= 0 || (e[1] -= 0.5 * this.fontPx, this.drawText(e, t, i, s));
  }
  /**
   * Draw text left-aligned to the given coordinates, vertically centered on y.
   * @internal
   */
  drawTextLeft(e, t, i = 1, s = null) {
    if (this.fontPx <= 0)
      return;
    const r = this.fontPx * i;
    e[0] -= this.textWidth(r, t), e[1] -= 0.5 * r, this.drawText(e, t, i, s);
  }
  /**
   * Draw text right-aligned and below the given coordinates.
   * @internal
   */
  drawTextRightBelow(e, t, i = 1, s = null) {
    this.fontPx <= 0 || this.drawText(e, t, i, s);
  }
  /**
   * Draw text horizontally centered between start and end points with a semi-transparent background.
   * @internal
   */
  drawTextBetween(e, t, i = 1, s = null) {
    if (this.fontPx <= 0)
      return;
    const r = [(e[0] + e[2]) * 0.5, (e[1] + e[3]) * 0.5], a = this.fontPx * i, n = this.textWidth(a, t);
    r[0] -= 0.5 * n, r[1] -= 0.5 * a;
    const o = [r[0] - 1, r[1] - 1, n + 2, a + 2];
    let l = s;
    l === null && (l = this.opts.crosshairColor), l && l[0] + l[1] + l[2] > 0.8 ? l = [0, 0, 0, 0.5] : l = [1, 1, 1, 0.5], this.drawRect(o, l), this.drawText(r, t, i, s);
  }
  /**
   * Draw text horizontally centered below a specified (x,y) position with canvas boundary clamping.
   * @internal
   */
  drawTextBelow(e, t, i = 1, s = null) {
    if (this.fontPx <= 0)
      return;
    if (!this.canvas)
      throw new Error("canvas undefined");
    let r = this.fontPx * i, a = this.textWidth(r, t);
    a > this.canvas.width && (i *= (this.canvas.width - 2) / a, r = this.fontPx * i, a = this.textWidth(r, t)), e[0] -= 0.5 * this.textWidth(r, t), e[0] = Math.max(e[0], 1), e[0] = Math.min(e[0], this.canvas.width - a - 1), this.drawText(e, t, i, s);
  }
  /**
   * Draw text horizontally centered above the given coordinates.
   * @internal
   */
  drawTextAbove(e, t, i = 1, s = null) {
    if (this.fontPx <= 0)
      return;
    if (!this.canvas)
      throw new Error("canvas undefined");
    let r = this.fontPx * i, a = this.textWidth(r, t);
    a > this.canvas.width && (i *= (this.canvas.width - 2) / a, r = this.fontPx * i, a = this.textWidth(r, t)), e[0] -= 0.5 * this.textWidth(r, t), e[0] = Math.max(e[0], 1), e[0] = Math.min(e[0], this.canvas.width - a - 1), e[1] -= r, this.drawText(e, t, i, s);
  }
  /**
   * Update texture interpolation mode (nearest or linear) for background or overlay layer.
   * @internal
   */
  updateInterpolation(e, t = !1) {
    let i = this.gl.LINEAR;
    !t && this.opts.isNearestInterpolation && (i = this.gl.NEAREST), e === 0 ? this.gl.activeTexture(ie) : this.gl.activeTexture(fi), this.opts.is2DSliceShader ? (this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, i), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, i)) : (this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, i), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, i));
  }
  /**
   * Enable or disable atlas outline overlay
   * @param isOutline - number 0 to 1 for outline opacity
   * @see {@link https://niivue.com/demos/features/atlas.sparse.html | live demo usage}
   */
  setAtlasOutline(e) {
    this.opts.atlasOutline = e, this.updateGLVolume(), this.drawScene();
  }
  /**
   * select between nearest and linear interpolation for voxel based images
   * @param isNearest - whether nearest neighbor interpolation is used, else linear interpolation
   * @example niivue.setInterpolation(true);
   * @see {@link https://niivue.com/demos/features/draw2.html | live demo usage}
   */
  setInterpolation(e) {
    this.opts.isNearestInterpolation = e;
    const t = this.volumes.length;
    if (!(t < 1)) {
      for (let i = 0; i < t; i++)
        this.updateInterpolation(i);
      this.drawScene();
    }
  }
  /**
   * Computes 2D model-view-projection and related matrices for rendering a slice of a 3D volume.
   * Configures viewport and accounts for radiological orientation, depth clipping, and camera rotation.
   * @internal
   */
  calculateMvpMatrix2D(e, t, i, s = 1 / 0, r = 0, a = 0, n = 0, o = !1) {
    this.gl.viewport(
      e[0],
      this.gl.canvas.height - (e[1] + e[3]),
      // lower numbers near bottom
      e[2],
      e[3]
    );
    let c = t[0], h = i[0], f = [c, t[1]], d = [h - c, i[1] - t[1]];
    o && (f = [i[0], t[1]], d = [t[0] - i[0], i[1] - t[1]], c = -i[0], h = -t[0]);
    const u = 2 * Math.max(Math.abs(t[2]), Math.abs(i[2])), m = it();
    let g = 0.01, p = u * 8;
    if (s !== 1 / 0) {
      let C = o;
      n === 0 && (a === 0 || a === 180) && (C = !C);
      let b = u * 1.8 - r;
      C || (b = u * 1.8 + r), p = b - s, g = b + s;
    }
    si(m, c, h, t[1], i[1], p, g);
    const A = it();
    A[0] = -1;
    const x = O(0, 0, -u * 1.8);
    me(A, A, x), ei(A, A, Xt(270 - n)), ii(A, A, Xt(a - 180));
    const w = it();
    Vt(w, A);
    const v = it();
    Ut(v, w);
    const F = it();
    return re(F, m, A), {
      modelViewProjectionMatrix: F,
      modelMatrix: A,
      normalMatrix: v,
      leftTopMM: f,
      fovMM: d
    };
  }
  /**
   * Reorders the components of a 3D vector based on the slice orientation (axial, coronal, or sagittal).
   * @internal
   */
  swizzleVec3MM(e, t) {
    return t === 1 ? e = dt(e, [0, 2, 1]) : t === 2 && (e = dt(e, [1, 2, 0])), e;
  }
  /**
   * Returns the swizzled field of view for the given slice orientation.
   * @internal
   */
  screenFieldOfViewVox(e = 0) {
    const t = Ot(this.volumeObject3D.fieldOfViewDeObliqueMM);
    return this.swizzleVec3MM(t, e);
  }
  /**
   * Returns the field of view in millimeters for the given slice orientation.
   * @internal
   */
  screenFieldOfViewMM(e = 0, t = !1) {
    if (this.volumes.length < 1) {
      let o = O(this.extentsMin[0], this.extentsMin[1], this.extentsMin[2]), l = O(this.extentsMax[0], this.extentsMax[1], this.extentsMax[2]);
      o = this.swizzleVec3MM(o, e), l = this.swizzleVec3MM(l, e);
      const c = nt();
      return ot(c, l, o), c;
    }
    if (!t && !this.opts.isSliceMM)
      return this.screenFieldOfViewVox(e);
    const i = this.volumeObject3D.extentsMin, s = this.volumeObject3D.extentsMax;
    let r = O(i[0], i[1], i[2]), a = O(s[0], s[1], s[2]);
    r = this.swizzleVec3MM(r, e), a = this.swizzleVec3MM(a, e);
    const n = nt();
    return ot(n, a, r), n;
  }
  /**
   * Returns extended voxel-aligned field of view and bounds for the given slice orientation.
   * @internal
   */
  screenFieldOfViewExtendedVox(e = 0) {
    const t = this.volumes[0].extentsMinOrtho, i = this.volumes[0].extentsMaxOrtho;
    let s = O(t[0], t[1], t[2]), r = O(i[0], i[1], i[2]);
    const a = it();
    s = this.swizzleVec3MM(s, e), r = this.swizzleVec3MM(r, e);
    const n = nt();
    return ot(n, r, s), { mnMM: s, mxMM: r, rotation: a, fovMM: n };
  }
  /**
   * Returns extended millimeter-aligned field of view and bounds for the given slice orientation.
   * @internal
   */
  screenFieldOfViewExtendedMM(e = 0) {
    if (this.volumes.length < 1) {
      let o = O(this.extentsMin[0], this.extentsMin[1], this.extentsMin[2]), l = O(this.extentsMax[0], this.extentsMax[1], this.extentsMax[2]);
      const c = it();
      o = this.swizzleVec3MM(o, e), l = this.swizzleVec3MM(l, e);
      const h = nt();
      return ot(h, l, o), { mnMM: o, mxMM: l, rotation: c, fovMM: h };
    }
    if (!this.volumeObject3D)
      throw new Error("volumeObject3D undefined");
    const t = this.volumeObject3D.extentsMin, i = this.volumeObject3D.extentsMax;
    let s = O(t[0], t[1], t[2]), r = O(i[0], i[1], i[2]);
    const a = it();
    s = this.swizzleVec3MM(s, e), r = this.swizzleVec3MM(r, e);
    const n = nt();
    return ot(n, r, s), { mnMM: s, mxMM: r, rotation: a, fovMM: n };
  }
  /**
   * Draws anatomical orientation labels (e.g., A/P/L/R) for the given slice view.
   * @internal
   */
  drawSliceOrientationText(e, t, i = [NaN, NaN]) {
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    let s = "S";
    t === 0 && (s = "A");
    let r = this.opts.isRadiologicalConvention ? "R" : "L";
    t === 2 && (r = this.opts.sagittalNoseLeft ? "A" : "P");
    let a = "I";
    t === 0 && (a = "P");
    let n = this.opts.isRadiologicalConvention ? "L" : "R";
    if (t === 2 && (n = this.opts.sagittalNoseLeft ? "P" : "A"), this.opts.isCornerOrientationText) {
      this.drawTextRightBelow([e[0], e[1]], r + s);
      return;
    }
    let o = !0, l = !0;
    const c = this.opts.showAllOrientationMarkers, h = this.opts.showAllOrientationMarkers;
    if (!isNaN(i[0])) {
      const f = this.fontPx + 2;
      i[1] > f && (this.drawTextBelow(
        [e[0] + e[2] * 0.5, e[1] + i[1] - f],
        s
      ), o = !1);
      const d = this.textWidth(f, r) + 2;
      i[0] > d && (this.drawTextRight(
        [e[0] + i[0] - d, e[1] + e[3] * 0.5],
        r
      ), l = !1);
    }
    o && this.drawTextBelow([e[0] + e[2] * 0.5, e[1]], s), l && this.drawTextRight([e[0], e[1] + e[3] * 0.5], r), c && this.drawTextAbove(
      [e[0] + e[2] * 0.5, e[1] + e[3]],
      a
    ), h && this.drawTextLeft(
      [e[0] + e[2], e[1] + e[3] * 0.5],
      n
    );
  }
  /**
   * Computes a plane in mm space for a given slice orientation and depth.
   * @internal
   */
  xyMM2xyzMM(e, t) {
    let i = 2;
    e === 1 && (i = 1), e === 2 && (i = 0);
    let s = [0, 0, 0], r = [1, 1, 0], a = [1, 0, 1];
    s[i] = t, r[i] = t, a[i] = t, s = this.frac2mm(s), r = this.frac2mm(r), a = this.frac2mm(a), s = this.swizzleVec3MM(O(s[0], s[1], s[2]), e), r = this.swizzleVec3MM(O(r[0], r[1], r[2]), e), a = this.swizzleVec3MM(O(a[0], a[1], a[2]), e);
    const n = (r[0] - s[0]) * (a[1] - s[1]) - (a[0] - s[0]) * (r[1] - s[1]);
    let o = (r[0] - s[0]) * (a[2] - s[2]) - (a[0] - s[0]) * (r[2] - s[2]);
    o /= n;
    let l = (r[1] - s[1]) * (a[2] - s[2]) - (a[1] - s[1]) * (r[2] - s[2]);
    l /= n;
    const c = [0, 0, 0, 0, 0];
    return c[0] = s[0], c[1] = s[1], c[2] = s[2], c[3] = l, c[4] = o, c;
  }
  /**
   * Draw a 2D slice tile with appropriate orientation, zoom, pan, and optional mesh overlay.
   * @internal
   */
  draw2DMain(e, t, i = NaN) {
    let s = new Float32Array([0, 0, 0]);
    this.volumes.length > 0 && (s = new Float32Array(this.volumes[0].frac2mm.slice()));
    let r = this.screenFieldOfViewExtendedMM(t), a = it();
    !this.opts.isSliceMM && this.volumes.length > 0 && (s = new Float32Array(this.volumes[0].frac2mmOrtho.slice()), a = mt(this.volumes[0].mm2ortho), r = this.screenFieldOfViewExtendedVox(t));
    let n = this.opts.isRadiologicalConvention && t < 2;
    i === 1 / 0 || i === -1 / 0 ? (n = i !== 1 / 0, t === 1 && (n = !n)) : this.opts.sagittalNoseLeft && t === 2 && (n = !n);
    let o = 0, l = 0;
    t === 2 ? l = n ? 90 : -90 : t === 1 ? l = n ? 180 : 0 : (l = n ? 180 : 0, o = n ? -90 : 90);
    const c = this.gl;
    let h = !1;
    if (e[2] === 0 || e[3] === 0) {
      h = !0;
      const x = c.canvas.width / r.fovMM[0], w = c.canvas.height / r.fovMM[1], v = Math.min(x, w), F = x / v, C = w / v;
      r.fovMM[0] *= F, r.fovMM[1] *= C;
      let b = (r.mnMM[0] + r.mxMM[0]) * 0.5;
      r.mnMM[0] = b - r.fovMM[0] * 0.5, r.mxMM[0] = b + r.fovMM[0] * 0.5, b = (r.mnMM[1] + r.mxMM[1]) * 0.5, r.mnMM[1] = b - r.fovMM[1] * 0.5, r.mxMM[1] = b + r.fovMM[1] * 0.5, e = [0, 0, c.canvas.width, c.canvas.height];
    }
    if (isNaN(i)) {
      const x = this.scene.pan2Dxyzmm, w = this.swizzleVec3MM(O(x[0], x[1], x[2]), t), v = this.scene.pan2Dxyzmm[3];
      r.mnMM[0] -= w[0], r.mxMM[0] -= w[0], r.mnMM[1] -= w[1], r.mxMM[1] -= w[1], r.mnMM[0] /= v, r.mxMM[0] /= v, r.mnMM[1] /= v, r.mxMM[1] /= v;
    }
    let f = 2;
    t === 1 && (f = 1), t === 2 && (f = 0);
    let d = this.scene.crosshairPos[f], u = this.frac2mm(this.scene.crosshairPos);
    !isNaN(i) && i !== 1 / 0 && i !== -1 / 0 && (u = this.frac2mm([0.5, 0.5, 0.5]), u[f] = i, d = this.mm2frac(u)[f]);
    const m = u[f], g = c.canvas.height - e[1] - e[3], p = [
      e[0],
      g,
      e[2],
      e[3]
    ];
    this.clearBounds(c.DEPTH_BUFFER_BIT, p), c.viewport(p[0], p[1], p[2], p[3]);
    let A = this.calculateMvpMatrix2D(
      e,
      r.mnMM,
      r.mxMM,
      1 / 0,
      0,
      l,
      o,
      n
    );
    if (i === 1 / 0 || i === -1 / 0) {
      const x = e.slice();
      this.draw3D(
        e,
        A.modelViewProjectionMatrix,
        A.modelMatrix,
        A.normalMatrix,
        l,
        o
      );
      const w = this.screenSlices[this.screenSlices.length - 1];
      w.leftTopWidthHeight = x, w.axCorSag = t, w.sliceFrac = 1 / 0, w.AxyzMxy = this.xyMM2xyzMM(t, d), w.leftTopMM = A.leftTopMM, w.fovMM = A.fovMM;
      return;
    }
    if (c.enable(c.DEPTH_TEST), c.blendFunc(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA), c.disable(c.BLEND), c.depthFunc(c.ALWAYS), c.disable(c.CULL_FACE), this.volumes.length > 0) {
      let x = this.sliceMMShader;
      if (this.opts.is2DSliceShader && (x = this.slice2DShader), this.opts.isV1SliceShader && (x = this.sliceV1Shader), this.customSliceShader && (x = this.customSliceShader), !x)
        throw new Error("slice Shader undefined");
      x.use(this.gl), c.uniform1f(x.uniforms.overlayOutlineWidth, this.overlayOutlineWidth), c.uniform1f(x.uniforms.overlayAlphaShader, this.overlayAlphaShader), c.uniform1i(x.uniforms.isAlphaClipDark, this.isAlphaClipDark ? 1 : 0), c.uniform1i(x.uniforms.backgroundMasksOverlays, this.backgroundMasksOverlays), c.uniform1f(x.uniforms.drawOpacity, this.drawOpacity), c.uniform1f(x.uniforms.drawRimOpacity, this.drawRimOpacity), c.enable(c.BLEND), c.blendFunc(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA), c.uniform1f(x.uniforms.opacity, this.volumes[0].opacity), c.uniform1i(x.uniforms.axCorSag, t), c.uniform1f(x.uniforms.slice, d), c.uniformMatrix4fv(
        x.uniforms.frac2mm,
        !1,
        s
        // this.volumes[0].frac2mm
      ), c.uniformMatrix4fv(x.uniforms.mvpMtx, !1, A.modelViewProjectionMatrix.slice()), c.bindVertexArray(this.genericVAO), c.drawArrays(c.TRIANGLE_STRIP, 0, 4), c.bindVertexArray(this.unusedVAO), this.screenSlices.push({
        leftTopWidthHeight: e,
        axCorSag: t,
        sliceFrac: d,
        AxyzMxy: this.xyMM2xyzMM(t, d),
        leftTopMM: A.leftTopMM,
        screen2frac: [],
        fovMM: A.fovMM
      });
    }
    if (c.depthMask(!0), c.depthFunc(c.LEQUAL), isNaN(i) && this.drawCrosshairs3D(!0, 1, A.modelViewProjectionMatrix, !0, this.opts.isSliceMM), this.opts.meshThicknessOn2D > 0) {
      this.opts.meshThicknessOn2D !== 1 / 0 && (A = this.calculateMvpMatrix2D(
        e,
        r.mnMM,
        r.mxMM,
        this.opts.meshThicknessOn2D,
        m,
        l,
        o,
        n
      ));
      const x = mt(A.modelViewProjectionMatrix);
      re(x, x, a), this.drawMesh3D(
        !0,
        1,
        x,
        // obj.modelViewProjectionMatrix,
        A.modelMatrix,
        A.normalMatrix,
        !0
      );
    }
    isNaN(i) && this.drawCrosshairs3D(!1, 0.15, A.modelViewProjectionMatrix, !0, this.opts.isSliceMM), h && this.opts.isOrientationTextVisible && this.drawSliceOrientationText(e, t), this.readyForSync = !0;
  }
  /**
   * Draw a 2D slice tile with optional custom size and orientation text.
   * @internal
   */
  draw2D(e, t, i = NaN, s = [NaN, NaN]) {
    const [r, a, n, o] = this.getBoundsRegion();
    let l;
    e[2] === 0 && e[3] === 0 ? this.opts.bounds ? l = [r, a, n, o] : l = [0, 0, this.gl.canvas.width, this.gl.canvas.height] : l = e.slice();
    const c = [NaN, NaN];
    if (s[0] === 1 / 0) {
      const h = this.sliceScale().volScale;
      let f = this.scaleSlice(h[0], h[1], [0, 0], [l[2], l[3]]);
      t === 1 && (f = this.scaleSlice(h[0], h[2], [0, 0], [l[2], l[3]])), t === 2 && (f = this.scaleSlice(h[1], h[2], [0, 0], [l[2], l[3]])), s[0] = f[2], s[1] = f[3];
    }
    isNaN(s[0]) ? this.draw2DMain(l, t, i) : (c[0] = Math.floor(0.5 * (l[2] - s[0])), c[1] = Math.floor(0.5 * (l[3] - s[1])), l[0] += c[0], l[1] += c[1], l[2] = s[0], l[3] = s[1], this.draw2DMain(l, t, i)), !(i === 1 / 0 || i === -1 / 0 || t === 4) && l[2] !== 0 && l[3] !== 0 && this.opts.isOrientationTextVisible && this.drawSliceOrientationText(l, t, c);
  }
  /**
   * Build MVP, Model, and Normal matrices for rendering.
   * Note: 3D MVP is identical for radiological and neurological conventions.
   * @param _unused - Reserved for future use.
   * @param leftTopWidthHeight - Viewport rectangle [x, y, w, h] in device pixels.
   * @param azimuth - Azimuth rotation in degrees.
   * @param elevation - Elevation rotation in degrees.
   * @internal
   */
  calculateMvpMatrix(e, t = [0, 0, 0, 0], i, s) {
    const r = this.gl;
    (t[2] === 0 || t[3] === 0) && (t = [0, 0, r.canvas.width, r.canvas.height]);
    const a = t[2] / t[3];
    let n = this.furthestFromPivot;
    const o = this.pivot3D, l = it();
    n = 0.8 * n / this.scene.volScaleMultiplier, a < 1 ? si(l, -n, n, -n / a, n / a, n * 8, n * 0.01) : si(l, -n * a, n * a, -n, n, n * 8, n * 0.01);
    const c = it();
    c[0] = -1;
    const h = O(0, 0, -n * 1.8);
    me(c, c, h), this.position && me(c, c, this.position), ei(c, c, Xt(270 - s)), ii(c, c, Xt(i - 180)), me(c, c, [-o[0], -o[1], -o[2]]);
    const f = it();
    Vt(f, c);
    const d = it();
    Ut(d, f);
    const u = it();
    return re(u, l, c), [u, c, d];
  }
  /**
   * Computes the model transformation matrix for the given azimuth and elevation.
   * Applies optional oblique RAS rotation if available.
   * @internal
   */
  calculateModelMatrix(e, t) {
    if (!this.back)
      throw new Error("back undefined");
    const i = it();
    if (i[0] = -1, ei(i, i, Xt(270 - t)), ii(i, i, Xt(e - 180)), this.back.obliqueRAS) {
      const s = mt(this.back.obliqueRAS);
      re(i, i, s);
    }
    return i;
  }
  /**
   * Returns the normalized near-to-far ray direction for the given view angles.
   * Ensures components are nonzero to avoid divide-by-zero errors.
   * n.b. volumes can have shear (see shear.html), so invert instead of transpose
   * @internal
   */
  calculateRayDirection(e, t) {
    const i = O(0, 0, -1), s = this.calculateModelMatrix(e, t), r = jt(1, 0, 0, 0, -1, 0, 0, 0, -1), a = nt();
    ks(a, i, r);
    const n = Ji();
    Pn(n, s);
    const o = Ji();
    if (!Nn(o, n))
      return O(0, 0, 1);
    const l = nt();
    ks(l, a, o), Rt(l, l);
    const c = 5e-5;
    for (let h = 0; h < 3; h++)
      Math.abs(l[h]) < c && (l[h] = Math.sign(l[h]) * c || c);
    return l;
  }
  /**
   * Returns the scene's min, max, and range extents in mm or voxel space.
   * Includes both volume and mesh geometry.
   * @internal
   */
  sceneExtentsMinMax(e = !0) {
    let t = O(0, 0, 0), i = O(0, 0, 0);
    if (this.volumes.length > 0) {
      if (!this.volumeObject3D)
        throw new Error("volumeObject3D undefined");
      t = O(
        this.volumeObject3D.extentsMin[0],
        this.volumeObject3D.extentsMin[1],
        this.volumeObject3D.extentsMin[2]
      ), i = O(
        this.volumeObject3D.extentsMax[0],
        this.volumeObject3D.extentsMax[1],
        this.volumeObject3D.extentsMax[2]
      ), e || (t = O(
        this.volumes[0].extentsMinOrtho[0],
        this.volumes[0].extentsMinOrtho[1],
        this.volumes[0].extentsMinOrtho[2]
      ), i = O(
        this.volumes[0].extentsMaxOrtho[0],
        this.volumes[0].extentsMaxOrtho[1],
        this.volumes[0].extentsMaxOrtho[2]
      ));
    }
    if (this.meshes.length > 0) {
      if (this.volumes.length < 1) {
        const r = this.meshes[0].extentsMin, a = this.meshes[0].extentsMax;
        t = O(r[0], r[1], r[2]), i = O(a[0], a[1], a[2]);
      }
      for (let r = 0; r < this.meshes.length; r++) {
        const a = this.meshes[r].extentsMin, n = this.meshes[r].extentsMax, o = O(a[0], a[1], a[2]);
        hs(t, t, o);
        const l = O(n[0], n[1], n[2]);
        fs(i, i, l);
      }
    }
    const s = nt();
    return ot(s, i, t), [t, i, s];
  }
  /**
   * Sets the 3D pivot point and scene scale based on volume and mesh extents.
   * @internal
   */
  setPivot3D() {
    const [e, t] = this.sceneExtentsMinMax(), i = nt();
    le(i, e, t), Gn(i, i, 0.5), this.pivot3D = [i[0], i[1], i[2]], ot(i, t, e), this.extentsMin = e, this.extentsMax = t, this.furthestFromPivot = $t(i) * 0.5;
  }
  /**
   * Returns the maximum number of 4D volumes across all loaded images.
   * @internal
   */
  getMaxVols() {
    if (this.volumes.length < 1)
      return 0;
    let e = 0;
    for (let t = 0; t < this.volumes.length; t++)
      e = Math.max(e, this.volumes[t].nFrame4D);
    return e;
  }
  /**
   * Returns true if any loaded 4D volume is missing frames.
   * @internal
   */
  detectPartialllyLoaded4D() {
    if (this.volumes.length < 1)
      return !1;
    for (let e = 0; e < this.volumes.length; e++)
      if (this.volumes[e].nFrame4D < this.volumes[e].hdr.dims[4])
        return !0;
    return !1;
  }
  /**
   * Draws a graph of 4D volume intensity over time at the current crosshair position.
   * Skips if volume is 3D, region is too small, or graph opacity is zero.
   * @internal
   */
  drawGraph() {
    if (this.getMaxVols() < 2)
      return;
    const e = this.graph, [t, i, s, r] = this.getBoundsRegion();
    let a = 0;
    if (e.autoSizeMultiplanar && this.opts.sliceType === 3)
      for (let z = 0; z < this.screenSlices.length; z++) {
        const K = this.screenSlices[z].axCorSag;
        if (K === 0 && (a = this.screenSlices[z].leftTopWidthHeight[1]), K !== 2)
          continue;
        const W = this.screenSlices[z].leftTopWidthHeight.slice();
        W[1] === a ? (e.LTWH[0] = W[0] + W[2], e.LTWH[1] = W[1]) : (e.LTWH[0] = W[0], e.LTWH[1] = W[1] + W[3]), e.LTWH[2] = W[2], e.LTWH[3] = W[2];
      }
    if (e.LTWH[0] = Math.max(t, e.LTWH[0]), e.LTWH[1] = Math.max(i, e.LTWH[1]), e.LTWH[2] = Math.min(s, e.LTWH[2]), e.LTWH[3] = Math.min(r, e.LTWH[3]), e.opacity <= 0 || e.LTWH[2] <= 5 || e.LTWH[3] <= 5 || Math.floor(e.LTWH[0] + e.LTWH[2]) > t + s || Math.floor(e.LTWH[1] + e.LTWH[3]) > i + r)
      return;
    e.backColor = [0.15, 0.15, 0.15, e.opacity], e.lineColor = [1, 1, 1, 1], this.opts.backColor[0] + this.opts.backColor[1] + this.opts.backColor[2] > 1.5 && (e.backColor = [0.95, 0.95, 0.95, e.opacity], e.lineColor = [0, 0, 0, 1]);
    const n = 0.2, o = 0.3;
    e.lineColor[3] = n, e.textColor = e.lineColor.slice(), e.textColor[3] = 1, e.lineThickness = 3, e.gridLineThickness = 1, e.lineAlpha = 1, e.lines = [];
    const l = [];
    if (e.vols.length < 1)
      this.volumes[0] != null && l.push(0);
    else
      for (let z = 0; z < e.vols.length; z++) {
        const K = e.vols[z];
        this.volumes[K] == null || this.volumes[K].nFrame4D < 2 || l.push(K);
      }
    if (l.length < 1)
      return;
    const c = this.volumes[l[0]].nFrame4D;
    if (this.graph.selectedColumn = this.volumes[l[0]].frame4D, c < 2) {
      V.debug("Unable to generate a graph: Selected volume is 3D not 4D");
      return;
    }
    for (let z = 0; z < l.length; z++) {
      e.lines[z] = [];
      const K = this.frac2vox(this.scene.crosshairPos), W = this.volumes[l[z]];
      let $ = W.nFrame4D;
      $ = Math.min($, c);
      for (let tt = 0; tt < $; tt++) {
        const at = W.getValue(K[0], K[1], K[2], tt);
        e.lines[z].push(at);
      }
    }
    e.lineRGB = [
      [0.8, 0, 0],
      [0, 0.7, 0],
      [0, 0, 0.9],
      [0.7, 0.7, 0],
      [0.8, 0, 0.8],
      [0, 0.7, 0.7],
      [0.6, 0.6, 0.6],
      [0, 0, 0]
    ];
    let h = e.lines[0][0], f = e.lines[0][0];
    for (let z = 0; z < e.lines.length; z++)
      for (let K = 0; K < e.lines[z].length; K++) {
        const W = e.lines[z][K];
        h = Math.min(W, h), f = Math.max(W, f);
      }
    const d = this.volumes[l[0]].cal_min, u = this.volumes[l[0]].cal_max;
    if (e.isRangeCalMinMax && d < u && isFinite(d) && isFinite(u) && (h = d, f = u), e.normalizeValues && f > h) {
      const z = f - h;
      for (let K = 0; K < e.lines.length; K++)
        for (let W = 0; W < e.lines[K].length; W++) {
          const $ = e.lines[K][W];
          e.lines[K][W] = ($ - h) / z;
        }
      h = 0, f = 1;
    }
    h >= f && (f = h + 1), this.drawRect(e.LTWH, e.backColor);
    const [m, g, p] = Ar(h, f), A = Math.max(0, -1 * Math.floor(Math.log(m) / Math.log(10)));
    h = Math.min(g, h), f = Math.max(p, f);
    function x(z) {
      return z.toFixed(6).replace(/\.?0*$/, "");
    }
    let w = this.fontPx * 0.7;
    const v = s / this.uiData.dpr, F = r / this.uiData.dpr, C = v * F, b = 800 * 600;
    C < b ? w = 0 : w = Math.max(w, this.opts.fontMinPx);
    const y = w / this.fontPx;
    let E = 0, S = g;
    if (w > 0)
      for (; S <= f; ) {
        const z = S.toFixed(A), K = this.textWidth(w, z);
        E = Math.max(K, E), S += m;
      }
    const D = 0.05, M = Math.abs(e.LTWH[2]), B = Math.abs(e.LTWH[3]), T = [
      e.LTWH[0] + D * M + E,
      e.LTWH[1] + D * B,
      e.LTWH[2] - E - 2 * D * M,
      e.LTWH[3] - w - 2.5 * D * B
    ];
    this.graph.LTWH = e.LTWH, this.graph.plotLTWH = T, this.drawRect(T, this.opts.backColor);
    const U = f - h, R = T[3] / U, N = T[2] / (e.lines[0].length - 1), k = T[1] + T[3];
    S = g + 0.5 * m;
    const L = e.lineColor.slice();
    for (L[3] = 0.5 * e.lineColor[3]; S <= f; ) {
      const z = k - (S - h) * R;
      this.drawLine([T[0], z, T[0] + T[2], z], e.gridLineThickness, L), S += m;
    }
    S = g;
    const q = 0.5 * e.gridLineThickness;
    for (; S <= f; ) {
      const z = k - (S - h) * R;
      this.drawLine(
        [T[0] - q, z, T[0] + T[2] + e.gridLineThickness, z],
        e.gridLineThickness,
        e.lineColor
      );
      const K = S.toFixed(A);
      w > 0 && this.drawTextLeft([T[0] - 6, z], K, y, e.textColor), S += m;
    }
    let _ = 1;
    for (; e.lines[0].length / _ > 20; )
      _ *= 5;
    for (let z = 0; z < e.lines[0].length; z += _) {
      const K = z * N + T[0];
      let W = e.gridLineThickness;
      if (z % 2 === 1)
        W *= 0.5, this.drawLine([K, T[1], K, T[1] + T[3]], W, L);
      else {
        const $ = x(z);
        w > 0 && this.drawTextBelow([K, 2 + T[1] + T[3]], $, y, e.textColor), this.drawLine([K, T[1], K, T[1] + T[3]], W, e.lineColor);
      }
    }
    for (let z = 0; z < e.lines.length; z++) {
      let K = [1, 0, 0, e.lineAlpha];
      z < e.lineRGB.length && (K = [e.lineRGB[z][0], e.lineRGB[z][1], e.lineRGB[z][2], e.lineAlpha]);
      for (let W = 1; W < e.lines[z].length; W++) {
        const $ = (W - 1) * N, tt = W * N, at = (e.lines[z][W - 1] - h) * R, ut = (e.lines[z][W] - h) * R, bt = [
          T[0] + $,
          T[1] + T[3] - at,
          T[0] + tt,
          T[1] + T[3] - ut
        ];
        this.drawLine(bt, e.lineThickness, K);
      }
    }
    if (e.selectedColumn >= 0 && e.selectedColumn < e.lines[0].length) {
      const z = e.selectedColumn * N + T[0];
      this.drawLine([z, T[1], z, T[1] + T[3]], e.lineThickness, [
        e.lineRGB[0][0],
        e.lineRGB[0][1],
        e.lineRGB[0][2],
        o
      ]);
    }
    w > 0 && e.LTWH[1] + e.LTWH[3] > T[1] + T[3] + w * 2.4 && this.drawTextBelow(
      [T[0] + 0.5 * T[2], T[1] + T[3] + w * 1.2],
      "Volume",
      y,
      e.textColor
    ), this.detectPartialllyLoaded4D() && this.drawTextBelow(
      [T[0] + T[2], T[1] + T[3] + w * 0.5],
      "...",
      y,
      e.textColor
    );
  }
  /**
   * Updates crosshair position using depth-based mouse picking from screen pixel color.
   * Only active when depth picking is enabled.
   * @internal
   */
  depthPicker(e, t) {
    if (!this.uiData.mouseDepthPicker)
      return;
    this.uiData.mouseDepthPicker = !1;
    const i = this.gl, s = this.mousePos[0] * e[2] / e[2], r = i.canvas.height - this.mousePos[1] * e[3] / e[3] - 1, a = new Uint8Array(4);
    if (i.readPixels(
      s,
      // x
      r,
      // y
      1,
      // width
      1,
      // height
      i.RGBA,
      // format
      i.UNSIGNED_BYTE,
      // type
      a
    ), this.selectedObjectId = a[3], this.selectedObjectId === this.VOLUME_ID) {
      this.scene.crosshairPos = new Float32Array(a.slice(0, 3)).map((f) => f / 255);
      return;
    }
    const n = mh(a);
    if (n > 1)
      return;
    const o = (this.mousePos[0] - e[0]) / e[2], l = (i.canvas.height - this.mousePos[1] - e[1]) / e[3], c = ph(o, l, n, t), h = this.mm2frac(c, 0, !0);
    h[0] < 0 || h[0] > 1 || h[1] < 0 || h[1] > 1 || h[2] < 0 || h[2] > 1 || (this.scene.crosshairPos = this.mm2frac(c, 0, !0));
  }
  /**
   * Render a 3D volume visualization of the current NVImage using provided transformation matrices and angles.
   * @internal
   */
  drawImage3D(e, t, i) {
    if (this.volumes.length === 0)
      return;
    const s = this.gl, r = this.calculateRayDirection(t, i), a = this.volumeObject3D;
    if (a) {
      s.enable(s.BLEND), s.blendFunc(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA), s.enable(s.CULL_FACE), s.cullFace(s.FRONT);
      let n = this.renderShader;
      if (this.uiData.mouseDepthPicker && (n = this.pickingImageShader), n.use(this.gl), s.uniform1i(n.uniforms.backgroundMasksOverlays, this.backgroundMasksOverlays), this.gradientTextureAmount > 0 && n.uniforms.normMtx && this.gradientTexture) {
        s.activeTexture(di), s.bindTexture(s.TEXTURE_3D, this.gradientTexture);
        const o = this.calculateModelMatrix(t, i), l = it();
        Vt(l, o);
        const c = it();
        Ut(c, l), s.uniformMatrix4fv(n.uniforms.normMtx, !1, c);
      }
      if (this.drawBitmap && this.drawBitmap.length > 8 ? s.uniform2f(n.uniforms.renderDrawAmbientOcclusionXY, this.renderDrawAmbientOcclusion, this.drawOpacity) : s.uniform2f(n.uniforms.renderDrawAmbientOcclusionXY, this.renderDrawAmbientOcclusion, 0), this.gl.uniform4fv(n.uniforms.paqdUniforms, this.opts.paqdUniforms), s.uniformMatrix4fv(n.uniforms.mvpMtx, !1, e), s.uniformMatrix4fv(n.uniforms.matRAS, !1, this.back.matRAS), s.uniform3fv(n.uniforms.rayDir, r), this.gradientTextureAmount < 0)
        s.uniform4fv(n.uniforms.clipPlane, [
          this.scene.crosshairPos[0],
          this.scene.crosshairPos[1],
          this.scene.crosshairPos[2],
          30
        ]);
      else {
        const l = new Float32Array(24).fill(2);
        for (let c = 0; c < this.scene.clipPlaneDepthAziElevs.length; c++) {
          const h = this.scene.clipPlaneDepthAziElevs[c], f = this.sph2cartDeg(h[1] + 180, h[2]), d = [f[0], f[1], f[2], h[0]];
          l.set(d, c * 4);
        }
        this.gl.uniform4fv(n.uniforms.clipPlanes, l);
      }
      s.uniform1f(n.uniforms.drawOpacity, 1), s.uniform1i(n.uniforms.isClipCutaway, this.opts.isClipPlanesCutaway ? 1 : 0), s.bindVertexArray(a.vao), s.drawElements(a.mode, a.indexCount, s.UNSIGNED_SHORT, 0), s.bindVertexArray(this.unusedVAO);
    }
  }
  /**
   * Draw a small orientation cube indicating L/R, A/P, I/S directions in the given tile area with specified azimuth and elevation.
   * @internal
   */
  drawOrientationCube(e, t = 0, i = 0) {
    if (!this.opts.isOrientCube)
      return;
    const s = 0.05 * Math.min(e[2], e[3]);
    if (s < 5)
      return;
    const r = this.gl;
    r.enable(r.CULL_FACE), r.cullFace(r.BACK), r.disable(r.DEPTH_TEST), this.orientCubeShader.use(this.gl), r.bindVertexArray(this.orientCubeShaderVAO);
    const a = it(), n = it();
    si(n, 0, r.canvas.width, 0, r.canvas.height, -10 * s, 10 * s);
    let o = 0;
    e[1] === 0 && (o = r.canvas.height - this.effectiveCanvasHeight()), me(a, a, [
      1.8 * s + e[0],
      o + 1.8 * s + e[1],
      0
    ]), Ns(a, a, [s, s, s]), ei(a, a, Xt(270 - i)), ii(a, a, Xt(-t));
    const l = it();
    re(l, n, a), r.uniformMatrix4fv(this.orientCubeShader.uniforms.u_matrix, !1, l), r.drawArrays(r.TRIANGLE_STRIP, 0, 168), r.bindVertexArray(this.unusedVAO), this.gl.disable(this.gl.CULL_FACE);
  }
  /**
   * Internal utility to generate human-readable location strings for the onLocationChange callback
   * @param axCorSag - optional axis index for coordinate interpretation (NaN by default)
   * @remarks Computes string representation of current crosshair position in mm (and frame if 4D).
   * @see {@link https://niivue.com/demos/features/modulateAfni.html | live demo usage}
   */
  createOnLocationChange(e = NaN) {
    const [t, i, s] = this.sceneExtentsMinMax(!0), r = Math.max(Math.max(s[0], s[1]), s[2]);
    function a(f) {
      return Math.max(0, -Math.ceil(Math.log10(Math.abs(f))));
    }
    let n = a(r * 1e-3);
    const o = this.frac2mm(this.scene.crosshairPos, 0, !0);
    function l(f, d = 0) {
      return parseFloat(f.toFixed(d));
    }
    let c = l(o[0], n) + "" + l(o[1], n) + "" + l(o[2], n);
    if (this.volumes.length > 0 && this.volumes[0].nFrame4D > 0 && (c += "" + l(this.volumes[0].frame4D)), this.volumes.length > 0) {
      let f = " = ";
      for (let m = 0; m < this.volumes.length; m++) {
        const g = this.volumes[m].mm2vox(o);
        let p = this.volumes[m].getValue(g[0], g[1], g[2], this.volumes[m].frame4D);
        if (n = 3, this.volumes[m].colormapLabel !== null) {
          const A = Math.round(p);
          if (this.volumes[m].hdr.intent_code === 1002 && this.volumes[m].hdr.datatypeCode === 2304) {
            const x = this.volumes[m].getValues(g[0], g[1], g[2], this.volumes[m].frame4D);
            if (x[2] > 2) {
              const w = Math.round(100 * x[2] / 255);
              if (f += this.volumes[m].colormapLabel.labels[x[0]] + ` (${w}%)`, x[3] > 2) {
                const v = Math.round(100 * x[3] / 255);
                f += " " + this.volumes[m].colormapLabel.labels[x[1]] + ` (${v}%)`;
              }
            }
          } else A >= 0 && this.volumes[m].colormapLabel.labels && A < this.volumes[m].colormapLabel.labels.length ? f += this.volumes[m].colormapLabel.labels[A] : f += "undefined(" + l(p, n) + ")";
        } else
          f += l(p, n);
        this.volumes[m].imaginary && (p = this.volumes[m].getValue(g[0], g[1], g[2], this.volumes[m].frame4D, !0), p >= 0 && (f += "+"), f += l(p, n)), f += "   ";
      }
      c += f;
      const d = this.back.dimsRAS, u = d[1] * d[2] * d[3];
      if (this.drawBitmap && this.drawBitmap.length === u) {
        const m = this.frac2vox(this.scene.crosshairPos), g = m[0] + m[1] * d[1] + m[2] * d[1] * d[2];
        c += " " + this.drawLut.labels[this.drawBitmap[g]];
      }
    }
    const h = {
      mm: this.frac2mm(this.scene.crosshairPos, 0, !0),
      axCorSag: e,
      vox: this.frac2vox(this.scene.crosshairPos),
      frac: this.scene.crosshairPos,
      xy: [this.mousePos[0], this.mousePos[1]],
      values: this.volumes.map((f) => {
        const d = this.frac2mm(this.scene.crosshairPos, 0, !0), u = f.mm2vox(d), m = f.getValue(u[0], u[1], u[2], f.frame4D);
        return {
          name: f.name,
          value: m,
          id: f.id,
          mm: d,
          vox: u
        };
      }),
      string: c
    };
    this.onLocationChange(h);
  }
  /**
   * Add a 3D Label
   * @param text - the text content of the label
   * @param style - visual styling options for the label (e.g., color, scale, line width)
   * @param points - a 3D point `[x, y, z]` or array of points to anchor the label in space
   * @param anchor - optional label anchor position (e.g., top-left, center, etc.)
   * @param onClick - optional callback function to invoke when the label is clicked
   * @returns the created `NVLabel3D` instance
   * @see {@link https://niivue.com/demos/features/labels.html | live demo usage}
   */
  addLabel(e, t, i, s, r) {
    const a = {
      textColor: this.opts.legendTextColor,
      textScale: 1,
      textAlignment: "left",
      lineWidth: 0,
      lineColor: this.opts.legendTextColor,
      lineTerminator: "none",
      bulletScale: 0,
      bulletColor: this.opts.legendTextColor
    }, n = t ? { ...a, ...t } : { ...a }, o = new Es(e, { ...n }, i, s, r);
    return this.document.labels.push(o), o;
  }
  /**
   * Calculate the 2D screen coordinates of a 3D point using the provided MVP matrix and tile position/size.
   * @internal
   */
  calculateScreenPoint(e, t, i) {
    const s = Wt();
    return Ct(s, [...e, 1], t), s[3] !== 0 && (s[0] = (s[0] / s[3] + 1) * 0.5 * i[2], s[1] = (1 - s[1] / s[3]) * 0.5 * i[3], s[2] /= s[3], s[0] += i[0], s[1] += i[1]), s;
  }
  /**
   * Return the label located at the given screen coordinates, or null if none found.
   * @internal
   */
  getLabelAtPoint(e) {
    const t = this.legendFontScaling, i = this.fontPx * t, s = this.fontPx * t;
    for (const c of this.document.labels) {
      if (c.anchor == null || c.anchor === 0)
        continue;
      const h = this.fontPx * c.style.textScale * t, f = this.textHeight(h, c.text), d = this.textWidth(h, c.text);
      if (!(c.anchor & 1 && e[0] > d) && !(c.anchor & 2 && (e[0] < (this.gl.canvas.width - d) / 2 || e[0] > (this.gl.canvas.width + d) / 2)) && !(c.anchor & 4 && e[0] < this.gl.canvas.width - d) && !(c.anchor & 8 && (e[1] < s / 2 || e[1] > f + s / 2)) && !(c.anchor & 16 && (e[1] < (this.gl.canvas.height - f - s) / 2 || e[1] > (this.gl.canvas.height + f - s / 2) / 2)) && !(c.anchor & 32 && (e[1] < this.gl.canvas.height - f - s || e[1] > this.gl.canvas.height - s / 2)))
        return c;
    }
    V.debug("screenPoint", e);
    const r = this.getLegendPanelHeight(t), a = this.getLegendPanelWidth(), n = this.gl.canvas.width - a;
    let o = (this.canvas.height - r) / 2;
    if (V.debug("panelrect", n, o, n + a, o + r), e[0] < n || e[1] < o || e[0] > n + a || e[1] > o + r)
      return null;
    const l = this.getConnectomeLabels();
    for (const c of l) {
      const h = this.fontPx * c.style.textScale * t, f = this.textHeight(h, c.text);
      if (e[1] >= o && e[1] <= o + f + i / 2)
        return V.debug(`label clicked ${c.text}`), c;
      o += f, o += i / 2;
    }
    return null;
  }
  /**
   * Draw lines from a 2D label position to its associated 3D points; supports solid and dotted lines.
   * @internal
   */
  drawLabelLine(e, t, i, s, r = !1) {
    const a = Array.isArray(e.points) && Array.isArray(e.points[0]) ? e.points : [e.points];
    for (const n of a) {
      const o = this.calculateScreenPoint(n, i, s);
      r ? this.drawDottedLine([...t, o[0], o[1]], e.style.lineWidth, e.style.lineColor) : this.draw3DLine(
        t,
        [o[0], o[1], o[2]],
        e.style.lineWidth,
        e.style.lineColor
      );
    }
  }
  /**
   * Render a 3D label with optional leader lines, bullet markers, and text alignment within a legend.
   * @internal
   */
  draw3DLabel(e, t, i, s, r, a, n, o = 1) {
    const l = e.text, c = t[0], h = t[1], f = this.fontPx * o, d = this.textHeight(e.style.textScale, l) * f;
    if (e.style.lineWidth > 0 && Array.isArray(e.points) && this.drawLabelLine(e, [c, h + d], i, s, n), e.style.bulletScale) {
      const g = e.style.bulletScale * d, p = d - g, A = h + p / 2 + g / 2, x = c + (r - g) / 2;
      this.drawCircle([x, A, g, g], e.style.bulletColor);
    }
    let u = c;
    if (a)
      if (e.style.textAlignment !== "left") {
        const g = this.textWidth(e.style.textScale, e.text) * f;
        if (e.style.textAlignment === "right")
          u = c + a - f * 1.5 - g;
        else {
          const p = a - (r || f);
          u += (p - g) / 2;
        }
      } else
        u += r;
    const m = e.style.textScale;
    this.drawText([u, h], l, m, e.style.textColor);
  }
  /**
   * Render all visible 3D labels in the legend panel, handling font scaling and layering.
   * @internal
   */
  draw3DLabels(e, t, i = !1) {
    const s = this.getConnectomeLabels();
    if (!this.opts.showLegend || s.length === 0)
      return;
    let r = this.getLegendPanelHeight(1);
    if (!this.canvas || r < 1)
      return;
    const a = this.gl;
    if (a.disable(a.CULL_FACE), a.viewport(0, 0, this.canvas.width, this.canvas.height), this.legendFontScaling = 1, r > this.canvas.height) {
      const u = 10 * this.uiData.dpr;
      this.legendFontScaling = Math.max(this.canvas.height - u, 1) / r, V.debug(`Legend too large for screen, font reduction factor x${this.legendFontScaling}`), r = this.getLegendPanelHeight(this.legendFontScaling);
    }
    const n = this.fontPx * this.legendFontScaling, o = this.getBulletMarginWidth(), l = this.getLegendPanelWidth(), c = a.canvas.width - l;
    let h = (this.canvas.height - r) / 2;
    this.drawRect([a.canvas.width - l, h, l - n, r], this.opts.legendBackgroundColor);
    const f = a.getParameter(a.BLEND), d = a.getParameter(a.DEPTH_FUNC);
    i || (a.disable(a.BLEND), a.depthFunc(a.LEQUAL));
    for (const u of s) {
      this.draw3DLabel(
        u,
        [c, h],
        e,
        t,
        o,
        l,
        i,
        this.legendFontScaling
      );
      const m = this.fontPx * u.style.textScale, g = this.textHeight(m, u.text) * this.legendFontScaling;
      h += g, h += n / 2;
    }
    i || (a.depthFunc(d), f && a.enable(a.BLEND));
  }
  /**
   * Draw all labels anchored to screen edges or corners with background rectangles.
   * @internal
   */
  drawAnchoredLabels() {
    const e = this.fontPx, t = this.document.labels.filter(
      (i) => i.anchor != null && i.anchor !== 0
      /* NONE */
    );
    for (const i of t) {
      const s = i.text, r = this.textHeight(i.style.textScale, s) * e, a = this.textWidth(i.style.textScale, s) * e;
      let n, o;
      const c = this.fontPx * 1, h = c;
      let f = c / 4, d = 0, u = 0;
      i.anchor & 1 && (n = 0), i.anchor & 4 && (n = this.canvas.width - a, d -= c / 4), i.anchor & 2 && (n = (this.canvas.width - a) / 2, d -= c / 4, f += c / 4), i.anchor & 8 && (o = 0), i.anchor & 16 && (o = (this.canvas.height - r - c) / 2, u -= c / 4), i.anchor & 32 && (o = this.canvas.height - r - c, u -= c / 4), this.drawRect(
        [n + d, o + u, a + f, r + h],
        i.style.backgroundColor
      ), this.draw3DLabel(i, [n, o]);
    }
  }
  /**
   * Render the 3D scene including volume, meshes, labels, crosshairs, and orientation cube.
   * @internal
   */
  draw3D(e = [0, 0, 0, 0], t = null, i = null, s = null, r = null, a = 0) {
    const n = this.gl, [o, l, c, h] = this.getBoundsRegion();
    let f = [...e];
    (f[2] === 0 || f[3] === 0) && (f = this.opts.bounds ? [o, l, c, h] : [0, 0, n.canvas.width, n.canvas.height]);
    const d = r !== null;
    this.setPivot3D(), d || (r = this.scene.renderAzimuth, a = this.scene.renderElevation), t === null && ([t, i, s] = this.calculateMvpMatrix(null, f, r, a));
    const u = [...f];
    this.screenSlices.push({
      leftTopWidthHeight: f.slice(),
      // canvas-space
      axCorSag: 4,
      sliceFrac: 0,
      AxyzMxy: [],
      leftTopMM: [],
      fovMM: [gh(i), 0]
    });
    const m = [f[0], n.canvas.height - f[3] - f[1], f[2], f[3]];
    if (f[1] = n.canvas.height - f[3] - f[1], n.clear(n.DEPTH_BUFFER_BIT), n.enable(n.DEPTH_TEST), n.depthFunc(n.ALWAYS), n.depthMask(!0), this.draw3DLabels(t, u, !1), this.gl.viewport(m[0], m[1], m[2], m[3]), this.volumes.length > 0 && (this.updateInterpolation(0, !0), this.updateInterpolation(1, !0), this.drawImage3D(t, r, a)), this.updateInterpolation(0), this.updateInterpolation(1), d || this.drawCrosshairs3D(!0, 1, t), this.drawMesh3D(!0, 1, t, i, s), this.uiData.mouseDepthPicker) {
      this.depthPicker(f, t), this.createOnLocationChange(), this.draw3D(u, t, i, s, r, a);
      return;
    }
    this.opts.meshXRay > 0 && this.drawMesh3D(!1, this.opts.meshXRay, t, i, s), this.gl.disable(this.gl.CULL_FACE), this.draw3DLabels(t, u, !1), n.viewport(f[0], f[1], f[2], f[3]), d || this.drawCrosshairs3D(!1, 0.15, t), n.viewport(o, l, c, h), this.drawOrientationCube(f, r, a);
    const g = "azimuth: " + this.scene.renderAzimuth.toFixed(0) + " elevation: " + this.scene.renderElevation.toFixed(0);
    return this.readyForSync = !0, this.sync(), this.draw3DLabels(t, u, !0), g;
  }
  /**
   * Render all visible 3D meshes with proper blending, depth, and shader settings.
   * @internal
   */
  drawMesh3D(e = !0, t = 1, i, s, r, a = !1) {
    if (this.meshes.length < 1)
      return;
    const n = this.gl;
    i || ([i, s, r] = this.calculateMvpMatrix(
      this.volumeObject3D,
      void 0,
      this.scene.renderAzimuth,
      this.scene.renderElevation
    )), n.enable(n.DEPTH_TEST), e ? n.depthFunc(n.LEQUAL) : n.depthFunc(n.ALWAYS), n.cullFace(n.BACK), n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA);
    let o = !1;
    for (const l of this.meshes) {
      if (!l.visible || l.opacity <= 0 || l.indexCount < 3)
        continue;
      const c = l.opacity * t;
      let h = this.meshShaders[l.meshShaderIndex].shader;
      if (this.uiData.mouseDepthPicker && (h = this.pickingMeshShader), h.use(n), h.isCrosscut) {
        n.disable(n.DEPTH_TEST), n.disable(n.CULL_FACE);
        const f = this.frac2mm(this.scene.crosshairPos, 0, this.opts.isSliceMM);
        n.uniformMatrix4fv(h.uniforms.modelMtx, !1, s), a && (Math.abs(s[2]) + Math.abs(s[4]) + Math.abs(s[9]) >= 2.95 && (f[1] = 1e9, f[2] = 1e9), Math.abs(s[0]) + Math.abs(s[6]) + Math.abs(s[9]) >= 2.95 && (f[0] = 1e9, f[2] = 1e9), Math.abs(s[0]) + Math.abs(s[5]) + Math.abs(s[10]) >= 2.95 && (f[0] = 1e9, f[1] = 1e9));
        let d = Number(this.opts.meshThicknessOn2D);
        Number.isFinite(d) || (d = 1), n.uniform4fv(h.uniforms.sliceMM, [f[0], f[1], f[2], d]);
      } else
        n.enable(n.CULL_FACE), n.enable(n.DEPTH_TEST);
      if (n.uniformMatrix4fv(h.uniforms.mvpMtx, !1, i), n.uniformMatrix4fv(h.uniforms.normMtx, !1, r), n.uniform1f(h.uniforms.opacity, c), c >= 1 ? (n.disable(n.BLEND), n.depthMask(!0)) : (n.enable(n.BLEND), n.depthMask(!1)), l.offsetPt0 && (l.fiberSides < 3 || l.fiberRadius <= 0)) {
        o = !0;
        continue;
      }
      h.isMatcap && (n.activeTexture(ji), n.bindTexture(n.TEXTURE_2D, this.matCapTexture)), n.bindVertexArray(l.vao), n.drawElements(n.TRIANGLES, l.indexCount, n.UNSIGNED_INT, 0), n.bindVertexArray(this.unusedVAO);
    }
    if (n.enable(n.CULL_FACE), this.opts.meshXRay > 0 && !o) {
      n.enable(n.BLEND), n.depthMask(!1), n.depthFunc(n.ALWAYS);
      for (const l of this.meshes) {
        if (!l.visible || l.indexCount < 3)
          continue;
        const c = this.meshShaders[l.meshShaderIndex].shader;
        c.use(n), n.uniformMatrix4fv(c.uniforms.mvpMtx, !1, i), n.uniformMatrix4fv(c.uniforms.normMtx, !1, r), n.uniform1f(c.uniforms.opacity, l.opacity * t * this.opts.meshXRay), n.bindVertexArray(l.vao), n.drawElements(n.TRIANGLES, l.indexCount, n.UNSIGNED_INT, 0), n.bindVertexArray(this.unusedVAO);
      }
      n.depthMask(!0), n.depthFunc(n.GREATER), n.disable(n.BLEND);
    }
    if (o) {
      const l = this.fiberShader;
      l.use(n), n.uniformMatrix4fv(l.uniforms.mvpMtx, !1, i), n.uniform1f(l.uniforms.opacity, t);
      for (const c of this.meshes)
        c.offsetPt0 && (c.fiberSides >= 3 && c.fiberRadius > 0 || (n.bindVertexArray(c.vaoFiber), n.drawElements(n.LINE_STRIP, c.indexCount, n.UNSIGNED_INT, 0), n.bindVertexArray(this.unusedVAO)));
    }
    n.depthMask(!0), n.disable(n.BLEND), this.readyForSync = !0;
  }
  /**
   * Render 3D crosshairs at the current crosshair position with optional depth testing and transparency.
   * @internal
   */
  drawCrosshairs3D(e = !0, t = 1, i = null, s = !1, r = !0) {
    var u, m;
    if (!this.opts.show3Dcrosshair && !s || this.opts.crosshairWidth <= 0 && s)
      return;
    const a = this.gl, n = this.frac2mm(this.scene.crosshairPos, 0, r);
    let o = 1;
    const [l, c, h] = this.sceneExtentsMinMax(r);
    if (this.volumes.length > 0) {
      if (!this.back)
        throw new Error("back undefined");
      o = 0.5 * Math.min(Math.min(this.back.pixDims[1], this.back.pixDims[2]), this.back.pixDims[3]);
    } else (h[0] < 50 || h[0] > 1e3) && (o = h[0] * 0.02);
    if (o *= this.opts.crosshairWidth, ((u = this.opts) == null ? void 0 : u.crosshairWidthUnit) === "percent" && (o = h[0] * this.opts.crosshairWidth * 0.5 * 0.01), ((m = this.opts) == null ? void 0 : m.crosshairWidthUnit) === "mm" && (o = this.opts.crosshairWidth * 0.5), (this.crosshairs3D === null || this.crosshairs3D.mm[0] !== n[0] || this.crosshairs3D.mm[1] !== n[1] || this.crosshairs3D.mm[2] !== n[2]) && (this.crosshairs3D !== null && (a.deleteBuffer(this.crosshairs3D.indexBuffer), a.deleteBuffer(this.crosshairs3D.vertexBuffer)), this.crosshairs3D = he.generateCrosshairs(this.gl, 1, n, l, c, o, 20, this.opts.crosshairGap), this.crosshairs3D.mm = n), !this.surfaceShader)
      throw new Error("surfaceShader undefined");
    const f = this.surfaceShader;
    f.use(this.gl), i == null && ([i] = this.calculateMvpMatrix(
      this.crosshairs3D,
      void 0,
      this.scene.renderAzimuth,
      this.scene.renderElevation
    )), a.uniformMatrix4fv(f.uniforms.mvpMtx, !1, i), a.disable(a.CULL_FACE), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.crosshairs3D.indexBuffer), a.enable(a.DEPTH_TEST);
    const d = [...this.opts.crosshairColor];
    e ? (a.disable(a.BLEND), a.depthFunc(a.LEQUAL)) : (a.enable(a.BLEND), a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA), a.depthFunc(a.ALWAYS)), d[3] = t, a.uniform4fv(f.uniforms.surfaceColor, d), a.bindVertexArray(this.crosshairs3D.vao), a.drawElements(
      a.TRIANGLES,
      this.crosshairs3D.indexCount,
      a.UNSIGNED_INT,
      // gl.UNSIGNED_SHORT,
      0
    ), a.bindVertexArray(this.unusedVAO);
  }
  /**
   * Convert millimeter coordinates to fractional volume coordinates for the specified volume.
   * @internal
   */
  mm2frac(e, t = 0, i = !1) {
    if (this.volumes.length < 1) {
      const s = O(0.1, 0.5, 0.5), [r, a, n] = this.sceneExtentsMinMax();
      return s[0] = (e[0] - r[0]) / n[0], s[1] = (e[1] - r[1]) / n[1], s[2] = (e[2] - r[2]) / n[2], isFinite(s) || (isFinite(s[0]) || (s[0] = 0.5), isFinite(s[1]) || (s[1] = 0.5), isFinite(s[2]) || (s[2] = 0.5), this.meshes.length < 1 && V.error("mm2frac() not finite: objects not (yet) loaded.")), s;
    }
    return this.volumes[t].convertMM2Frac(e, i || this.opts.isSliceMM);
  }
  /**
   * Convert voxel coordinates to fractional volume coordinates for the specified volume.
   * @internal
   */
  vox2frac(e, t = 0) {
    return this.volumes[t].convertVox2Frac(e);
  }
  /**
   * Convert fractional volume coordinates to voxel coordinates for the specified volume.
   * @internal
   */
  frac2vox(e, t = 0) {
    return this.volumes.length <= t ? [0, 0, 0] : this.volumes[t].convertFrac2Vox(e);
  }
  /**
   * move crosshair a fixed number of voxels (not mm)
   * @param x - translate left (-) or right (+)
   * @param y - translate posterior (-) or +anterior (+)
   * @param z - translate inferior (-) or superior (+)
   * @example niivue.moveCrosshairInVox(1, 0, 0)
   * @see {@link https://niivue.com/demos/features/draw2.html | live demo usage}
   */
  moveCrosshairInVox(e, t, i) {
    const s = this.frac2vox(this.scene.crosshairPos), r = s[2];
    s[0] += e, s[1] += t, s[2] += i, s[0] = Hi(s[0], 0, this.volumes[0].dimsRAS[1] - 1), s[1] = Hi(s[1], 0, this.volumes[0].dimsRAS[2] - 1), s[2] = Hi(s[2], 0, this.volumes[0].dimsRAS[3] - 1), this.scene.crosshairPos = this.vox2frac(s), this.createOnLocationChange(), this.opts.is2DSliceShader && r !== s[2] && (this.updateGLVolume(), this.refreshDrawing(!1)), this.drawScene();
  }
  /**
   * Convert fractional volume coordinates to millimeter space for the specified volume.
   * @internal
   */
  frac2mm(e, t = 0, i = !1) {
    const s = ht(e[0], e[1], e[2], 1);
    if (this.volumes.length > 0)
      return this.volumes[t].convertFrac2MM(e, i || this.opts.isSliceMM);
    {
      const [r, a] = this.sceneExtentsMinMax(), n = (o, l, c) => o * (1 - c) + l * c;
      s[0] = n(r[0], a[0], e[0]), s[1] = n(r[1], a[1], e[1]), s[2] = n(r[2], a[2], e[2]);
    }
    return s;
  }
  /**
   * Convert screen pixel coordinates to texture fractional coordinates for the given slice index.
   * @internal
   */
  screenXY2TextureFrac(e, t, i, s = !0) {
    const r = O(-1, -1, -1), a = this.screenSlices[i].axCorSag;
    if (a > 2)
      return r;
    const n = this.screenSlices[i].leftTopWidthHeight.slice();
    let o = !1;
    n[2] < 0 && (o = !0, n[0] += n[2], n[2] = -n[2]);
    let l = (e - n[0]) / n[2];
    o && (l = 1 - l);
    const c = 1 - (t - n[1]) / n[3];
    if (l < 0 || l > 1 || c < 0 || c > 1 || this.screenSlices[i].AxyzMxy.length < 4)
      return r;
    let h = O(0, 0, 0);
    h[0] = this.screenSlices[i].leftTopMM[0] + l * this.screenSlices[i].fovMM[0], h[1] = this.screenSlices[i].leftTopMM[1] + c * this.screenSlices[i].fovMM[1];
    const f = this.screenSlices[i].AxyzMxy;
    h[2] = f[2] + f[4] * (h[1] - f[1]) - f[3] * (h[0] - f[0]), a === 1 && (h = dt(h, [0, 2, 1])), a === 2 && (h = dt(h, [2, 0, 1]));
    const d = this.mm2frac(h);
    return s && (d[0] < 0 || d[0] > 1 || d[1] < 0 || d[1] > 1 || d[2] < 0 || d[2] > 1) ? r : d;
  }
  /**
   * Converts a canvas position to fractional texture coordinates.
   * @internal
   */
  canvasPos2frac(e) {
    for (let t = 0; t < this.screenSlices.length; t++) {
      const i = this.screenXY2TextureFrac(e[0], e[1], t);
      if (i[0] >= 0)
        return i;
    }
    return [-1, -1, -1];
  }
  /**
   * Convert fractional volume coordinates to canvas pixel coordinates.
   * Returns the first valid screen slice that contains the fractional coordinates.
   * @internal
   */
  /**
   * Convert fractional volume coordinates to canvas pixel coordinates with tile information.
   * Returns both canvas position and the tile index for validation.
   * @internal
   */
  frac2canvasPosWithTile(e, t) {
    const i = this.frac2mm(e);
    let s = { distance: 1 / 0 };
    for (let r = 0; r < this.screenSlices.length; r++) {
      const a = this.screenSlices[r].axCorSag;
      if (a > 2 || this.screenSlices[r].AxyzMxy.length < 4 || t !== void 0 && a !== t)
        continue;
      let n = O(i[0], i[1], i[2]);
      a === 1 && (n = dt(n, [0, 2, 1])), a === 2 && (n = dt(n, [1, 2, 0]));
      const o = this.screenSlices[r].AxyzMxy, l = o[2] + o[4] * (n[1] - o[1]) - o[3] * (n[0] - o[0]), c = Math.abs(n[2] - l), h = this.opts.sliceType === 3 ? 1 : 0.1;
      if (c < s.distance && (s = { index: r, distance: c }), c <= h) {
        const f = (n[0] - this.screenSlices[r].leftTopMM[0]) / this.screenSlices[r].fovMM[0], d = (n[1] - this.screenSlices[r].leftTopMM[1]) / this.screenSlices[r].fovMM[1];
        if (f >= 0 && f <= 1 && d >= 0 && d <= 1) {
          const u = this.screenSlices[r].leftTopWidthHeight.slice();
          let m = !1;
          u[2] < 0 && (m = !0, u[0] += u[2], u[2] = -u[2]);
          let g = f;
          m && (g = 1 - f);
          const p = 1 - d, A = u[0] + g * u[2], x = u[1] + p * u[3];
          return { pos: [A, x], tileIndex: r };
        }
      }
    }
    return null;
  }
  frac2canvasPos(e) {
    const t = this.frac2mm(e);
    let i = { index: -1, distance: 1 / 0 };
    for (let s = 0; s < this.screenSlices.length; s++) {
      const r = this.screenSlices[s].axCorSag;
      if (r > 2 || this.screenSlices[s].AxyzMxy.length < 4)
        continue;
      let a = O(t[0], t[1], t[2]);
      r === 1 && (a = dt(a, [0, 2, 1])), r === 2 && (a = dt(a, [1, 2, 0]));
      const n = this.screenSlices[s].AxyzMxy, o = n[2] + n[4] * (a[1] - n[1]) - n[3] * (a[0] - n[0]), l = Math.abs(a[2] - o), c = this.opts.sliceType === 3 ? 1 : 0.1;
      if (l < i.distance && (i = { index: s, distance: l }), l <= c) {
        const h = (a[0] - this.screenSlices[s].leftTopMM[0]) / this.screenSlices[s].fovMM[0], f = (a[1] - this.screenSlices[s].leftTopMM[1]) / this.screenSlices[s].fovMM[1];
        if (h >= 0 && h <= 1 && f >= 0 && f <= 1) {
          const d = this.screenSlices[s].leftTopWidthHeight.slice();
          let u = !1;
          d[2] < 0 && (u = !0, d[0] += d[2], d[2] = -d[2]);
          let m = h;
          u && (m = 1 - h);
          const g = 1 - f, p = d[0] + m * d[2], A = d[1] + g * d[3];
          return [p, A];
        }
      }
    }
    if (i.index >= 0 && i.distance < 2) {
      const s = i.index, r = this.screenSlices[s].axCorSag;
      let a = O(t[0], t[1], t[2]);
      r === 1 && (a = dt(a, [0, 2, 1])), r === 2 && (a = dt(a, [1, 2, 0]));
      const n = this.screenSlices[s].AxyzMxy;
      a[2] = n[2] + n[4] * (a[1] - n[1]) - n[3] * (a[0] - n[0]);
      const o = (a[0] - this.screenSlices[s].leftTopMM[0]) / this.screenSlices[s].fovMM[0], l = (a[1] - this.screenSlices[s].leftTopMM[1]) / this.screenSlices[s].fovMM[1];
      if (o >= -0.1 && o <= 1.1 && l >= -0.1 && l <= 1.1) {
        const c = Math.max(0, Math.min(1, o)), h = Math.max(0, Math.min(1, l)), f = this.screenSlices[s].leftTopWidthHeight.slice();
        let d = !1;
        f[2] < 0 && (d = !0, f[0] += f[2], f[2] = -f[2]);
        let u = c;
        d && (u = 1 - c);
        const m = 1 - h, g = f[0] + u * f[2], p = f[1] + m * f[3];
        return [g, p];
      }
    }
    return null;
  }
  /**
   * Calculates scaled slice dimensions and position within the canvas.
   * n.b. beware of similarly named `sliceScale` method.
   * @internal
   */
  scaleSlice(e, t, i = [0, 0], s = [0, 0]) {
    const r = s[0] === 0 ? this.effectiveCanvasWidth() - i[0] : s[0] - i[0], a = s[1] === 0 ? this.effectiveCanvasHeight() - i[1] : s[1] - i[1];
    let n = r / e;
    t * n > a && (n = a / t);
    const o = e * n, l = t * n;
    return [(r - o) * 0.5, (a - l) * 0.5, o, l, n];
  }
  /**
   * Renders a centered thumbnail image using the bitmap shader.
   * @internal
   */
  drawThumbnail() {
    if (!this.bmpShader)
      throw new Error("bmpShader undefined");
    this.bmpShader.use(this.gl);
    const [e, t, i, s] = this.getBoundsRegion();
    this.gl.uniform2f(this.bmpShader.uniforms.canvasWidthHeight, i, s);
    let r = s, a = s * this.bmpTextureWH;
    a > i && (r = i / this.bmpTextureWH, a = i);
    const n = e + (i - a) / 2, o = t + (s - r) / 2;
    this.gl.uniform4f(this.bmpShader.uniforms.leftTopWidthHeight, n, o, a, r), this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO);
  }
  /**
   * Draws a 2D line with specified thickness and color on the canvas.
   * If alpha < 0, uses the default crosshair color.
   * @internal
   */
  drawLine(e, t = 1, i = [1, 0, 0, -1]) {
    if (this.gl.bindVertexArray(this.genericVAO), !this.lineShader)
      throw new Error("lineShader undefined");
    this.lineShader.use(this.gl), i[3] < 0 && (i = this.opts.crosshairColor), this.gl.uniform4fv(this.lineShader.uniforms.lineColor, i), this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]), this.gl.uniform1f(this.lineShader.uniforms.thickness, t), this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, e), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO);
  }
  /**
   * Draws a 3D line from screen to world space with specified thickness and color.
   * If alpha < 0, uses the default crosshair color.
   * @internal
   */
  draw3DLine(e, t, i = 1, s = [1, 0, 0, -1]) {
    if (this.gl.bindVertexArray(this.genericVAO), !this.line3DShader)
      throw new Error("line3DShader undefined");
    this.line3DShader.use(this.gl), s[3] < 0 && (s = this.opts.crosshairColor), this.gl.uniform4fv(this.line3DShader.uniforms.lineColor, s), this.gl.uniform2fv(this.line3DShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]), this.gl.uniform1f(this.line3DShader.uniforms.thickness, i), this.gl.uniform2fv(this.line3DShader.uniforms.startXY, e), this.gl.uniform3fv(this.line3DShader.uniforms.endXYZ, t), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO);
  }
  /**
   * Draws a dotted 2D line with specified thickness and color.
   * If alpha < 0, uses the default crosshair color with reduced opacity.
   * @internal
   */
  drawDottedLine(e, t = 1, i = [1, 0, 0, -1]) {
    if (this.gl.bindVertexArray(this.genericVAO), !this.lineShader)
      throw new Error("lineShader undefined");
    this.lineShader.use(this.gl);
    const s = i[3] < 0 ? [...this.opts.crosshairColor] : [...i];
    s[3] = 0.3;
    const r = Gs(e[2] - e[0], e[3] - e[1]), a = Ys(r);
    Zn(r, r);
    const o = this.fontPx * 1;
    jn(r, r, o / 2);
    const l = Ys(r);
    let c = Math.floor(a / l);
    a % l && c++;
    const h = [e[0], e[1]];
    this.gl.uniform4fv(this.lineShader.uniforms.lineColor, s), this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [this.gl.canvas.width, this.gl.canvas.height]), this.gl.uniform1f(this.lineShader.uniforms.thickness, t);
    for (let f = 0; f < c - 1; f++) {
      if (f % 2) {
        h[0] += r[0], h[1] += r[1];
        continue;
      }
      const d = [
        h[0],
        h[1],
        h[0] + r[0],
        h[1] + r[1]
      ];
      this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, d), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), h[0] += r[0], h[1] += r[1];
    }
    this.gl.bindVertexArray(this.unusedVAO);
  }
  /**
   * Draw a colored line on the graph using given coordinates, color, and thickness.
   * @internal
   */
  drawGraphLine(e, t = [1, 0, 0, 0.5], i = 2) {
    this.drawLine(e, i, t);
  }
  /**
   * Draw crosshair lines in millimeters on a given 2D slice tile.
   * @internal
   */
  drawCrossLinesMM(e, t, i, s, r) {
    if (e < 0 || this.screenSlices.length <= e)
      return;
    const a = this.screenSlices[e];
    let n = a.sliceFrac;
    n === 1 / 0 && V.debug("Rendering approximate cross lines in world view mode"), n === 1 / 0 && (n = 0.5);
    let l = s.slice(), c = r.slice();
    const h = Math.max(1, this.opts.crosshairWidth);
    t === 1 && (l = i.slice()), t === 2 && (l = i.slice(), c = s.slice());
    function f(d) {
      const u = Gs(0, 0);
      return u[0] = a.leftTopWidthHeight[0] + (d[0] - a.leftTopMM[0]) / a.fovMM[0] * a.leftTopWidthHeight[2], u[1] = a.leftTopWidthHeight[1] + a.leftTopWidthHeight[3] - (d[1] - a.leftTopMM[1]) / a.fovMM[1] * a.leftTopWidthHeight[3], u;
    }
    if (l.length > 0 && t === 0) {
      const d = n, u = 1;
      for (let m = 0; m < l.length; m++) {
        const g = this.frac2mm([0.5, 0.5, 0.5]);
        g[u] = l[m];
        let p = this.mm2frac(g);
        p = p[u];
        let A = this.frac2mm([0, p, d]);
        A = dt(A, [0, 1, 2]);
        let x = this.frac2mm([1, p, d]);
        x = dt(x, [0, 1, 2]), A = f(A), x = f(x), this.drawLine([A[0], A[1], x[0], x[1]], h);
      }
    }
    if (l.length > 0 && t === 1) {
      const d = n, u = 2;
      for (let m = 0; m < l.length; m++) {
        const g = this.frac2mm([0.5, 0.5, 0.5]);
        g[u] = l[m];
        let p = this.mm2frac(g);
        p = p[u];
        let A = this.frac2mm([0, d, p]);
        A = dt(A, [0, 2, 1]);
        let x = this.frac2mm([1, d, p]);
        x = dt(x, [0, 2, 1]), A = f(A), x = f(x), this.drawLine([A[0], A[1], x[0], x[1]], h);
      }
    }
    if (l.length > 0 && t === 2) {
      const d = n, u = 2;
      for (let m = 0; m < l.length; m++) {
        const g = this.frac2mm([0.5, 0.5, 0.5]);
        g[u] = l[m];
        let p = this.mm2frac(g);
        p = p[u];
        let A = this.frac2mm([d, 0, p]);
        A = dt(A, [1, 2, 0]);
        let x = this.frac2mm([d, 1, p]);
        x = dt(x, [1, 2, 0]), A = f(A), x = f(x), this.drawLine([A[0], A[1], x[0], x[1]], h);
      }
    }
    if (c.length > 0 && t === 0) {
      const d = n, u = 0;
      for (let m = 0; m < c.length; m++) {
        const g = this.frac2mm([0.5, 0.5, 0.5]);
        g[u] = c[m];
        let p = this.mm2frac(g);
        p = p[u];
        let A = this.frac2mm([p, 0, d]);
        A = dt(A, [0, 1, 2]);
        let x = this.frac2mm([p, 1, d]);
        x = dt(x, [0, 1, 2]), A = f(A), x = f(x), this.drawLine([A[0], A[1], x[0], x[1]], h);
      }
    }
    if (c.length > 0 && t === 1) {
      const d = n, u = 0;
      for (let m = 0; m < c.length; m++) {
        const g = this.frac2mm([0.5, 0.5, 0.5]);
        g[u] = c[m];
        let p = this.mm2frac(g);
        p = p[u];
        let A = this.frac2mm([p, d, 0]);
        A = dt(A, [0, 2, 1]);
        let x = this.frac2mm([p, d, 1]);
        x = dt(x, [0, 2, 1]), A = f(A), x = f(x), this.drawLine([A[0], A[1], x[0], x[1]], h);
      }
    }
    if (c.length > 0 && t === 2) {
      const d = n, u = 1;
      for (let m = 0; m < c.length; m++) {
        const g = this.frac2mm([0.5, 0.5, 0.5]);
        g[u] = c[m];
        let p = this.mm2frac(g);
        p = p[u];
        let A = this.frac2mm([d, p, 0]);
        A = dt(A, [1, 2, 0]);
        let x = this.frac2mm([d, p, 1]);
        x = dt(x, [1, 2, 0]), A = f(A), x = f(x), this.drawLine([A[0], A[1], x[0], x[1]], h);
      }
    }
  }
  /**
   * Draw crosshair lines on 2D slice tile, delegating to mm-based drawing if appropriate.
   * @internal
   */
  drawCrossLines(e, t, i, s, r) {
    if (e < 0 || this.screenSlices.length <= e)
      return;
    if (this.opts.isSliceMM)
      return this.drawCrossLinesMM(e, t, i, s, r);
    if (this.screenSlices[e].sliceFrac === 1 / 0)
      return this.drawCrossLinesMM(e, t, i, s, r);
    const a = this.screenSlices[e];
    let n = s.slice(), o = r.slice();
    if (t === 1 && (n = i.slice()), t === 2 && (n = i.slice(), o = s.slice()), n.length > 0) {
      const l = a.leftTopWidthHeight.slice();
      let c = 2;
      t === 0 && (c = 1);
      const h = this.frac2mm([0.5, 0.5, 0.5]);
      for (let f = 0; f < n.length; f++) {
        h[c] = n[f];
        const d = this.mm2frac(h);
        this.drawRect([l[0], l[1] + l[3] - d[c] * l[3], l[2], 1]);
      }
    }
    if (o.length > 0) {
      const l = a.leftTopWidthHeight.slice(), c = a.fovMM[0] < 0;
      let h = 0;
      t === 2 && (h = 1);
      const f = this.frac2mm([0.5, 0.5, 0.5]);
      for (let d = 0; d < o.length; d++) {
        f[h] = o[d];
        const u = this.mm2frac(f);
        c ? this.drawRect([l[0] + (l[2] - u[h] * l[2]), l[1], 1, l[3]]) : this.drawRect([l[0] + u[h] * l[2], l[1], 1, l[3]]);
      }
    }
  }
  /**
   * display a lightbox or montage view
   * @param mosaicStr - specifies orientation (A,C,S) and location of slices.
   * @example niivue.setSliceMosaicString("A -10 0 20");
   * @see {@link https://niivue.com/demos/features/mosaics.html | live demo usage}
   */
  drawMosaic(e) {
    var p;
    this.screenSlices = [];
    const [t, i, s, r] = this.getBoundsRegion(), a = this.screenFieldOfViewMM(0, !0), n = this.screenFieldOfViewMM(
      0
      /* AXIAL */
    );
    e = e.replaceAll(";", " ;").trim();
    const o = [], l = [], c = [], h = e.split(/\s+/);
    let f = 1;
    const d = this.fontPx;
    let u = 0, m = 0, g = 0;
    (p = this.volumes[0]) != null && p.dims || (g = Math.ceil(this.opts.tileMargin * 0.3));
    for (let A = 0; A < 2; A++) {
      let x = !1, w = !1, v = 0, F = 0, C = 0, b = 0, y = !1, E = 0, S = 0, D = 0, M = 0;
      for (let U = 0; U < h.length; U++) {
        const R = h[U];
        if (R.includes("X")) {
          w = !0;
          continue;
        }
        if (R.includes("L")) {
          y = !R.includes("-");
          continue;
        }
        if (R.includes("H")) {
          U++, S = Math.abs(Math.max(0, Math.min(1, parseFloat(h[U]))));
          continue;
        }
        if (R.includes("V")) {
          U++;
          continue;
        }
        if (R.includes("A")) {
          E = 0;
          continue;
        }
        if (R.includes("C")) {
          E = 1;
          continue;
        }
        if (R.includes("S")) {
          E = 2;
          continue;
        }
        if (R.includes("R")) {
          x = !0;
          continue;
        }
        if (R.includes(";")) {
          C += v, b = Math.max(b, F + D), v = 0, F = 0, D = 0;
          continue;
        }
        M = D, S > 0 && !x && (M = Math.round(M * (1 - S))), F += M, M = 0;
        const N = parseFloat(R);
        if (isNaN(N))
          continue;
        let k = 0, L = n;
        if (x && (L = a), E === 2 ? M = L[1] : M = L[0], E === 0 ? k = L[1] : k = L[2], A === 0)
          x || (E === 0 && o.push(N), E === 1 && l.push(N), E === 2 && c.push(N));
        else {
          const q = [
            t + u + f * F,
            i + m + f * C,
            f * M,
            f * k
          ];
          if (this.fontPx = y ? d : 0, x) {
            let _ = N < 0 ? -1 / 0 : 1 / 0;
            Object.is(N, -0) && (_ = -1 / 0), this.draw2D(q, E, _);
          } else
            this.draw2D(q, E, N);
          w && this.drawCrossLines(this.screenSlices.length - 1, E, o, l, c), x = !1, w = !1;
        }
        D = M, F += g, v = Math.max(v, k);
      }
      if (C += v, b = Math.max(b, F + D), b <= 0 || C <= 0)
        break;
      const B = (s - 2 * this.opts.tileMargin - g) / b, T = (r - 2 * this.opts.tileMargin) / C;
      f = Math.min(B, T), this.opts.centerMosaic ? (u = Math.floor(0.5 * (s - b * f)), m = Math.floor(0.5 * (r - C * f))) : (u = this.opts.tileMargin, m = this.opts.tileMargin);
    }
    this.fontPx = d;
  }
  /**
   * Calculate width and height to fit a slice within a container, preserving aspect ratio based on slice type and volume scaling.
   * @internal
   */
  calculateWidthHeight(e, t, i, s) {
    let r, a;
    switch (e) {
      case 0:
        r = t[0], a = t[1];
        break;
      case 1:
        r = t[0], a = t[2];
        break;
      case 2:
        r = t[1], a = t[2];
        break;
      default:
        return [i, s];
    }
    const n = r / a, o = i / s;
    let l, c;
    return n > o ? (l = i, c = i / n) : (c = s, l = s * n), [l, c];
  }
  /**
   * Convert opts.bounds into CSS pixel coordinates (for hit testing).
   * @returns [x, y, width, height] in CSS pixels
   */
  getBoundsRegionCSS() {
    const e = this.gl.canvas.getBoundingClientRect();
    if (!this.opts.bounds)
      return [0, 0, e.width, e.height];
    const [[t, i], [s, r]] = this.opts.bounds, a = Math.round(t * e.width), n = Math.round((s - t) * e.width), o = Math.round(i * e.height), l = Math.round(r * e.height), c = l - o, h = e.height - l;
    return [a, h, n, c];
  }
  /**
   * Returns true if a mouse/touch event happened inside this instances bounds.
   */
  eventInBounds(e) {
    const t = this.gl.canvas.getBoundingClientRect();
    let i, s;
    if (e instanceof MouseEvent)
      i = e.clientX, s = e.clientY;
    else if (e instanceof TouchEvent) {
      const h = e.touches[0] ?? e.changedTouches[0];
      if (!h)
        return !1;
      i = h.clientX, s = h.clientY;
    } else
      i = e.clientX, s = e.clientY;
    const r = i - t.left, a = s - t.top, [n, o, l, c] = this.getBoundsRegionCSS();
    return r >= n && r <= n + l && a >= o && a <= o + c;
  }
  /**
   * Check whether the last known mouse cursor position is inside this instance's bounds.
   *
   * Used to filter keyboard events so they are only handled by the Niivue instance
   * whose bounds currently contain the cursor.
   *
   * @returns true if the cursor is inside this.opts.bounds, false otherwise.
   * @internal
   */
  cursorInBounds() {
    if (this.mousePos[0] < 0 || this.mousePos[1] < 0)
      return !1;
    const [e, t, i, s] = this.getBoundsRegion(), [r, a] = this.mousePos;
    return r >= e && r <= e + i && a >= t && a <= t + s;
  }
  /**
   * Compute the current drawing region from opts.bounds.
   * Returns [x, y, width, height] in device pixels, bottom-left origin.
   */
  getBoundsRegion() {
    var u;
    const e = this.gl, t = ((u = this.uiData) == null ? void 0 : u.dpr) || window.devicePixelRatio || 1, i = e.canvas, s = i.clientWidth, r = i.clientHeight;
    if (!this.opts.bounds)
      return [0, 0, e.canvas.width, e.canvas.height];
    const [[a, n], [o, l]] = this.opts.bounds, c = Math.floor(a * s * t), h = Math.ceil((o - a) * s * t);
    let f = Math.floor((1 - l) * r * t), d = Math.ceil((l - n) * r * t);
    return f < 0 && (d += f, f = 0), f + d > e.canvas.height && (d = e.canvas.height - f), [c, f, h, d];
  }
  /**
   * Return true if the given canvas pixel coordinates are inside this Niivue instance's bounds.
   */
  inBounds(e, t) {
    const [i, s, r, a] = this.getBoundsRegion(), n = e * this.uiData.dpr, o = this.gl.canvas.height - t * this.uiData.dpr;
    return n >= i && n <= i + r && o >= s && o <= s + a;
  }
  /**
   * Rebind all textures for this instance.
   * Call this at the start of every draw pass if multiple instances share a GL context.
   */
  bindTextures() {
    this.gl.activeTexture(ie), this.gl.bindTexture(this.gl.TEXTURE_3D, this.volumeTexture), this.gl.activeTexture(fi), this.gl.bindTexture(this.gl.TEXTURE_3D, this.overlayTexture), this.gl.activeTexture(ue), this.gl.bindTexture(this.gl.TEXTURE_3D, this.paqdTexture), this.gl.activeTexture(vr), this.gl.bindTexture(this.gl.TEXTURE_2D, this.fontTexture), this.gl.activeTexture(Se), this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture), this.gl.activeTexture(ji), this.gl.bindTexture(this.gl.TEXTURE_2D, this.matCapTexture), this.gl.activeTexture(di), this.gl.bindTexture(this.gl.TEXTURE_3D, this.gradientTexture);
  }
  /**
   * Clear a rectangular region of this instance's canvas.
   *
   * @param mask - bitmask of buffers to clear (default: color+depth).
   * @param ltwh - optional [x, y, w, h] region in *device px* (GL coords, bottom-left).
   *   If not provided, clears the full instance bounds (getBoundsRegion).
   *   For multiplanar panels, pass the panels own [x,y,w,h].
   */
  clearBounds(e = this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT, t) {
    const i = this.gl, [s, r, a, n] = t ?? this.getBoundsRegion(), o = i.canvas.height - r - n;
    e & i.DEPTH_BUFFER_BIT && i.clearDepth(1), i.enable(i.SCISSOR_TEST), i.scissor(s, o, a, n), e & i.COLOR_BUFFER_BIT && i.clearColor(this.opts.backColor[0], this.opts.backColor[1], this.opts.backColor[2], this.opts.backColor[3]), i.clear(e), i.disable(i.SCISSOR_TEST);
  }
  drawBoundsBorder() {
    if (!this.opts.showBoundsBorder)
      return;
    const [e, t, i, s] = this.getBoundsRegion();
    this.drawBoundsBox([e, t, i, s], this.opts.boundsBorderColor, this.opts.selectionBoxLineThickness);
  }
  /**
   * Core function to draw the entire scene including volumes, meshes, slices, overlays, colorbars, graphs, and handle user interaction like dragging.
   * @internal
   */
  drawSceneCore() {
    var l, c, h;
    if (!this.initialized)
      return;
    this.colorbarHeight = 0;
    const [e, t, i, s] = this.getBoundsRegion();
    if (this.gl.viewport(e, t, i, s), this.clearBounds(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT), this.bindTextures(), this.bmpTexture && this.thumbnailVisible) {
      this.drawThumbnail();
      return;
    }
    let r = "";
    if (this.volumes.length === 0 || typeof this.volumes[0].dims > "u") {
      if (this.meshes.length > 0) {
        if (this.sliceMosaicString.length > 0) {
          this.opts.isColorbar && this.reserveColorbarPanel(), this.drawMosaic(this.sliceMosaicString), this.opts.isColorbar && this.drawColorbar();
          return;
        }
        this.screenSlices = [], this.draw3D([e, t, i, s]), this.opts.isColorbar && this.drawColorbar();
        return;
      }
      this.drawLoadingText(this.opts.loadingText);
      return;
    }
    if (this.uiData.isDragging && this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex][0] < 1.8 && this.inRenderTile(this.uiData.dragStart[0], this.uiData.dragStart[1]) >= 0) {
      const f = this.uiData.dragStart[0] - this.uiData.dragEnd[0], d = this.uiData.dragStart[1] - this.uiData.dragEnd[1], u = this.uiData.dragClipPlaneStartDepthAziElev.slice();
      if (u[1] -= f, u[1] = u[1] % 360, u[2] += d, u[1] !== this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex][1] || u[2] !== this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex][2])
        return this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex] = u, this.setClipPlane(this.scene.clipPlaneDepthAziElevs[this.uiData.activeClipPlaneIndex]);
    }
    if (this.sliceMosaicString.length < 1 && this.opts.sliceType === 4) {
      this.opts.isColorbar && this.reserveColorbarPanel(), this.screenSlices = [], this.draw3D(), this.opts.isColorbar && this.drawColorbar();
      return;
    }
    this.opts.isColorbar && this.reserveColorbarPanel();
    const a = this.getMaxVols(), n = this.opts.sliceType === 3 && a > 1 && this.graph.autoSizeMultiplanar && this.graph.opacity > 0;
    if (this.sliceMosaicString.length > 0)
      this.drawMosaic(this.sliceMosaicString);
    else {
      const f = [0, 0];
      let d = !1;
      if (this.screenSlices = [], this.customLayout && this.customLayout.length > 0) {
        this.screenSlices = [];
        const { volScale: u } = this.sliceScale();
        for (const m of this.customLayout) {
          const { sliceType: g, position: p, sliceMM: A } = m, x = [
            e + p[0] * i,
            t + p[1] * s,
            p[2] * i,
            p[3] * s
          ];
          if (x[0] + x[2] > e + i && (V.warn("adjusting slice width because it would have been clipped"), x[2] = e + i - x[0]), x[1] + x[3] > t + s && (V.warn("adjusting slice height because it would have been clipped"), x[3] = t + s - x[1]), g === 4)
            this.draw3D(x);
          else {
            const w = this.calculateWidthHeight(
              g,
              u,
              x[2],
              x[3]
            );
            this.draw2D(x, g, A ?? NaN, w);
          }
        }
      } else if (this.opts.sliceType === 0 || this.opts.sliceType === 1 || this.opts.sliceType === 2) {
        const { volScale: u } = this.sliceScale(), m = [e, t, i, s], g = this.calculateWidthHeight(
          this.opts.sliceType,
          u,
          m[2],
          m[3]
        );
        this.draw2D([0, 0, 0, 0], this.opts.sliceType, NaN, g);
      } else {
        let u = function(tt, at) {
          return [(tt - 1) * x + tt * w, (at - 1) * x + at * w];
        }, m = !1;
        this.opts.multiplanarForceRender ? (m = !0, this.opts.multiplanarForceRender ? this.opts.multiplanarShowRender = 1 : this.opts.multiplanarShowRender = 2, delete this.opts.multiplanarForceRender) : this.opts.multiplanarShowRender === 1 && (m = !0);
        const g = isFinite(this.drawPenLocation[0]) && this.opts.drawingEnabled, { volScale: p } = this.sliceScale(), A = p.slice();
        this.opts.multiplanarEqualSize && (p[0] = 1, p[1] = 1, p[2] = 1), typeof this.opts.multiplanarPadPixels != "number" && V.debug("multiplanarPadPixels must be numeric");
        const x = parseFloat(`${this.opts.multiplanarPadPixels}`) * this.uiData.dpr;
        let w = this.opts.tileMargin * this.uiData.dpr;
        w < 0 && (w = 2 * (2 + Math.ceil(this.fontPx)));
        const [v, F, C, b] = this.getBoundsRegion();
        let y = [this.effectiveCanvasWidth(), this.effectiveCanvasHeight()];
        this.opts.heroImageFraction > 0 && this.opts.heroImageFraction < 1 && (m = !1, d = !0, y[0] > y[1] && this.opts.multiplanarLayout !== 3 ? f[0] = y[0] * this.opts.heroImageFraction : f[1] = y[1] * this.opts.heroImageFraction, y = [y[0] - f[0], y[1] - f[1]]);
        const E = this.scaleSlice(
          p[0] + p[1],
          p[1] + p[2],
          u(2, 2),
          y
        ), S = Math.max(Math.max(p[1], p[2]), p[0]), D = this.scaleSlice(
          p[0] + p[0] + p[1],
          Math.max(p[1], p[2]),
          u(3, 1),
          y
        ), M = this.scaleSlice(
          p[0] + p[0] + p[1] + S,
          Math.max(p[1], p[2]),
          u(4, 1),
          y
        ), B = this.scaleSlice(S, p[1] + p[2] + p[2], u(1, 3), y), T = this.scaleSlice(S, p[1] + p[2] + p[2] + S, u(1, 4), y);
        let U = !g && (a < 2 || !n), R = !1, N = !1, k = !1;
        this.opts.multiplanarLayout === 1 ? R = !0 : this.opts.multiplanarLayout === 2 ? N = !0 : this.opts.multiplanarLayout === 3 ? k = !0 : B[4] > D[4] && B[4] > E[4] ? R = !0 : D[4] > E[4] ? k = !0 : N = !0;
        let L = E;
        if (R ? (L = B, !d && (m || this.opts.multiplanarShowRender === 2 && T[4] >= B[4]) ? L = T : U = !1) : k && (L = D, !d && (m || this.opts.multiplanarShowRender === 2 && M[4] >= D[4]) ? L = M : U = !1), d) {
          const tt = f[0] === 0 ? C : f[0], at = f[1] === 0 ? b : f[1];
          if (((l = this.opts) == null ? void 0 : l.heroSliceType) === 0 || ((c = this.opts) == null ? void 0 : c.heroSliceType) === 1 || ((h = this.opts) == null ? void 0 : h.heroSliceType) === 2)
            this.draw2D([v, F, tt, at], this.opts.heroSliceType, NaN, [1 / 0, 1 / 0]);
          else {
            const ut = L.slice();
            tt === C && (ut[0] = 0), this.draw3D([v + ut[0], F, tt, at]);
          }
          L[0] += f[0], L[1] += f[1], U = !1;
        }
        const q = p[0] * L[4] + w, _ = p[1] * L[4] + w, z = p[2] * L[4] + w, K = A[0] * L[4], W = A[1] * L[4], $ = A[2] * L[4];
        if (R) {
          if (this.draw2D([v + L[0], F + L[1], q, _], 0, NaN, [K, W]), this.draw2D([v + L[0], F + L[1] + _ + x, q, z], 1, NaN, [
            K,
            $
          ]), this.draw2D([v + L[0], F + L[1] + _ + x + z + x, _, z], 2, NaN, [
            W,
            $
          ]), U) {
            const tt = S * L[4];
            this.draw3D([v + L[0], F + L[1] + _ + z + z + x * 3, tt, tt]);
          }
        } else if (k) {
          if (this.draw2D([v + L[0], F + L[1], q, _], 0, NaN, [K, W]), this.draw2D([v + L[0] + q + x, F + L[1], q, z], 1, NaN, [
            K,
            $
          ]), this.draw2D([v + L[0] + q + q + x * 2, F + L[1], _, z], 2, NaN, [
            W,
            $
          ]), U) {
            const tt = S * L[4];
            this.draw3D([v + L[0] + q + q + _ + x * 3, F + L[1], tt, tt]);
          }
        } else N && (m || (U = !1), this.opts.multiplanarShowRender === 2 && (U = !0), d && (U = !1), this.draw2D([v + L[0], F + L[1] + z + x, q, _], 0, NaN, [
          K,
          W
        ]), this.draw2D([v + L[0], F + L[1], q, z], 1, NaN, [K, $]), this.draw2D([v + L[0] + q + x, F + L[1], _, z], 2, NaN, [
          W,
          $
        ]), U && this.draw3D([v + L[0] + q + x, F + L[1] + z + x, _, _]));
      }
    }
    if (this.opts.isRuler && this.drawRuler(), this.opts.isColorbar && this.drawColorbar(), n && this.drawGraph(), this.uiData.isDragging) {
      if (this.uiData.mouseButtonCenterDown) {
        this.dragForCenterButton([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1],
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        return;
      }
      if (this.getCurrentDragMode() === 4) {
        this.dragForSlicer3D([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1],
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        return;
      }
      if (this.getCurrentDragMode() === 3) {
        this.dragForPanZoom([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1],
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        return;
      }
      if (this.inRenderTile(this.uiData.dragStart[0], this.uiData.dragStart[1]) >= 0)
        return;
      this.getCurrentDragMode() === 2 && this.drawMeasurementTool([
        this.uiData.dragStart[0],
        this.uiData.dragStart[1],
        this.uiData.dragEnd[0],
        this.uiData.dragEnd[1]
      ]), this.getCurrentDragMode() === 7 && this.drawAngleMeasurementTool();
      const f = this.getCurrentDragMode();
      if (f === 1 || f === 6) {
        const d = Math.abs(this.uiData.dragStart[0] - this.uiData.dragEnd[0]), u = Math.abs(this.uiData.dragStart[1] - this.uiData.dragEnd[1]);
        this.drawSelectionBox([
          Math.min(this.uiData.dragStart[0], this.uiData.dragEnd[0]),
          Math.min(this.uiData.dragStart[1], this.uiData.dragEnd[1]),
          d,
          u
        ]);
      }
    }
    for (const f of this.document.completedMeasurements)
      if (this.shouldDrawOnCurrentSlice(f.sliceIndex, f.sliceType, f.slicePosition)) {
        const d = this.mm2frac(f.startMM), u = this.mm2frac(f.endMM), m = this.frac2canvasPosWithTile(d, f.sliceType), g = this.frac2canvasPosWithTile(u, f.sliceType);
        m && g && m.tileIndex === g.tileIndex && this.drawMeasurementTool([
          m.pos[0],
          m.pos[1],
          g.pos[0],
          g.pos[1]
        ]);
      }
    for (let f = 0; f < this.document.completedAngles.length; f++) {
      const d = this.document.completedAngles[f];
      if (this.shouldDrawOnCurrentSlice(d.sliceIndex, d.sliceType, d.slicePosition)) {
        const m = this.mm2frac(d.firstLineMM.start), g = this.mm2frac(d.firstLineMM.end), p = this.mm2frac(d.secondLineMM.start), A = this.mm2frac(d.secondLineMM.end), x = this.frac2canvasPosWithTile(m, d.sliceType), w = this.frac2canvasPosWithTile(g, d.sliceType), v = this.frac2canvasPosWithTile(p, d.sliceType), F = this.frac2canvasPosWithTile(A, d.sliceType);
        if (x && w && v && F && x.tileIndex === w.tileIndex && x.tileIndex === v.tileIndex && x.tileIndex === F.tileIndex) {
          this.drawMeasurementTool(
            [
              x.pos[0],
              x.pos[1],
              w.pos[0],
              w.pos[1]
            ],
            !1
          ), this.drawMeasurementTool(
            [
              v.pos[0],
              v.pos[1],
              F.pos[0],
              F.pos[1]
            ],
            !1
          );
          const C = {
            firstLine: [
              x.pos[0],
              x.pos[1],
              w.pos[0],
              w.pos[1]
            ],
            secondLine: [
              v.pos[0],
              v.pos[1],
              F.pos[0],
              F.pos[1]
            ],
            sliceIndex: d.sliceIndex,
            sliceType: d.sliceType,
            slicePosition: d.slicePosition
          };
          this.drawAngleTextForAngle(C);
        }
      }
    }
    const o = this.frac2mm([this.scene.crosshairPos[0], this.scene.crosshairPos[1], this.scene.crosshairPos[2]]);
    return r = o[0].toFixed(2) + "" + o[1].toFixed(2) + "" + o[2].toFixed(2), this.readyForSync = !0, this.sync(), this.drawAnchoredLabels(), this.drawBoundsBorder(), r;
  }
  /**
   * Manage draw calls to prevent concurrency issues, calling drawSceneCore and handling refresh flags.
   * @internal
   */
  drawScene() {
    if (this.isBusy) {
      this.needsRefresh = !0;
      return;
    }
    this.isBusy = !1, this.needsRefresh = !1;
    let e = this.drawSceneCore();
    return this._gl !== null && this.gl.finish(), this.needsRefresh && (e = this.drawScene()), e;
  }
  /**
   * Getter for WebGL2 rendering context; throws error if context is unavailable.
   * @internal
   */
  get gl() {
    if (!this._gl)
      throw new Error("unable to get WebGL context. Maybe the browser doesn't support WebGL2.");
    return this._gl;
  }
  /**
   * Setter for WebGL2 rendering context.
   * @internal
   */
  set gl(e) {
    this._gl = e;
  }
  /**
   * Find the first and last slices containing drawing data along a given axis
   * @param sliceType - The slice orientation (AXIAL, CORONAL, or SAGITTAL)
   * @returns Object containing first and last slice indices, or null if no data found
   */
  findDrawingBoundarySlices(e) {
    if (!this.back || !this.back.dims || !this.drawBitmap)
      return null;
    const t = { dimX: this.back.dims[1], dimY: this.back.dims[2], dimZ: this.back.dims[3] };
    return oc(e, this.drawBitmap, t);
  }
  /**
   * Interpolate between mask slices using geometric or intensity-guided methods
   * @param sliceIndexLow - Lower slice index (optional, will auto-detect if not provided)
   * @param sliceIndexHigh - Higher slice index (optional, will auto-detect if not provided)
   * @param options - Interpolation options
   */
  interpolateMaskSlices(e, t, i = {}) {
    if (!this.back || !this.back.dims || !this.drawBitmap)
      throw new Error("Background image and drawing bitmap must be loaded");
    const s = { dimX: this.back.dims[1], dimY: this.back.dims[2], dimZ: this.back.dims[3] }, r = this.back.img, a = this.back.global_max;
    dc(
      this.drawBitmap,
      s,
      r,
      a,
      e,
      t,
      i,
      () => this.refreshDrawing(!0)
    );
  }
};
se = /* @__PURE__ */ new WeakMap();
const zt = {
  CANVAS_BG_COLOR: [0.2, 0.2, 0.2, 1],
  // Playback settings
  PLAY_INITIAL_INTERVAL: 500,
  // milliseconds between frames
  PLAY_MIN_INTERVAL: 50,
  // fastest playback speed
  PLAY_SPEED_FACTOR: 0.5,
  // speed multiplier on repeated play clicks
  // UI responsiveness
  SLIDER_DEBOUNCE_MS: 50,
  // debounce time for slice slider
  // Zoom settings
  ZOOM_IN_FACTOR: 1.2,
  // zoom in multiplier
  ZOOM_OUT_FACTOR: 0.8,
  // zoom out multiplier
  // Window/Level settings
  AUTO_LEVEL_PERCENTILE_LOW: 0.02,
  // 2 percentile per contrasto migliore
  AUTO_LEVEL_PERCENTILE_HIGH: 0.98,
  // 98 percentile per contrasto migliore
  AUTO_LEVEL_SAMPLE_RATE: 1e5
}, Fh = ve.extend({
  className: "g-nifti-slice-image",
  initialize: function(e) {
    this.nv = null, this.volumeUrl = null, this.volumeBuffer = null, this.volumeName = null, this.volumeData = null, this.currentOrientation = "axial", this.currentSliceIndex = 0, this.maxSlices = { axial: 0, coronal: 0, sagittal: 0 }, this.onSliceChange = e.onSliceChange || null, this.onVolumeLoaded = e.onVolumeLoaded || null, ve.prototype.initialize.call(this, e);
  },
  destroy: function() {
    if (this.nv) {
      if (this.nv.volumes && this.nv.volumes.length > 0)
        for (let t = this.nv.volumes.length - 1; t >= 0; t--)
          try {
            this.nv.removeVolumeByIndex(t);
          } catch (i) {
            console.warn("Error removing volume:", i);
          }
      this.nv = null;
    }
    const e = this.el.querySelector("canvas");
    e && (e.width = 0, e.height = 0, e.remove()), this.volumeBuffer = null, ve.prototype.destroy.apply(this, arguments);
  },
  /**
   * Set the volume URL for Niivue to load
   * @param {string} url - URL to the NIfTI file
   * @param {string} name - Name of the file (e.g., 'brain.nii.gz')
   */
  setVolumeUrl: function(e, t) {
    return this.volumeUrl = e, this.volumeBuffer = null, this.volumeName = t || "volume.nii.gz", this;
  },
  /**
   * Set the volume from an ArrayBuffer (preferred for caching)
   * @param {ArrayBuffer} buffer - ArrayBuffer containing NIfTI data
   * @param {string} name - Name of the file (e.g., 'brain.nii.gz')
   */
  setVolumeBuffer: function(e, t) {
    return this.volumeBuffer = e, this.volumeUrl = null, this.volumeName = t || "volume.nii.gz", this;
  },
  /**
   * Set orientation (axial, coronal, sagittal)
   */
  setOrientation: function(e) {
    return this.currentOrientation = e, this.nv && this.nv.volumes.length > 0 && this._applyOrientation(), this;
  },
  /**
   * Set the current slice index
   */
  setSlice: function(e) {
    return this.currentSliceIndex = e, this.nv && this.nv.volumes.length > 0 && this._applySlice(), this;
  },
  /**
   * Set window level and width (contrast/brightness)
   */
  setWindowLevel: function(e, t) {
    if (this.nv && this.nv.volumes.length > 0) {
      const i = this.nv.volumes[0], s = e - t / 2, r = e + t / 2;
      i.cal_min = s, i.cal_max = r, this.nv.updateGLVolume();
    }
    return this;
  },
  /**
   * Get volume header info
   */
  getVolumeInfo: function() {
    if (this.nv && this.nv.volumes.length > 0) {
      const e = this.nv.volumes[0];
      return {
        dims: e.dims,
        pixDims: e.pixDims,
        dataType: e.hdr ? e.hdr.datatypeCode : null,
        cal_min: e.cal_min,
        cal_max: e.cal_max,
        global_min: e.global_min,
        global_max: e.global_max
      };
    }
    return null;
  },
  /**
   * Get maximum slices for each orientation
   */
  getMaxSlices: function() {
    return this.maxSlices;
  },
  /**
   * Render the viewer
   */
  render: function() {
    this.$el.empty();
    const e = document.createElement("canvas");
    return e.id = "nifti-canvas-" + Date.now(), e.style.width = "512px", e.style.height = "512px", this.$el.append(e), this.nv = new Ch({
      backColor: zt.CANVAS_BG_COLOR,
      show3Dcrosshair: !1,
      crosshairColor: [0, 0, 0, 0],
      // Alpha = 0 per nascondere completamente il crosshair
      crosshairWidth: 0,
      multiplanarForceRender: !1,
      sliceType: this._getSliceType(),
      isRadiologicalConvention: !0,
      logging: !1,
      // FIX: Usa dragMode pan per permettere spostamento con tasto destro
      // 0 = none, 1 = contrast (windowing), 2 = measurement, 3 = pan
      dragMode: 3
      // pan mode: tasto destro sposta l'immagine senza windowing
    }), this.nv.attachToCanvas(e), e.addEventListener("contextmenu", (t) => (t.preventDefault(), !1)), (this.volumeBuffer || this.volumeUrl) && this._loadVolume(), this;
  },
  /**
   * Load volume from ArrayBuffer or URL
   * Prefers ArrayBuffer (cached) over URL loading
   */
  _loadVolume: function() {
    if (!this.nv) return;
    let e;
    if (this.volumeBuffer)
      e = this.nv.loadFromArrayBuffer(this.volumeBuffer, this.volumeName);
    else if (this.volumeUrl)
      e = this.nv.loadVolumes([{ url: this.volumeUrl, name: this.volumeName }]);
    else
      return;
    e.then(() => {
      if (this.nv.volumes.length > 0) {
        const t = this.nv.volumes[0];
        this.maxSlices = {
          axial: t.dims[3] || 1,
          coronal: t.dims[2] || 1,
          sagittal: t.dims[1] || 1
        }, this._applyOrientation(), this.onVolumeLoaded && this.onVolumeLoaded({
          dims: t.dims,
          pixDims: t.pixDims,
          maxSlices: this.maxSlices,
          cal_min: t.cal_min,
          cal_max: t.cal_max,
          global_min: t.global_min,
          global_max: t.global_max
        });
      }
    }).catch((t) => {
      console.error("Failed to load NIfTI volume:", t);
    });
  },
  /**
   * Apply the current orientation
   */
  _applyOrientation: function() {
    if (!this.nv) return;
    const e = this._getSliceType();
    this.nv.setSliceType(e);
    const t = this.maxSlices[this.currentOrientation] || 1;
    this.currentSliceIndex = Math.floor(t / 2), this._applySlice();
  },
  /**
   * Apply the current slice
   */
  _applySlice: function() {
    if (!this.nv || this.nv.volumes.length === 0) return;
    this.nv.volumes[0];
    const e = this.maxSlices[this.currentOrientation] || 1, t = e > 1 ? this.currentSliceIndex / (e - 1) : 0.5;
    switch (this.currentOrientation) {
      case "axial":
        this.nv.scene.crosshairPos = [0.5, 0.5, t];
        break;
      case "coronal":
        this.nv.scene.crosshairPos = [0.5, t, 0.5];
        break;
      case "sagittal":
        this.nv.scene.crosshairPos = [t, 0.5, 0.5];
        break;
    }
    this.nv.updateGLVolume();
  },
  /**
   * Get Niivue slice type from orientation string
   */
  _getSliceType: function() {
    switch (this.currentOrientation) {
      case "axial":
        return 0;
      case "coronal":
        return 1;
      case "sagittal":
        return 2;
      default:
        return 0;
    }
  },
  /**
   * Auto-adjust window/level based on image histogram with percentiles
   */
  autoLevels: function() {
    if (this.nv && this.nv.volumes.length > 0) {
      const e = this.nv.volumes[0];
      let t, i;
      if (e.img && e.img.length > 1e3) {
        const s = Math.max(1, Math.floor(e.img.length / zt.AUTO_LEVEL_SAMPLE_RATE)), r = [];
        for (let a = 0; a < e.img.length; a += s) {
          const n = e.img[a];
          !isNaN(n) && isFinite(n) && r.push(n);
        }
        if (r.length > 10) {
          r.sort((o, l) => o - l);
          const a = Math.floor(r.length * zt.AUTO_LEVEL_PERCENTILE_LOW), n = Math.floor(r.length * zt.AUTO_LEVEL_PERCENTILE_HIGH);
          t = r[a], i = r[n];
        } else
          t = e.global_min, i = e.global_max;
      } else {
        const s = e.global_max - e.global_min;
        t = e.global_min + s * 0.05, i = e.global_max - s * 0.05;
      }
      return t >= i && (t = e.global_min, i = e.global_max), e.cal_min = t, e.cal_max = i, this.nv.updateGLVolume(), {
        level: (t + i) / 2,
        width: i - t
      };
    }
    return null;
  },
  /**
   * Zoom in
   */
  zoomIn: function() {
    if (this.nv) {
      const e = this.nv.scene.pan2Dxyzmm[3];
      this.nv.scene.pan2Dxyzmm[3] = e * zt.ZOOM_IN_FACTOR, this.nv.drawScene();
    }
    return this;
  },
  /**
   * Zoom out
   */
  zoomOut: function() {
    if (this.nv) {
      const e = this.nv.scene.pan2Dxyzmm[3];
      this.nv.scene.pan2Dxyzmm[3] = e * zt.ZOOM_OUT_FACTOR, this.nv.drawScene();
    }
    return this;
  },
  /**
   * Reset zoom to default
   */
  resetZoom: function() {
    return this.nv && (this.nv.scene.pan2Dxyzmm = [0, 0, 0, 1], this.nv.drawScene()), this;
  },
  /**
   * Navigate to next slice
   */
  nextSlice: function() {
    const e = this.maxSlices[this.currentOrientation] || 1;
    return this.currentSliceIndex < e - 1 && (this.currentSliceIndex++, this._applySlice()), this.currentSliceIndex;
  },
  /**
   * Navigate to previous slice
   */
  previousSlice: function() {
    return this.currentSliceIndex > 0 && (this.currentSliceIndex--, this._applySlice()), this.currentSliceIndex;
  },
  /**
   * Go to first slice
   */
  firstSlice: function() {
    return this.currentSliceIndex = 0, this._applySlice(), this.currentSliceIndex;
  },
  /**
   * Go to last slice
   */
  lastSlice: function() {
    const e = this.maxSlices[this.currentOrientation] || 1;
    return this.currentSliceIndex = e - 1, this._applySlice(), this.currentSliceIndex;
  },
  /**
   * Get current slice index
   */
  getCurrentSlice: function() {
    return this.currentSliceIndex;
  }
});
function Fr(e, t, i, s) {
  return " " + (e + '="' + e + '"');
}
function wn(e, t, i, s) {
  if (!(e instanceof Error)) throw e;
  if (!(typeof window > "u" && t || s)) throw e.message += " on line " + i, e;
  try {
    s = s || require("fs").readFileSync(t, "utf8");
  } catch {
    wn(e, null, i);
  }
  var o = 3, r = s.split(`
`), a = Math.max(i - o, 0), n = Math.min(r.length, i + o), o = r.slice(a, n).map(function(l, c) {
    var h = c + a + 1;
    return (h == i ? "  > " : "    ") + h + "| " + l;
  }).join(`
`);
  throw e.path = t, e.message = (t || "Pug") + ":" + i + `
` + o + `

` + e.message, e;
}
function Mh(e) {
  var t = "", i, s;
  try {
    s = 5, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-container">', s = 6, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-item-info-header">', s = 7, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-doc-text"></i>', s = 8, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + " NIfTI Viewer</div></div>", s = 9, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-panes clearfix">', s = 10, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-left">', s = 12, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-image">', s = 14, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-loading" style="display:none">', s = 15, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-spinner">', s = 16, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-spin icon-spinner"></i></div>', s = 17, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<p class="g-nifti-loading-text">', s = 17, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "Loading", s = 18, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<strong class="g-nifti-loading-filename"></strong></p>', s = 19, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-progress">', s = 20, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-progress-bar" style="width: 0%"></div></div>', s = 21, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<small class="g-nifti-progress-text">', s = 21, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "0%</small></div></div>", s = 24, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-filename">', s = 24, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "Loading...</div>", s = 27, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-controls">', s = 29, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<input class="g-nifti-slider" type="range" min="0" max="100" step="1" value="0"/>', s = 32, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="right">', s = 33, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-first btn btn-sm btn-default" title="First Slice">', s = 34, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-angle-double-left"></i></button>', s = 35, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-previous btn btn-sm btn-default" title="Previous Slice">', s = 36, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-angle-left"></i></button>', s = 37, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-play btn btn-sm btn-default" title="Play">', s = 38, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-play"></i></button>', s = 39, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-pause btn btn-sm btn-default" title="Pause">', s = 40, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-pause"></i></button>', s = 41, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-next btn btn-sm btn-default" title="Next Slice">', s = 42, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-angle-right"></i></button>', s = 43, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-last btn btn-sm btn-default" title="Last Slice">', s = 44, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-angle-double-right"></i></button></div>', s = 47, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="left">', s = 48, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-zoom-in btn btn-sm btn-default" title="Zoom In">', s = 49, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-zoom-in"></i></button>', s = 50, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-zoom-out btn btn-sm btn-default" title="Zoom Out">', s = 51, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-zoom-out"></i></button>', s = 52, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-reset-zoom btn btn-sm btn-default" title="Reset Zoom">', s = 53, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-search"></i></button>', s = 54, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-auto-levels btn btn-sm btn-default" title="Auto Contrast">', s = 55, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-adjust"></i></button></div></div>', s = 58, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-window-level-panel">', s = 59, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-wl-header">', s = 60, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-adjust"></i>', s = 61, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + " Contrast & Brightness", s = 62, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-wl-toggle btn btn-xs btn-link" title="Show/Hide">', s = 63, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<i class="icon-angle-down"></i></button></div>', s = 64, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-wl-controls" style="display:none">', s = 65, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-wl-row">', s = 66, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "<label>", s = 66, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "Window (Contrast):</label>", s = 67, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "<input" + (' class="g-nifti-window-slider" type="range" min="1" max="5000" step="1" value="400"' + Fr("disabled", !0, !0, !1)) + "/>", s = 68, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<span class="g-nifti-window-value">', s = 68, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "400</span></div>", s = 69, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-wl-row">', s = 70, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "<label>", s = 70, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "Level (Brightness):</label>", s = 71, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "<input" + (' class="g-nifti-level-slider" type="range" min="-1000" max="3000" step="1" value="50"' + Fr("disabled", !0, !0, !1)) + "/>", s = 72, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<span class="g-nifti-level-value">', s = 72, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "50</span></div></div></div>", s = 75, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-orientation">', s = 76, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="btn-group btn-group-sm">', s = 77, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-orientation-btn btn btn-default active" data-orientation="axial">', s = 77, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "Axial</button>", s = 78, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-orientation-btn btn btn-default" data-orientation="coronal">', s = 78, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "Coronal</button>", s = 79, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<button class="g-nifti-orientation-btn btn btn-default" data-orientation="sagittal">', s = 79, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + "Sagittal</button></div></div></div>", s = 81, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-right">', s = 83, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiItem.pug", t = t + '<div class="g-nifti-tags"></div></div></div>';
  } catch (r) {
    wn(r, i, s);
  }
  return t;
}
function ui(e) {
  var t = "" + e, i = Eh.exec(t);
  if (!i) return e;
  var s, r, a, n = "";
  for (s = i.index, r = 0; s < t.length; s++) {
    switch (t.charCodeAt(s)) {
      case 34:
        a = "&quot;";
        break;
      case 38:
        a = "&amp;";
        break;
      case 60:
        a = "&lt;";
        break;
      case 62:
        a = "&gt;";
        break;
      default:
        continue;
    }
    r !== s && (n += t.substring(r, s)), r = s + 1, n += a;
  }
  return r !== s ? n + t.substring(r, s) : n;
}
var Eh = /["&<>]/;
function bn(e, t, i, s) {
  if (!(e instanceof Error)) throw e;
  if (!(typeof window > "u" && t || s)) throw e.message += " on line " + i, e;
  try {
    s = s || require("fs").readFileSync(t, "utf8");
  } catch {
    bn(e, null, i);
  }
  var o = 3, r = s.split(`
`), a = Math.max(i - o, 0), n = Math.min(r.length, i + o), o = r.slice(a, n).map(function(l, c) {
    var h = c + a + 1;
    return (h == i ? "  > " : "    ") + h + "| " + l;
  }).join(`
`);
  throw e.path = t, e.message = (t || "Pug") + ":" + i + `
` + o + `

` + e.message, e;
}
function Dh(e) {
  var t = "", i, s, r;
  try {
    var a = e || {};
    (function(n) {
      r = 2, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", n && n.length > 0 ? (r = 3, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + '<table class="table table-condensed g-nifti-metadata-table">', r = 4, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + "<tbody>", r = 5, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", (function() {
        var o = n;
        if (typeof o.length == "number")
          for (var l = 0, c = o.length; l < c; l++) {
            var h = o[l];
            r = 6, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + "<tr>", r = 7, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + '<td class="g-nifti-tag-name">', r = 7, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + ui((i = h.name) == null ? "" : i) + "</td>", r = 8, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + '<td class="g-nifti-tag-value">', r = 8, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + ui((i = h.value) == null ? "" : i) + "</td></tr>";
          }
        else {
          var c = 0;
          for (var l in o) {
            c++;
            var h = o[l];
            r = 6, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + "<tr>", r = 7, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + '<td class="g-nifti-tag-name">', r = 7, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + ui((i = h.name) == null ? "" : i) + "</td>", r = 8, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + '<td class="g-nifti-tag-value">', r = 8, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + ui((i = h.value) == null ? "" : i) + "</td></tr>";
          }
        }
      }).call(this), t = t + "</tbody></table>") : (r = 10, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + '<p class="text-muted">', r = 10, s = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/niftiSliceMetadata.pug", t = t + "Loading metadata...</p>");
    }).call(this, "tags" in a ? a.tags : typeof tags < "u" ? tags : void 0);
  } catch (n) {
    bn(n, s, r);
  }
  return t;
}
function Zi(e, t) {
  let i;
  return function(...s) {
    clearTimeout(i), i = setTimeout(() => e.apply(this, s), t);
  };
}
const Sh = ve.extend({
  className: "g-nifti-tags",
  initialize: function(e) {
    this._metadata = null, this._volumeInfo = null, this._jsonMetadata = null;
  },
  setMetadata: function(e) {
    return this._metadata = e, this;
  },
  setVolumeInfo: function(e) {
    return this._volumeInfo = e, this;
  },
  setJsonMetadata: function(e) {
    return this._jsonMetadata = e, this;
  },
  render: function() {
    const e = this._buildTagList();
    return this.$el.html(Dh({ tags: e })), this;
  },
  _buildTagList: function() {
    const e = [];
    if (this._volumeInfo) {
      const t = this._volumeInfo;
      t.dims && e.push({ name: "Dimensions", value: t.dims.slice(1, 4).join("  ") }), t.pixDims && e.push({ name: "Voxel Size (mm)", value: t.pixDims.slice(1, 4).map((i) => i.toFixed(2)).join("  ") }), t.maxSlices && (e.push({ name: "Axial Slices", value: t.maxSlices.axial }), e.push({ name: "Coronal Slices", value: t.maxSlices.coronal }), e.push({ name: "Sagittal Slices", value: t.maxSlices.sagittal })), t.global_min !== void 0 && t.global_max !== void 0 && e.push({ name: "Intensity Range", value: `${t.global_min.toFixed(2)} - ${t.global_max.toFixed(2)}` });
    }
    if (this._metadata)
      for (const [t, i] of Object.entries(this._metadata))
        typeof i != "object" && e.push({ name: t, value: String(i) });
    if (this._jsonMetadata) {
      e.push({ name: "--- JSON Metadata ---", value: "" });
      for (const [t, i] of Object.entries(this._jsonMetadata)) {
        if (typeof i == "object" && !Array.isArray(i)) continue;
        let s = Array.isArray(i) ? i.join(", ") : String(i);
        s.length > 100 && (s = s.substring(0, 100) + "..."), e.push({ name: t, value: s });
      }
    }
    return e;
  }
}), Ih = ve.extend({
  className: "g-nifti-view",
  events: {
    // Slice navigation via slider
    "input .g-nifti-slider": "_onSliderInput",
    // Navigation buttons
    "click .g-nifti-first": "_firstSlice",
    "click .g-nifti-previous": "_previousSlice",
    "click .g-nifti-play": "play",
    "click .g-nifti-pause": "pause",
    "click .g-nifti-next": "_nextSlice",
    "click .g-nifti-last": "_lastSlice",
    // Zoom controls
    "click .g-nifti-zoom-in": "_zoomIn",
    "click .g-nifti-zoom-out": "_zoomOut",
    "click .g-nifti-reset-zoom": "_resetZoom",
    "click .g-nifti-auto-levels": "_autoLevels",
    // Window/Level controls
    "click .g-nifti-wl-header": "_toggleWindowLevelPanel",
    "input .g-nifti-window-slider": "_onWindowChange",
    "input .g-nifti-level-slider": "_onLevelChange",
    // Orientation buttons
    "click .g-nifti-orientation-btn": "_changeOrientation"
  },
  initialize: function(e) {
    this.item = e.item, this.parentView = e.parentView, this.niftiInfo = this.item.get("nifti"), this._niftiFileModel = null, this._volumeInfo = null, this._jsonMetadata = null, this._sliceImageWidget = null, this._sliceMetadataWidget = null, this._currentOrientation = "axial", this._currentSlice = 0, this._maxSlices = 0, this._playing = !1, this._playInterval = zt.PLAY_INITIAL_INTERVAL, this._playTimer = null, this._currentWindow = 400, this._currentLevel = 50, this._windowLevelPanelVisible = !1, this._debouncedSliderHandler = Zi((t) => {
      this._setSlice(t);
    }, zt.SLIDER_DEBOUNCE_MS), this._debouncedWindowHandler = Zi((t) => {
      this._applyWindowLevel(this._currentLevel, t);
    }, 50), this._debouncedLevelHandler = Zi((t) => {
      this._applyWindowLevel(t, this._currentWindow);
    }, 50);
  },
  _onSliderInput: function(e) {
    const t = parseInt(e.target.value);
    this._debouncedSliderHandler(t);
  },
  render: function() {
    this.niftiInfo.files, this.$el.html(Mh({
      nifti: this.niftiInfo
    })), this._sliceMetadataWidget = new Sh({
      el: this.$(".g-nifti-tags"),
      parentView: this
    }), this._sliceMetadataWidget.setMetadata(this.niftiInfo.meta || {}).render(), this._sliceImageWidget = new Fh({
      el: this.$(".g-nifti-image"),
      parentView: this,
      onVolumeLoaded: (i) => this._onVolumeLoaded(i),
      onSliceChange: (i) => this._onSliceChangeFromWheel(i)
    });
    const e = this.niftiInfo.files[0], t = e.name;
    return this._niftiFileModel = new Un({ _id: e.id }), this.$(".g-nifti-loading").show(), this.$(".g-nifti-loading-filename").text(t), this.$(".g-nifti-filename").text("Loading NIfTI file..."), this._niftiFileModel.getVolumeWithProgress((i, s) => {
      if (s > 0) {
        const r = Math.round(i / s * 100);
        this.$(".g-nifti-progress-bar").css("width", r + "%");
        const a = (i / 1024 / 1024).toFixed(1), n = (s / 1024 / 1024).toFixed(1);
        this.$(".g-nifti-progress-text").text(`${a} MB / ${n} MB (${r}%)`);
      }
    }).then((i) => {
      this.$(".g-nifti-loading").hide(), this._sliceImageWidget.setVolumeBuffer(i, t).render();
    }).catch((i) => {
      console.error("Failed to load NIfTI volume:", i);
      const s = this._getErrorMessage(i);
      this.$(".g-nifti-loading").html(`
                    <div class="alert alert-danger">
                        <i class="icon-warning-sign"></i>
                        <strong>Failed to load NIfTI file</strong>
                        <p>${s}</p>
                        <button class="btn btn-sm btn-primary g-nifti-retry">
                            <i class="icon-refresh"></i> Retry
                        </button>
                    </div>
                `), this.$(".g-nifti-retry").on("click", () => {
        this.render();
      });
    }), this._loadJsonMetadata(), this;
  },
  _onVolumeLoaded: function(e) {
    this._volumeInfo = e, this._maxSlices = e.maxSlices[this._currentOrientation] || 1, this._currentSlice = Math.floor(this._maxSlices / 2), this.$(".g-nifti-slider").attr("max", this._maxSlices - 1).val(this._currentSlice), this._updateSliceLabel(), this._toggleControls(!0);
    const t = this.$(".g-nifti-slider")[0];
    t && !t._wheelListenerAttached && (t.addEventListener("wheel", (i) => {
      i.preventDefault();
      const s = i.deltaY > 0 ? 1 : -1;
      let r = this._currentSlice + s;
      r < 0 && (r = 0), r >= this._maxSlices && (r = this._maxSlices - 1), r !== this._currentSlice && (this._currentSlice = r, this.$(".g-nifti-slider").val(r), this._setSlice(r));
    }), t._wheelListenerAttached = !0), this._sliceMetadataWidget.setVolumeInfo(e).render();
  },
  _loadJsonMetadata: function() {
    const e = (this.niftiInfo.files || []).find(
      (t) => t.name.endsWith(".json")
    );
    e && Sr({
      url: `file/${e.id}/download`,
      method: "GET",
      error: null
    }).done((t) => {
      try {
        this._jsonMetadata = typeof t == "string" ? JSON.parse(t) : t, this._sliceMetadataWidget.setJsonMetadata(this._jsonMetadata).render();
      } catch (i) {
        console.error("Failed to parse JSON metadata:", i);
      }
    });
  },
  _setSlice: function(e) {
    this._currentSlice = e, this._sliceImageWidget && this._sliceImageWidget.setSlice(e), this._updateSliceLabel();
  },
  _updateSliceLabel: function() {
    this.$(".g-nifti-filename").text(
      `${this._currentOrientation.charAt(0).toUpperCase() + this._currentOrientation.slice(1)}: ${this._currentSlice + 1} / ${this._maxSlices}`
    );
  },
  _toggleControls: function(e) {
    this.$(".g-nifti-controls button").girderEnable(e);
  },
  // Navigation methods
  _firstSlice: function() {
    this._setSlice(0), this.$(".g-nifti-slider").val(0);
  },
  _previousSlice: function() {
    let e = this._currentSlice - 1;
    e < 0 && (e = this._maxSlices - 1), this._setSlice(e), this.$(".g-nifti-slider").val(e);
  },
  _nextSlice: function() {
    let e = this._currentSlice + 1;
    e >= this._maxSlices && (e = 0), this._setSlice(e), this.$(".g-nifti-slider").val(e);
  },
  _lastSlice: function() {
    this._setSlice(this._maxSlices - 1), this.$(".g-nifti-slider").val(this._maxSlices - 1);
  },
  // Playback methods
  play: function() {
    this._playTimer && (clearTimeout(this._playTimer), this._playTimer = null), this._playing ? this._playInterval = Math.max(
      zt.PLAY_MIN_INTERVAL,
      this._playInterval * zt.PLAY_SPEED_FACTOR
    ) : this._playing = !0, this._step();
  },
  pause: function() {
    this._playing = !1, this._playInterval = zt.PLAY_INITIAL_INTERVAL, this._playTimer && (clearTimeout(this._playTimer), this._playTimer = null);
  },
  _step: function() {
    this._playing && (this._nextSlice(), this._playTimer = setTimeout(() => this._step(), this._playInterval));
  },
  // Zoom methods
  _zoomIn: function() {
    this._sliceImageWidget && this._sliceImageWidget.zoomIn();
  },
  _zoomOut: function() {
    this._sliceImageWidget && this._sliceImageWidget.zoomOut();
  },
  _resetZoom: function() {
    this._sliceImageWidget && this._sliceImageWidget.resetZoom();
  },
  _autoLevels: function() {
    this._sliceImageWidget && this._sliceImageWidget.autoLevels();
  },
  // Orientation change
  _changeOrientation: function(e) {
    e.preventDefault();
    const t = this.$(e.currentTarget), i = t.data("orientation");
    if (i !== this._currentOrientation) {
      if (this._currentOrientation = i, this.$(".g-nifti-orientation-btn").removeClass("active"), t.addClass("active"), this._sliceImageWidget) {
        this._sliceImageWidget.setOrientation(i);
        const s = this._sliceImageWidget.getMaxSlices();
        this._maxSlices = s[i] || 1, this._currentSlice = this._sliceImageWidget.getCurrentSlice(), this.$(".g-nifti-slider").attr("max", this._maxSlices - 1).val(this._currentSlice);
      }
      this._updateSliceLabel();
    }
  },
  /**
   * Handle slice change from mouse wheel navigation
   * Updates slider and label to reflect Niivue's current position
   */
  _onSliceChangeFromWheel: function(e) {
    this._currentSlice = e, this.$(".g-nifti-slider").val(e), this._updateSliceLabel();
  },
  // Window/Level controls
  _toggleWindowLevelPanel: function() {
    this._windowLevelPanelVisible = !this._windowLevelPanelVisible;
    const e = this.$(".g-nifti-wl-controls"), t = this.$(".g-nifti-wl-toggle i");
    this._windowLevelPanelVisible ? (e.slideDown(200), t.removeClass("icon-angle-down").addClass("icon-angle-up"), this.$(".g-nifti-window-slider").prop("disabled", !1), this.$(".g-nifti-level-slider").prop("disabled", !1)) : (e.slideUp(200), t.removeClass("icon-angle-up").addClass("icon-angle-down"));
  },
  _onWindowChange: function(e) {
    const t = parseInt(e.target.value);
    this._currentWindow = t, this.$(".g-nifti-window-value").text(t), this._debouncedWindowHandler(t);
  },
  _onLevelChange: function(e) {
    const t = parseInt(e.target.value);
    this._currentLevel = t, this.$(".g-nifti-level-value").text(t), this._debouncedLevelHandler(t);
  },
  _applyWindowLevel: function(e, t) {
    this._sliceImageWidget && this._sliceImageWidget.setWindowLevel(e, t);
  },
  _getErrorMessage: function(e) {
    const t = e.message || e.toString();
    return t.includes("404") || t.includes("Not Found") ? "File not found. The NIfTI file may have been deleted or moved." : t.includes("timeout") || t.includes("Timeout") ? "Request timeout. The file is too large or the connection is slow. Please try again." : t.includes("NetworkError") || t.includes("Failed to fetch") ? "Network error. Please check your internet connection and try again." : t.includes("403") || t.includes("Forbidden") ? "Access denied. You do not have permission to view this file." : t.includes("500") || t.includes("Internal Server Error") ? "Server error. Please contact your administrator." : t.includes("decode") || t.includes("parse") ? "Invalid NIfTI file format. The file may be corrupted." : `Error: ${t}`;
  },
  destroy: function() {
    this.pause(), this._sliceImageWidget && this._sliceImageWidget.destroy(), this._sliceMetadataWidget && this._sliceMetadataWidget.destroy(), ve.prototype.destroy.apply(this, arguments);
  }
});
function yn(e, t, i, s) {
  if (!(e instanceof Error)) throw e;
  if (!(typeof window > "u" && t || s)) throw e.message += " on line " + i, e;
  try {
    s = s || require("fs").readFileSync(t, "utf8");
  } catch {
    yn(e, null, i);
  }
  var o = 3, r = s.split(`
`), a = Math.max(i - o, 0), n = Math.min(r.length, i + o), o = r.slice(a, n).map(function(l, c) {
    var h = c + a + 1;
    return (h == i ? "  > " : "    ") + h + "| " + l;
  }).join(`
`);
  throw e.path = t, e.message = (t || "Pug") + ":" + i + `
` + o + `

` + e.message, e;
}
function Th(e) {
  var t = "", i, s;
  try {
    s = 1, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/parseNiftiItem.pug", t = t + '<a class="g-nifti-parse-item g-item-list-command-icon" title="Force NIfTI parsing">', s = 2, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/parseNiftiItem.pug", t = t + '<i class="icon-sitemap"></i>', s = 3, i = "/workspace/nifti_viewer/girder_nifti_viewer/web_client/templates/parseNiftiItem.pug", t = t + " Parse NIfTI</a>";
  } catch (r) {
    yn(r, i, s);
  }
  return t;
}
Tn(Ir, "render", function(e) {
  return this.once("g:rendered", () => {
    this.model.get("_accessLevel") >= In.WRITE && this.$(".g-item-actions-menu").prepend(Th({
      item: this.model,
      currentUser: Sn()
    })), this.model.has("nifti") && new Ih({
      parentView: this,
      item: this.model
    }).render().$el.insertAfter(this.$(".g-item-info"));
  }), e.call(this);
});
Ir.prototype.events["click .g-nifti-parse-item"] = function() {
  Sr({
    method: "POST",
    url: `item/${this.model.id}/parseNifti`,
    error: null
  }).done((e) => {
    Ps.trigger("g:alert", {
      icon: "ok",
      text: "NIfTI item parsed successfully.",
      type: "success",
      timeout: 4e3
    }), this.model.fetch().done(() => {
      this.render();
    });
  }).fail((e) => {
    Ps.trigger("g:alert", {
      icon: "cancel",
      text: e.responseJSON.message || "Failed to parse NIfTI item.",
      type: "danger",
      timeout: 5e3
    });
  });
};
Vn.addMode(
  "nifti",
  ["item"],
  "NIfTI metadata search",
  `You are searching for text in NIfTI metadata. Only Girder items which have been preprocessed to
        extract NIfTI metadata will be searched. The search performs case-insensitive substring matching across:
        - NIfTI header fields (orientation, datatype, dimensions, pixel spacing, units, etc.)
        - BIDS JSON metadata (ProtocolName, Manufacturer, SeriesDescription, etc.)
        - File names

        Example searches: "T1", "MPRAGE", "Siemens", "RAS", "256", "3.0"`
);
//# sourceMappingURL=girder-plugin-nifti-viewer.js.map
